<!DOCTYPE html>
<html>
<head>
  <title>Author Name Normalizer</title>
  <style>
    html, body {
      font-family: -moz-dialog, Arial, sans-serif;
      padding: 12px;
      margin: 0;
      background: #f9f9f9;
      color: #333;
    }
    h1 { margin-top: 0; }
    .summary {
      background: #e8f4fd;
      padding: 10px;
      margin: 8px 0;
      border: 1px solid #b3d9ff;
      border-radius: 4px;
    }
    .summary-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .variant-group {
      margin: 6px 0;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
    }
    .variant-group h3 {
      margin: 0 0 4px 0;
      font-size: 1em;
      color: #0066cc;
    }
    .variant-group h4 { margin: 0 0 10px 0; color: #0066cc; }
    .variant-group-header {
      margin-bottom: 6px;
    }
    .variant-group-summary {
      font-size: 0.8em;
      color: #666;
      margin-bottom: 2px;
    }
    .surname-variant {
      font-style: italic;
    }
    .primary {
      font-weight: bold;
      color: #0066cc;
      margin-bottom: 10px;
      padding: 5px;
      background: #f0f8ff;
      border-radius: 3px;
    }
    .variants-list {
      list-style: none;
      padding: 0;
    }
    .variant {
      margin: 5px 0;
      padding: 5px;
      background: #f9f9f9;
      border-radius: 3px;
    }
    .variant-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin: 8px 0 4px 0;
    }
    .variant-pill {
      display: inline-flex;
      align-items: center;
      padding: 4px 10px;
      border: 1px solid #c8d1dc;
      border-radius: 16px;
      background: #f7f9fc;
      font-size: 0.9em;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
    }
    .variant-pill:hover {
      border-color: #007acc;
      background: #eef5ff;
    }
    .variant-pill.active {
      background: #007acc;
      border-color: #007acc;
      color: #fff;
    }
    .variant-pill.recommended {
      border-color: #2563eb;
      color: #1d4ed8;
      font-weight: 600;
    }
    .frequency { 
      color: #666; 
      font-size: 0.9em; 
      font-style: italic;
    }
    .radio-group {
      margin: 6px 0;
    }
    .radio-group input[type="radio"] {
      margin-right: 5px;
    }
    .radio-group label {
      word-wrap: break-word;
      max-width: 100%;
    }
    .confidence {
      font-size: 0.9em;
      color: #007acc;
      font-weight: bold;
    }
    button { 
      margin: 10px 5px; 
      padding: 8px 16px; 
      border: 1px solid #ccc; 
      border-radius: 3px;
      background: #f0f0f0;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      background: #e0e0e0;
    }
    .custom-normalization {
      margin-top: 12px;
      padding: 10px;
      background: #f6f8fa;
      border-radius: 4px;
      border: 1px solid #d8dee4;
    }
    .custom-normalization label {
      display: block;
      font-weight: 600;
      margin-bottom: 6px;
    }
    .custom-normalization input[type="text"] {
      width: 150px;
      padding: 4px 6px;
      border: 1px solid #c9d1d9;
      border-radius: 3px;
      font-size: 0.9em;
    }
    .custom-normalization input[type="text"]:disabled {
      background: #f0f0f0;
      color: #777;
    }
    .card-actions {
      display: flex;
      gap: 6px;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #e8e8e8;
    }
    .card-actions button {
      margin: 0;
      padding: 4px 10px;
      font-size: 0.85em;
    }
    .card-actions .apply-btn {
      background: #007acc;
      color: white;
      border-color: #0066a8;
    }
    .card-actions .apply-btn:hover:not(:disabled) {
      background: #0066a8;
    }
    .card-actions .not-variants-btn {
      background: #f9f9f9;
      color: #666;
      border-color: #ccc;
    }
    .card-actions .not-variants-btn:hover:not(:disabled) {
      background: #f0f0f0;
      color: #333;
    }
    .progress { 
      margin: 10px 0; 
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .progress-bar { 
      flex: 1; 
      height: 20px; 
      background: #f0f0f0; 
      border-radius: 10px; 
      overflow: hidden;
      border: 1px solid #ccc;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #0066cc, #007acc);
      transition: width 0.3s ease;
      width: 0%;
      min-width: 3px; /* Always show at least a small amount for visual feedback */
    }
    .progress-fill.indeterminate {
      background: linear-gradient(90deg, #0066cc 0%, #007acc 50%, #0066cc 100%);
      background-size: 200% 100%;
      animation: indeterminate-progress 1.5s ease-in-out infinite;
      width: 30% !important;
    }
    @keyframes indeterminate-progress {
      0% { background-position: 100% 0; }
      100% { background-position: -100% 0; }
    }
    .empty-message {
      text-align: center;
      color: #666;
      font-style: italic;
      padding: 20px;
    }
    .empty-message-content {
      text-align: left;
      color: #444;
      font-style: normal;
    }
    .empty-message-content p {
      margin: 8px 0;
    }
    .surname-frequency-list {
      list-style: disc;
      padding-left: 20px;
      margin: 6px 0 0 0;
    }
    .surname-frequency-list li {
      margin: 4px 0;
    }
    .surname-frequency-list .surname {
      font-weight: 600;
      color: #222;
    }
    #progress-container { display: none; }
    #suggestions-container:empty::after {
      content: "No suggestions to display.";
      display: block;
      text-align: center;
      color: #666;
      padding: 20px;
    }
    .selected {
      background-color: #e3f2fd;
      border-color: #2196f3;
    }
    .variant-meta {
      font-size: 0.85em;
      color: #555;
      margin-top: 4px;
    }
    #variant-filter-bar {
      margin: 12px 0 18px;
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    #variant-filter-input {
      flex: 1 1 150px;
      max-width: 200px;
      padding: 4px 6px;
      border: 1px solid #c9d1d9;
      border-radius: 4px;
      font-size: 0.85em;
      background: #fff;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    #variant-filter-input:focus {
      outline: none;
      border-color: #007acc;
      box-shadow: 0 0 0 3px rgba(0, 122, 204, 0.15);
    }
    #variant-filter-summary {
      font-size: 0.9em;
      color: #4b5563;
      white-space: nowrap;
    }
    #variant-section {
      margin: 20px 0;
    }
    #variant-layout {
      display: grid;
      grid-template-columns: 1fr 250px;
      grid-template-rows: auto;
      gap: 10px;
      width: 100%;
    }
    #variant-groups-column {
      grid-column: 1;
      grid-row: 1;
      min-width: 0;
    }
    .variant-detail {
      grid-column: 2;
      grid-row: 1;
      min-width: 250px;
      width: 250px;
      padding: 8px;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      background: #fff;
      box-shadow: 0 3px 8px rgba(15, 23, 42, 0.08);
      max-height: 300px;
      overflow: hidden;
    }
    .variant-detail h4 {
      margin: 0 0 4px 0;
      color: #005a9c;
      font-size: 0.95em;
    }
    .variant-detail-context {
      font-size: 0.8em;
      color: #586069;
      margin-bottom: 6px;
    }
    .variant-detail-empty {
      font-size: 0.85em;
      color: #69737d;
      padding: 8px 0;
    }
    .variant-detail.empty #variant-detail-items,
    .variant-detail.empty .variant-detail-context {
      display: none;
    }
    .variant-detail:not(.empty) .variant-detail-empty {
      display: none;
    }
    .variant-detail-items {
      list-style: none;
      padding-left: 0;
      margin: 0;
      max-height: 200px;
      overflow-y: auto;
      font-size: 0.85em;
    }
    .variant-detail-items li {
      margin: 4px 0;
      padding: 3px 5px;
      background: #fafbfc;
      border-radius: 3px;
    }
    .variant-detail-items li:hover {
      background: #f0f4f8;
    }
    .item-author {
      color: #6a737e;
      font-size: 0.9em;
      font-weight: 500;
    }
    .item-title {
      color: #24292e;
    }
    .item-link {
      color: #005a9c;
      text-decoration: none;
      cursor: pointer;
    }
    .item-link:visited {
      color: #005a9c;
    }
    .item-link:hover {
      text-decoration: underline;
    }
    .item-year {
      color: #6a737e;
      font-size: 0.9em;
    }
    .item-details {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: baseline;
    }
    .item-details .item-author {
      flex: 0 0 auto;
    }
    .item-details .item-link {
      flex: 1 1 auto;
      min-width: 150px;
      color: #005a9c;
      text-decoration: none;
    }
    .item-details .item-link:hover {
      text-decoration: underline;
    }
    .item-details .item-year {
      flex: 0 0 auto;
    }
    @media (max-width: 960px) {
      #variant-layout {
        grid-template-columns: 1fr;
      }
      .variant-detail {
        position: static;
        max-height: none;
      }
    }
  </style>
</head>
<body>
  <h1>Author Name Normalizer</h1>
  <p>Review and apply author name normalizations for your library.</p>

  <!-- Summary header for full-library analysis -->
  <div id="summary-group" class="summary" style="display: none;">
    <h3>Library Analysis Summary</h3>
    <div class="summary-grid">
      <div><strong>Unique surnames:</strong> <span id="summary-total-creators">Loading...</span></div>
      <div><strong>Variant groups:</strong> <span id="summary-variant-groups">Loading...</span></div>
      <div><strong>Pending normalizations:</strong> <span id="summary-pending-normalizations">Loading...</span></div>
    </div>
  </div>

  <!-- Progress indicator for batch processing -->
  <div id="progress-container" class="progress">
    <div class="progress-bar">
      <div id="progress-fill" class="progress-fill"></div>
    </div>
    <span id="progress-label">Processing...</span>
  </div>

  <!-- Variant groups + detail layout -->
  <div id="variant-section">
    <h3>Creator Variant Groups</h3>
    <p id="variant-groups-description">Review variant groups discovered in your library. Each entry represents multiple creator spellings that may refer to the same person.</p>
    <div id="variant-filter-bar">
      <input type="search" id="variant-filter-input" placeholder="Filter variant groupsâ€¦" aria-label="Filter variant groups">
      <span id="variant-filter-summary">Showing all groups</span>
    </div>
    <div id="variant-layout">
      <div id="variant-groups-column">
        <div id="variant-groups-container">
          <!-- Variant groups will be dynamically populated here -->
        </div>
      </div>
      <aside id="variant-detail-panel" class="variant-detail empty hidden">
        <h4 id="variant-detail-title">Variant details</h4>
        <div id="variant-detail-context" class="variant-detail-context"></div>
        <div id="variant-detail-empty" class="variant-detail-empty">Select a variant pill to review sample items and occurrences.</div>
        <ul id="variant-detail-items"></ul>
      </aside>
    </div>
  </div>

  <!-- Empty state -->
  <div id="empty-message" class="empty-message" style="display: none;">
    No variant groups found. All creator names appear to be consistent.
  </div>

  <!-- Action buttons -->
  <div style="text-align: right; margin-top: 20px;">
    <button id="apply-all-button" disabled style="margin-right: 10px;">Apply All Selected</button>
    <button id="apply-button" disabled>Apply Selected</button>
    <button id="cancel-button">Cancel</button>
  </div>

  <script type="application/javascript" src="chrome://zoteronamenormalizer/content/scripts/zotero-ner-bundled.js"></script>
  <script type="application/javascript">
    /* global Zotero, ZoteroNER */

    // HTML DOM utils
    const ZoteroNER_HTMLUtils = {
      getElement: function(id) {
        return document.getElementById(id);
      },
      createElement: function(tagName, attributes = {}) {
        const el = document.createElement(tagName);
        for (const [key, value] of Object.entries(attributes)) {
          el.setAttribute(key, value);
        }
        return el;
      },
      appendTo: function(parentId, child) {
        const parent = this.getElement(parentId);
        if (parent) parent.appendChild(child);
      },
      clearContainer: function(id) {
        const container = this.getElement(id);
        if (container) container.innerHTML = '';
      },
      setText: function(id, text) {
        const el = this.getElement(id);
        if (el) el.textContent = text;
      },
      setHidden: function(id, hidden) {
        const el = this.getElement(id);
        if (el) el.style.display = hidden ? 'none' : 'block';
      },
      updateProgressBar: function(percent) {
        const fill = document.getElementById('progress-fill');
        if (fill) fill.style.width = percent + '%';
      },
      updateProgressLabel: function(text) {
        const label = document.getElementById('progress-label');
        if (label) label.textContent = text;
      }
    };

    // Embedded controller
    var ZoteroNER_NormalizationDialog = {
      dbAnalyzer: null,
      isProcessing: false,
    analysisResults: null,
    items: null,
    analysisResultsSource: null,
    userSelections: null,
    variantDetailState: null,
    filterText: '',
    currentProgressState: null,

      // File-based logger for debugging
      fileLogger: {
        logPath: '/tmp/zotero-normalizer.log',
        log: function(msg) {
          try {
            const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
            const line = timestamp + ' ' + msg + '\n';
            if (typeof Components !== 'undefined') {
              // Firefox/XUL context - use nsIFileOutputStream
              const file = Components.classes['@mozilla.org/file/directory_service;1']
                .getService(Components.interfaces.nsIProperties)
                .get('TmpD', Components.interfaces.nsIFile);
              file.append('zotero-normalizer.log');
              const fos = Components.classes['@mozilla.org/network/file-output-stream;1']
                .createInstance(Components.interfaces.nsIFileOutputStream);
              fos.init(file, 0x02 | 0x08 | 0x10, 0o644, 0);
              const data = new TextEncoder().encode(line);
              fos.write(line, data.length);
              fos.close();
            }
            // Also log to console for immediate feedback
            console.log('NER-LOG: ' + msg);
          } catch(e) {
            console.log('NER-LOG: ' + msg);
          }
        }
      },

      init: function() {
        console.log('Dialog initialization started');
        this.fileLogger.log('=== Dialog init started ===');
        this.userSelections = new Map();
        this.variantDetailState = null;
        this.filterText = '';
        this.currentProgressState = null;

        // Set up event delegation for clickable item links
        document.addEventListener('click', (event) => {
          const link = event.target.closest('.item-link');
          if (link) {
            event.preventDefault();
            const itemKey = link.getAttribute('data-item-key');
            // Show debug in the detail panel
            const debugEl = document.getElementById('variant-detail-items');
            if (debugEl && debugEl.firstChild && debugEl.firstChild.className === 'debug-info') {
              debugEl.firstChild.textContent = 'DEBUG: Clicked itemKey=' + itemKey;
            }
            if (itemKey) {
              // Try to select the item in Zotero using multiple methods
              const opener = window.opener;
              if (opener) {
                try {
                  // Method 1: Use ZoteroPane (internal API, most reliable)
                  if (opener.ZoteroPane && opener.ZoteroPane.selectItem) {
                    // Try to resolve key to ID if possible
                    if (opener.Zotero && opener.Zotero.Items && opener.Zotero.Items.getByLibraryAndKeyAsync) {
                      const libraryID = opener.Zotero.Libraries.userLibraryID;
                      opener.Zotero.Items.getByLibraryAndKeyAsync(libraryID, itemKey).then(item => {
                        if (item && item.id) {
                          opener.ZoteroPane.selectItem(item.id);
                        } else {
                          // Fallback: try with key (may not work)
                          opener.ZoteroPane.selectItem(itemKey);
                        }
                      }).catch(e => {
                        console.error('Failed to get item by key:', e);
                      });
                      return;
                    } else {
                      opener.ZoteroPane.selectItem(itemKey);
                      return;
                    }
                  }
                  // Method 2: Use Zotero.NameNormalizer.selectItem (our helper)
                  if (opener.Zotero && opener.Zotero.NameNormalizer && opener.Zotero.NameNormalizer.selectItem) {
                    opener.Zotero.NameNormalizer.selectItem(itemKey);
                    return;
                  }
                  // Method 3: Use Zotero.launchURL with zotero:// URI (least reliable)
                  if (opener.Zotero && opener.Zotero.launchURL) {
                    const url = 'zotero://select/library/items/' + itemKey;
                    opener.Zotero.launchURL(url);
                    return;
                  }
                  console.error('No method available to select item');
                } catch (e) {
                  console.error('Failed to select item:', e);
                  if (debugEl && debugEl.firstChild && debugEl.firstChild.className === 'debug-info') {
                    debugEl.firstChild.textContent = 'DEBUG: Error selecting item: ' + e.message;
                  }
                }
              } else {
                if (debugEl && debugEl.firstChild && debugEl.firstChild.className === 'debug-info') {
                  debugEl.firstChild.textContent = 'DEBUG: No opener window';
                }
              }
            }
          }
        });

        this.setupFilterInput();
        Promise.resolve(this.initialize()).catch((error) => {
          console.error(error);
          this.alert('Error', 'Failed to initialize: ' + error.message);
          window.close();
        });
      },

      unwrapDialogParams: function(raw) {
        if (!raw) {
          return raw;
        }

        try {
          if (raw.wrappedJSObject) {
            return raw.wrappedJSObject;
          }
        } catch (err) {
          this.log('Failed to access wrappedJSObject: ' + err.message);
        }

        if (typeof raw.getProperty === 'function') {
          try {
            const wrapped = raw.getProperty('wrappedJSObject');
            if (wrapped) {
              return wrapped;
            }
          } catch (err) {
            this.log('No wrappedJSObject property in param bag: ' + err.message);
          }

          let items;
          let analysisResults;
          let analysisResultsJSON;

          try {
            items = raw.getProperty('items');
          } catch (err) {
            this.log('Unable to read items from param bag: ' + err.message);
          }

          try {
            analysisResults = raw.getProperty('analysisResults');
          } catch (err) {
            this.log('Unable to read analysisResults from param bag: ' + err.message);
          }

          try {
            analysisResultsJSON = raw.getProperty('analysisResultsJSON');
          } catch (err) {
            this.log('Unable to read analysisResultsJSON from param bag: ' + err.message);
          }

          if (analysisResultsJSON || analysisResults || items) {
            return {
              items,
              analysisResults,
              analysisResultsJSON
            };
          }
        }

        return raw;
      },

      sanitizeAnalysisResults: function(value, contextLabel = 'analysis results') {
        if (!value || typeof value !== 'object') {
          return null;
        }

        try {
          const plain = JSON.parse(JSON.stringify(value));
          this.log('Sanitized ' + contextLabel + ' (suggestions: ' + ((plain && Array.isArray(plain.suggestions)) ? plain.suggestions.length : 'unknown') + ')');
          return plain;
        } catch (err) {
          this.log('Failed to sanitize ' + contextLabel + ': ' + err.message);
        }

        return null;
      },

      safeParseJSON: function(jsonString, contextLabel = 'analysisResultsJSON') {
        if (!jsonString || typeof jsonString !== 'string') {
          return null;
        }

        try {
          const parsed = JSON.parse(jsonString);
          this.log('Parsed ' + contextLabel + ' (suggestions: ' + ((parsed && Array.isArray(parsed.suggestions)) ? parsed.suggestions.length : 'unknown') + ')');
          return parsed;
        } catch (err) {
          this.log('Failed to parse ' + contextLabel + ': ' + err.message);
        }

        return null;
      },

      resolveAnalysisResults: function(params, contextLabel = 'dialog params') {
        if (!params) {
          return null;
        }

        if (params.analysisResults && typeof params.analysisResults === 'object') {
          const sanitized = this.sanitizeAnalysisResults(params.analysisResults, contextLabel + '.analysisResults');
          if (sanitized) {
            this.analysisResultsSource = contextLabel + '.analysisResults';
            return sanitized;
          }
        }

        if (params.analysisResultsJSON) {
          const parsed = this.safeParseJSON(params.analysisResultsJSON, contextLabel + '.analysisResultsJSON');
          if (parsed) {
            this.analysisResultsSource = contextLabel + '.analysisResultsJSON';
            return parsed;
          }
        }

        return null;
      },

      log: function(message) {
        const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
        const logLine = 'NER-DIALOG:' + timestamp + ' ' + message;
        console.log(logLine);
        try {
          if (typeof Zotero !== 'undefined' && typeof Zotero.debug === 'function') {
            Zotero.debug('Zotero NER Dialog: ' + message);
          }
        } catch (e) {}
        // Also write to file for debugging
        try {
          if (typeof Components !== 'undefined') {
            const file = Components.classes['@mozilla.org/file/directory_service;1']
              .getService(Components.interfaces.nsIProperties)
              .get('TmpD', Components.interfaces.nsIFile);
            file.append('zotero-normalizer.log');
            const fos = Components.classes['@mozilla.org/network/file-output-stream;1']
              .createInstance(Components.interfaces.nsIFileOutputStream);
            fos.init(file, 0x02 | 0x08 | 0x10, 0o644, 0);
            const data = new TextEncoder().encode(timestamp + ' ' + message + '\n');
            fos.write(message, data.length);
            fos.close();
          }
        } catch (e) {}
      },

      alert: function(title, message) {
        try {
          if (typeof Zotero !== 'undefined' && typeof Zotero.alert === 'function') {
            Zotero.alert(null, title, message);
          } else {
            window.alert(title + ': ' + message);
          }
        } catch (e) {
          window.alert(title + ': ' + message);
        }
      },

      setupFilterInput: function() {
        const input = ZoteroNER_HTMLUtils.getElement('variant-filter-input');
        if (!input) {
          return;
        }

        input.value = this.filterText || '';
        input.addEventListener('input', (event) => {
          this.handleFilterInput(event.target.value);
        });
      },

      handleFilterInput: function(rawValue) {
        this.filterText = (rawValue || '').trim();
        this.populateVariantGroupList();
      },

      matchesFilter: function(suggestion) {
        const query = (this.filterText || '').toLowerCase();
        if (!query) {
          return true;
        }

        const terms = [];
        const capture = (value) => {
          if (!value) {
            return;
          }
          if (typeof value === 'string') {
            terms.push(value.toLowerCase());
          }
        };

        capture(suggestion.type);
        capture(suggestion.surname);
        capture(typeof suggestion.primary === 'string' ? suggestion.primary : this.formatNameString(suggestion.primary));
        capture(suggestion.recommendedFullName);
        capture(suggestion.recommendedFirstName);

        (suggestion.variants || []).forEach(variant => {
          capture(variant.name);
          capture(variant.firstName);
          capture(variant.lastName);
        });

        return terms.some(term => term.includes(query));
      },

      updateFilterSummary: function(visibleCount, totalCount) {
        const summaryEl = ZoteroNER_HTMLUtils.getElement('variant-filter-summary');
        if (!summaryEl) {
          return;
        }

        if (!totalCount) {
          summaryEl.textContent = 'No variant groups available';
          return;
        }

        if (!this.filterText) {
          summaryEl.textContent = `Showing all ${totalCount} variant groups`;
          return;
        }

        summaryEl.textContent = `Showing ${visibleCount} of ${totalCount} groups`;
      },
      
      initialize: async function() {
        this.log('Dialog initialize started');
        this.fileLogger.log('=== Dialog initialize ===');

        // Track when analysis is complete (set by updateAnalysisResults)
        this.analysisComplete = false;

        // DEBUG: Set timeout to detect if analysis never starts
        const analysisStartTime = Date.now();
        const self = this;
        this.checkAnalysisInterval = setInterval(() => {
          // Check if analysis completed (flag set by updateAnalysisResults)
          if (self.analysisComplete) {
            clearInterval(self.checkAnalysisInterval);
            self.checkAnalysisInterval = null;
            const suggestionCount = (self.analysisResults && self.analysisResults.suggestions) ? self.analysisResults.suggestions.length : 0;
            self.fileLogger.log('Analysis completed with ' + suggestionCount + ' suggestions after ' + (Date.now() - analysisStartTime) + 'ms');
          } else if (Date.now() - analysisStartTime > 10000) {
            // 10 seconds passed, no valid results
            clearInterval(self.checkAnalysisInterval);
            self.checkAnalysisInterval = null;
            self.fileLogger.log('ERROR: Timeout waiting for analysis results after 10s');
            self.fileLogger.log('  this.analysisResults: ' + (self.analysisResults ? 'SET' : 'NULL'));
            self.fileLogger.log('  this.analysisComplete: ' + self.analysisComplete);
            if (self.analysisResults) {
              self.fileLogger.log('  suggestions: ' + (self.analysisResults.suggestions ? self.analysisResults.suggestions.length : 'NULL'));
            }
            self.showEmptyState('Analysis timed out. The analysis may have failed to run properly.');
          }
        }, 500);

        let params = null;

        try {
          if (typeof window.arguments !== 'undefined' && window.arguments.length > 0) {
            params = window.arguments[0];
            this.fileLogger.log('window.arguments[0] type: ' + (params ? typeof params : 'NULL'));
            this.fileLogger.log('window.arguments[0] loading: ' + (params && params.loading === true ? 'TRUE' : 'FALSE/NULL'));
            this.fileLogger.log('window.arguments[0] has analysisResults: ' + (params && params.analysisResults ? 'TRUE' : 'FALSE'));
            if (params && params.analysisResults) {
              this.fileLogger.log('  params.analysisResults.suggestions: ' + (params.analysisResults.suggestions ? params.analysisResults.suggestions.length : 'NULL'));
            }
          } else {
            this.fileLogger.log('window.arguments is undefined or empty');
          }
        } catch (err) {
          this.log('Unable to read window arguments: ' + err.message);
        }

        if (params) {
          params = this.unwrapDialogParams(params);
        }

        if (!params && window.ZoteroNERDialogParams) {
          params = this.unwrapDialogParams(window.ZoteroNERDialogParams);
        }

        if (!params && window.ZoteroNERDialogParamsJSON) {
          params = { analysisResultsJSON: window.ZoteroNERDialogParamsJSON };
        }

        if (!params && window.opener) {
          try {
            if (window.opener.ZoteroNERDialogParams) {
              params = this.unwrapDialogParams(window.opener.ZoteroNERDialogParams);
            }
          } catch (err) {
            this.log('Unable to read ZoteroNERDialogParams from opener: ' + err.message);
          }
        }

        if (!params && window.opener && window.opener.ZoteroNERDialogParamsJSON) {
          params = { analysisResultsJSON: window.opener.ZoteroNERDialogParamsJSON };
        }

        if (!params && window.opener && window.opener.ZoteroNERAnalysisResultsJSON) {
          params = { analysisResultsJSON: window.opener.ZoteroNERAnalysisResultsJSON };
        }

        if (!params && window.opener && window.opener.ZoteroNERAnalysisResults) {
          const sanitized = this.sanitizeAnalysisResults(window.opener.ZoteroNERAnalysisResults, 'opener.ZoteroNERAnalysisResults');
          if (sanitized) {
            params = { analysisResults: sanitized };
          }
        }

        if (!params && window.ZoteroNERAnalysisResultsJSON) {
          params = { analysisResultsJSON: window.ZoteroNERAnalysisResultsJSON };
        }

        if (!params && window.ZoteroNERAnalysisResults) {
          const sanitizedCurrent = this.sanitizeAnalysisResults(window.ZoteroNERAnalysisResults, 'window.ZoteroNERAnalysisResults');
          if (sanitizedCurrent) {
            params = { analysisResults: sanitizedCurrent };
          }
        }

        // DEBUG: Log params status
        this.fileLogger.log('params is ' + (params ? 'SET' : 'NULL'));
        this.fileLogger.log('window.opener is ' + (window.opener ? 'SET' : 'NULL'));
        if (window.opener) {
          this.fileLogger.log('opener.ZoteroNERDialogParams is ' + (window.opener.ZoteroNERDialogParams ? 'SET' : 'NULL'));
          this.fileLogger.log('opener.ZoteroNERAnalysisResultsJSON is ' + (window.opener.ZoteroNERAnalysisResultsJSON ? 'SET' : 'NULL'));
          this.fileLogger.log('opener.ZoteroNERAnalysisResults is ' + (window.opener.ZoteroNERAnalysisResults ? 'SET' : 'NULL'));
        }
        this.fileLogger.log('window.ZoteroNERDialogParams is ' + (window.ZoteroNERDialogParams ? 'SET' : 'NULL'));
        this.fileLogger.log('window.ZoteroNERAnalysisResultsJSON is ' + (window.ZoteroNERAnalysisResultsJSON ? 'SET' : 'NULL'));
        this.fileLogger.log('window.ZoteroNERAnalysisResults is ' + (window.ZoteroNERAnalysisResults ? 'SET' : 'NULL'));

        let analysisResults = null;

        // DEBUG: Log all potential sources
        this.fileLogger.log('Checking for params/analysisResults...');
        this.fileLogger.log('  window.arguments[0]: ' + (typeof window.arguments !== 'undefined' && window.arguments.length > 0 ? 'EXISTS' : 'NULL/EMPTY'));
        this.fileLogger.log('  window.ZoteroNERDialogParams: ' + (window.ZoteroNERDialogParams ? 'EXISTS' : 'NULL'));
        this.fileLogger.log('  window.ZoteroNERAnalysisResults: ' + (window.ZoteroNERAnalysisResults ? 'EXISTS' : 'NULL'));
        if (window.ZoteroNERAnalysisResults) {
          this.fileLogger.log('    window.ZoteroNERAnalysisResults.suggestions: ' + (window.ZoteroNERAnalysisResults.suggestions ? window.ZoteroNERAnalysisResults.suggestions.length : 'NULL'));
        }
        this.fileLogger.log('  window.opener.ZoteroNERDialogParams: ' + (window.opener && window.opener.ZoteroNERDialogParams ? 'EXISTS' : 'NULL'));
        this.fileLogger.log('  window.opener.ZoteroNERAnalysisResults: ' + (window.opener && window.opener.ZoteroNERAnalysisResults ? 'EXISTS' : 'NULL'));
        if (window.opener && window.opener.ZoteroNERAnalysisResults) {
          this.fileLogger.log('    opener.analysisResults.suggestions: ' + (window.opener.ZoteroNERAnalysisResults.suggestions ? window.opener.ZoteroNERAnalysisResults.suggestions.length : 'NULL'));
        }

        if (params) {
          params = this.unwrapDialogParams(params);
          this.fileLogger.log('  params after unwrap: ' + (params ? 'EXISTS' : 'NULL'));
          if (params) {
            this.fileLogger.log('    params.analysisResults: ' + (params.analysisResults ? 'EXISTS' : 'NULL'));
            this.fileLogger.log('    params.analysisResultsJSON: ' + (params.analysisResultsJSON ? 'EXISTS' : 'NULL'));
            if (params.analysisResults) {
              this.fileLogger.log('    params.analysisResults.suggestions: ' + (params.analysisResults.suggestions ? params.analysisResults.suggestions.length : 'NULL'));
            }
          }
        }

        // Try to resolve analysisResults from params
        if (params) {
          analysisResults = this.resolveAnalysisResults(params, 'dialog params');
          this.fileLogger.log('resolveAnalysisResults from params: ' + (analysisResults ? 'EXISTS' : 'NULL'));
        }

        // Try other sources if needed
        if (!analysisResults && window.opener && window.opener.ZoteroNERAnalysisResultsJSON) {
          this.fileLogger.log('Trying opener.ZoteroNERAnalysisResultsJSON...');
          analysisResults = this.safeParseJSON(window.opener.ZoteroNERAnalysisResultsJSON, 'opener.ZoteroNERAnalysisResultsJSON');
        }

        if (!analysisResults && window.opener && window.opener.ZoteroNERAnalysisResults) {
          this.fileLogger.log('Trying opener.ZoteroNERAnalysisResults...');
          analysisResults = this.sanitizeAnalysisResults(window.opener.ZoteroNERAnalysisResults, 'opener.ZoteroNERAnalysisResults direct');
        }

        if (!analysisResults && window.ZoteroNERAnalysisResultsJSON) {
          this.fileLogger.log('Trying window.ZoteroNERAnalysisResultsJSON...');
          analysisResults = this.safeParseJSON(window.ZoteroNERAnalysisResultsJSON, 'window.ZoteroNERAnalysisResultsJSON');
        }

        if (!analysisResults && window.ZoteroNERAnalysisResults) {
          this.fileLogger.log('Trying window.ZoteroNERAnalysisResults...');
          analysisResults = this.sanitizeAnalysisResults(window.ZoteroNERAnalysisResults, 'window.ZoteroNERAnalysisResults direct');
        }

        // If still no results but params looks like results itself
        if (!analysisResults && params && typeof params === 'object' && !params.loading) {
          this.fileLogger.log('Trying params as direct results...');
          const direct = this.sanitizeAnalysisResults(params, 'dialog params direct');
          if (direct) {
            analysisResults = direct;
            this.analysisResultsSource = 'dialog params direct';
          }
        }

        if (params && params.items) {
          this.items = params.items;
        }

        // Log what we found
        this.fileLogger.log('Final analysisResults: ' + (analysisResults ? 'EXISTS' : 'NULL'));
        if (analysisResults) {
          this.fileLogger.log('  suggestions count: ' + (analysisResults.suggestions ? analysisResults.suggestions.length : 'NULL'));
          this.fileLogger.log('  totalUniqueSurnames: ' + (analysisResults.totalUniqueSurnames || 'NULL'));
          if (analysisResults.suggestions && analysisResults.suggestions.length > 0) {
            const sample = analysisResults.suggestions.slice(0, 3).map(s => s.primary || s.surname || '?').join(', ');
            this.fileLogger.log('  Sample suggestions: ' + sample);
          }
        }

        if (!analysisResults) {
          this.log('No analysis results found');
          this.fileLogger.log('ERROR: No analysis results found - showing empty state');
          this.showEmptyState('No analysis results were provided to the dialog.');
          this.updateProgress();
          return;
        }

        // Check if this is a loading state OR if suggestions are NULL (stale cached data)
        // We need fresh analysis if:
        // 1. loading === true (explicitly waiting for analysis)
        // 2. suggestions is NULL (stale cached data with no results)
        if (analysisResults.loading === true || analysisResults.suggestions === null) {
          const reason = analysisResults.loading === true ? 'loading=true' : 'suggestions=NULL';
          this.log('Dialog opened in loading state (' + reason + ')');
          this.fileLogger.log('Loading state (' + reason + ') - will wait for updateAnalysisResults');
          // Update loading message to show we're waiting
          ZoteroNER_HTMLUtils.updateProgressLabel('Waiting for analysis to complete...');
          this.showLoadingState();
          return;
        }

        this.analysisResults = analysisResults;
        this.resetSelections();
        this.clearVariantDetails();

        this.log('Analysis results source: ' + (this.analysisResultsSource || 'unknown'));
        this.log('Analysis results loaded: ' + (this.analysisResults.suggestions ? this.analysisResults.suggestions.length : 0) + ' suggestions; unique surnames: ' + (this.analysisResults.totalUniqueSurnames ?? 'unknown'));

        this.updateSummaryHeader();
        this.populateVariantGroupList();
        this.refreshApplyButtonState();
        this.updateProgress();
      },

      showEmptyState: function(message) {
        if (this.analysisResults) {
          this.updateSummaryHeader();
        } else {
          ZoteroNER_HTMLUtils.setHidden('summary-group', true);
        }

        const totalSuggestions = (this.analysisResults && Array.isArray(this.analysisResults.suggestions))
          ? this.analysisResults.suggestions.length
          : 0;
        this.updateFilterSummary(0, totalSuggestions);

        ZoteroNER_HTMLUtils.clearContainer('variant-groups-container');
        this.clearVariantDetails();

        this.setApplyEnabled(false);

        const emptyMsg = ZoteroNER_HTMLUtils.getElement('empty-message');
        if (emptyMsg) {
          const frequencies = this.analysisResults && this.analysisResults.surnameFrequencies
            ? Object.entries(this.analysisResults.surnameFrequencies)
            : [];
          const totalUnique = this.analysisResults && typeof this.analysisResults.totalUniqueSurnames === 'number'
            ? this.analysisResults.totalUniqueSurnames
            : 0;
          const topFrequencies = frequencies
            .sort((a, b) => b[1] - a[1])
            .slice(0, 10);

          let html = '<div class="empty-message-content">';
          html += `<p>${message || 'No variant groups found. All creator names appear to be consistent.'}</p>`;

          if (totalUnique) {
            html += `<p><strong>Total unique surnames scanned:</strong> ${totalUnique}</p>`;
          }

          if (topFrequencies.length > 0) {
            html += '<p><strong>Top surnames by frequency:</strong></p>';
            html += '<ul class="surname-frequency-list">';
            topFrequencies.forEach(([name, count]) => {
              html += `<li><span class="surname">${this.formatSurnameKey(name)}</span> <span class="frequency">(${count})</span></li>`;
            });
            html += '</ul>';
          }

          html += '</div>';
          emptyMsg.innerHTML = html;
          emptyMsg.style.display = 'block';
        }
      },

      updateSummaryHeader: function() {
        if (!this.analysisResults) return;

        ZoteroNER_HTMLUtils.setHidden('summary-group', false);
        ZoteroNER_HTMLUtils.setText('summary-total-creators', this.analysisResults.totalUniqueSurnames || '0');
        ZoteroNER_HTMLUtils.setText('summary-variant-groups', this.analysisResults.totalVariantGroups || '0');
        ZoteroNER_HTMLUtils.setText('summary-pending-normalizations', this.analysisResults.suggestions ? this.analysisResults.suggestions.length : '0');
      },

      resetSelections: function() {
        this.userSelections = new Map();
        if (!this.analysisResults || !Array.isArray(this.analysisResults.suggestions)) {
          return;
        }

        this.analysisResults.suggestions.forEach((suggestion, index) => {
          this.ensureUserSelection(index, suggestion);
        });
      },

      ensureUserSelection: function(index, suggestion) {
        if (!this.userSelections) {
          this.userSelections = new Map();
        }

        if (!this.userSelections.has(index)) {
          // Default to NOT applying - user must explicitly select a normalization
          // This prevents accidental bulk changes to the library
          const defaultValue = this.getDefaultNormalizationValue(suggestion);
          this.userSelections.set(index, {
            mode: 'primary',
            value: defaultValue,
            variantIndex: null,
            customValue: defaultValue,
            apply: false  // Changed from true to require explicit opt-in
          });
        }

        return this.userSelections.get(index);
      },

      updateSelection: function(index, suggestion, updates) {
        const current = this.ensureUserSelection(index, suggestion);
        const next = Object.assign({}, current, updates || {});

        if (updates && Object.prototype.hasOwnProperty.call(updates, 'mode')) {
          if (updates.mode === 'keep') {
            next.apply = false;
            next.variantIndex = null;
          } else {
            next.apply = true;
            if (updates.mode !== 'variant') {
              next.variantIndex = null;
            }
          }
        }

        if (updates && Object.prototype.hasOwnProperty.call(updates, 'variantIndex') && next.mode !== 'variant') {
          next.variantIndex = updates.variantIndex;
        }

        if (updates && Object.prototype.hasOwnProperty.call(updates, 'customValue')) {
          next.customValue = updates.customValue;
          if (next.mode === 'custom' && !Object.prototype.hasOwnProperty.call(updates, 'value')) {
            next.value = updates.customValue;
          }
        }

        if (updates && Object.prototype.hasOwnProperty.call(updates, 'value')) {
          next.value = updates.value;
        }

        this.userSelections.set(index, next);
        this.refreshApplyButtonState();
        return next;
      },

      refreshApplyButtonState: function() {
        this.setApplyEnabled(this.hasSelectedNormalizations());
      },

      hasSelectedNormalizations: function() {
        if (!this.analysisResults || !Array.isArray(this.analysisResults.suggestions) || this.analysisResults.suggestions.length === 0) {
          return false;
        }

        if (!this.userSelections || this.userSelections.size === 0) {
          return true;
        }

        for (let i = 0; i < this.analysisResults.suggestions.length; i++) {
          const selection = this.userSelections.get(i);
          if (!selection || selection.apply !== false) {
            return true;
          }
        }

        return false;
      },

      // Per-card apply: apply a single suggestion and remove its card from the UI
      applyCard: async function(index, suggestion) {
        this.log('applyCard called: index=' + index + ', suggestion.type=' + (suggestion ? suggestion.type : 'null'));
        const selection = this.ensureUserSelection(index, suggestion);
        if (!selection) {
          this.log('applyCard: no selection found, returning false');
          return false;
        }

        this.log('applyCard: selection.mode=' + selection.mode + ', apply=' + selection.apply + ', value=' + selection.value + ', customValue=' + selection.customValue);

        // Check if there's a valid selection to apply
        const normalizedValue = (selection.value || selection.customValue || '').trim();
        this.log('applyCard: normalizedValue="' + normalizedValue + '"');

        if (!normalizedValue || selection.apply === false) {
          this.log('applyCard: early return - no value or apply=false');
          return false;
        }

        // Mark as applied
        selection.applied = true;
        this.log('applyCard: marked as applied, looking for card');

        // Find and remove the card
        const card = document.querySelector(`.variant-group[data-suggestion-index="${index}"]`);
        this.log('applyCard: card found=' + (card ? 'yes' : 'no'));

        if (card) {
          this.log('applyCard: removing card with animation');
          card.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
          card.style.opacity = '0';
          card.style.transform = 'translateX(-20px)';
          setTimeout(() => {
            this.log('applyCard: timeout fired, removing card DOM element');
            card.remove();
            this.checkAllCardsApplied();
          }, 300);
        }

        return true;
      },

      // Mark card as "not variants" (distinct authors) and remove from UI
      markNotVariants: function(index, suggestion) {
        const selection = this.ensureUserSelection(index, suggestion);
        if (!selection) {
          return false;
        }

        // Mark as declined (not variants)
        selection.apply = false;
        selection.notVariants = true;

        // Store user preference to never propose this normalization again
        this.storeNotVariantsPreference(suggestion);

        // Find and remove the card with animation
        const card = document.querySelector(`.variant-group[data-suggestion-index="${index}"]`);
        if (card) {
          card.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
          card.style.opacity = '0';
          card.style.transform = 'translateX(-20px)';
          setTimeout(() => {
            card.remove();
            this.checkAllCardsApplied();
          }, 300);
        }

        return true;
      },

      // Store user preference for "not variants" (distinct authors)
      storeNotVariantsPreference: function(suggestion) {
        // Create a unique key for this suggestion based on its characteristics
        const key = this.getNotVariantsKey(suggestion);

        // Get existing preferences
        const existingPrefs = this.getNotVariantsPreferences();
        if (!existingPrefs.includes(key)) {
          existingPrefs.push(key);
          this.saveNotVariantsPreferences(existingPrefs);
        }

        this.log('Stored "not variants" preference for: ' + key);
      },

      // Generate a unique key for identifying this suggestion
      // Sanitize values to prevent special characters from breaking the key format
      getNotVariantsKey: function(suggestion) {
        const sanitize = function(value) {
          return (value || '').replace(/[:\\/\n\r\t]/g, '_').substring(0, 100);
        };
        if (suggestion.type === 'given-name') {
          return `given-name:${sanitize(suggestion.surname)}:${sanitize(suggestion.primary)}`;
        }
        return `surname:${sanitize(suggestion.primary)}`;
      },

      // Get stored "not variants" preferences
      getNotVariantsPreferences: function() {
        try {
          const prefs = window.localStorage.getItem('zotero-ner-not-variants');
          return prefs ? JSON.parse(prefs) : [];
        } catch (e) {
          return [];
        }
      },

      // Save "not variants" preferences
      saveNotVariantsPreferences: function(prefs) {
        try {
          const json = JSON.stringify(prefs);
          window.localStorage.setItem('zotero-ner-not-variants', json);
        } catch (e) {
          this.log('Failed to save not-variants preferences: ' + e.message);
          // localStorage may fail in private browsing or when quota exceeded
          // The preference won't persist, but the UI interaction still works
        }
      },

      // Check if all cards have been applied/declined
      checkAllCardsApplied: function() {
        const remainingCards = document.querySelectorAll('.variant-group');
        if (remainingCards.length === 0) {
          // All cards have been handled - update empty message
          const emptyMsg = ZoteroNER_HTMLUtils.getElement('empty-message');
          if (emptyMsg) {
            const content = document.createElement('div');
            content.className = 'empty-message-content';
            const p = document.createElement('p');
            p.textContent = 'All variant groups have been processed. You can close this dialog.';
            content.appendChild(p);
            emptyMsg.innerHTML = '';
            emptyMsg.appendChild(content);
            emptyMsg.style.display = 'block';
          }
          // Disable the main apply buttons since there are no more cards
          this.setApplyEnabled(false);
        }
      },

      // Build the per-card action buttons (Apply and Not Variants)
      buildCardActions: function(index, suggestion) {
        this.log('buildCardActions: creating buttons for index=' + index);
        const container = ZoteroNER_HTMLUtils.createElement('div', { class: 'card-actions' });

        // Apply button
        const applyBtn = ZoteroNER_HTMLUtils.createElement('button', {
          type: 'button',
          class: 'apply-btn',
          'data-suggestion-index': String(index)
        });
        applyBtn.textContent = 'Apply';

        // Not Variants button (Distinct Authors)
        const notVariantsBtn = ZoteroNER_HTMLUtils.createElement('button', {
          type: 'button',
          class: 'not-variants-btn',
          'data-suggestion-index': String(index),
          title: 'Mark these as distinct authors - this will not be proposed again'
        });
        notVariantsBtn.textContent = 'Not Variants';

        // Add click handlers
        applyBtn.addEventListener('click', async () => {
          this.log('Apply button clicked for index=' + index);
          await this.applyCard(index, suggestion);
        });

        notVariantsBtn.addEventListener('click', () => {
          this.markNotVariants(index, suggestion);
        });

        container.appendChild(applyBtn);
        container.appendChild(notVariantsBtn);

        return container;
      },

      getDefaultNormalizationValue: function(suggestion) {
        if (!suggestion) {
          return '';
        }

        if (suggestion.type === 'given-name') {
          if (suggestion.recommendedFullName) {
            return suggestion.recommendedFullName;
          }
        }

        if (typeof suggestion.primary === 'string') {
          // For surname suggestions, return a title-cased display value
          return suggestion.type === 'surname'
            ? this.formatSurnameKey(suggestion.primary.trim())
            : suggestion.primary.trim();
        }

        return this.formatNameString(suggestion.primary);
      },

      titleCase: function(value) {
        if (!value || typeof value !== 'string') {
          return '';
        }

        const cleaned = value.normalize('NFC').replace(/[\u200B-\u200D\uFEFF]/g, '');
        return cleaned
          .split(/\s+/)
          .filter(Boolean)
          .map(part => part.toLowerCase().replace(/(^|['`-])(\p{L})/gu, (match, prefix, letter) => prefix + letter.toUpperCase()))
          .join(' ');
      },

      getGroupTitle: function(index, suggestion) {
        const groupNumber = index + 1;
        if (suggestion.type === 'given-name') {
          const surname = this.titleCase(suggestion.surname || suggestion.primary || '');
          const safeSurname = this.escapeHTML(surname);
          return surname
            ? `Given name variants <span class="surname-variant">${safeSurname}</span>`
            : `Given name variants Group ${groupNumber}`;
        }

        const surname = this.titleCase(suggestion.primary || '');
        const safeSurname = this.escapeHTML(surname);
        return surname
          ? `Surname variants <span class="surname-variant">${safeSurname}</span>`
          : `Variant Group ${groupNumber}`;
      },

      buildRecommendedHTML: function(suggestion, recommendedValue) {
        const rawValue = recommendedValue || '';
        const safeValue = this.escapeHTML(rawValue);
        if (suggestion.type === 'given-name') {
          return 'Recommended full name: <strong>' + safeValue + '</strong>';
        }
        // For surname recommendations, display a title-cased, escaped version
        const display = this.formatSurnameKey(rawValue);
        return 'Recommended normalization: <strong>' + display + '</strong>';
      },

      getVariantSummaryText: function(suggestion) {
        const variantCount = Array.isArray(suggestion.variants) ? suggestion.variants.length : 0;

        if (suggestion.type === 'given-name') {
          const total = suggestion.totalFrequency || 0;
          return `${variantCount} given-name variants Â· ${total} occurrences`;
        }

        const totalOccurrences = (suggestion.variants || []).reduce((sum, variant) => sum + (variant.frequency || 0), 0);
        return `${variantCount} surname spellings Â· ${totalOccurrences} occurrences`;
      },

      getVariantDisplayLabel: function(suggestion, variant) {
        if (!variant) {
          return '';
        }

        const frequency = typeof variant.frequency === 'number' ? ` (${variant.frequency})` : '';

        if (suggestion.type === 'given-name') {
          const name = variant.firstName || variant.name || '';
          return `${this.titleCase(name)}${frequency}`;
        }

        // Preserve original casing of the variant name - don't title-case it
        const surnameDisplay = typeof variant.name === 'string'
          ? variant.name
          : this.formatNameString(variant.name);
        return `${surnameDisplay}${frequency}`;
      },

      getVariantSelectionLabel: function(suggestion, variant) {
        if (!variant) {
          return '';
        }

        const occurrences = typeof variant.frequency === 'number' ? `${variant.frequency} occurrences` : 'variant';

        if (suggestion.type === 'given-name') {
          return `Normalize to ${this.titleCase(variant.firstName || variant.name || '')} (${occurrences})`;
        }

        // Preserve original casing for surname variants
        const variantSurname = typeof variant.name === 'string'
          ? variant.name
          : this.formatNameString(variant.name);
        return `Normalize to ${variantSurname} (${occurrences})`;
      },

      buildVariantListElement: function(index, suggestion) {
        const wrapper = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-list' });
        const recommendedValue = (this.getDefaultNormalizationValue(suggestion) || '').trim().toLowerCase();

        (suggestion.variants || []).forEach((variant, variantIndex) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'variant-pill';
          button.dataset.suggestionIndex = String(index);
          button.dataset.variantIndex = String(variantIndex);
          button.textContent = this.getVariantDisplayLabel(suggestion, variant);
          const variantValue = (typeof variant.name === 'string' && variant.name)
            ? variant.name.trim().toLowerCase()
            : (variant.firstName ? `${variant.firstName} ${variant.lastName || suggestion.primary || ''}`.trim().toLowerCase() : '');
          if (recommendedValue && variantValue && variantValue === recommendedValue) {
            button.classList.add('recommended');
          }
          button.addEventListener('click', () => {
            this.showVariantDetails(index, variantIndex, suggestion, { suppressHighlight: false });
          });
          wrapper.appendChild(button);
        });

        return wrapper;
      },

      findRecommendedVariantIndex: function(suggestion) {
        if (!suggestion || !Array.isArray(suggestion.variants) || suggestion.variants.length === 0) {
          return null;
        }

        const recommendedValue = (this.getDefaultNormalizationValue(suggestion) || '').trim().toLowerCase();
        if (!recommendedValue) {
          return null;
        }

        for (let i = 0; i < suggestion.variants.length; i++) {
          const variant = suggestion.variants[i];
          const variantValue = (typeof variant.name === 'string' && variant.name)
            ? variant.name.trim().toLowerCase()
            : (variant.firstName ? `${variant.firstName} ${variant.lastName || suggestion.primary || ''}`.trim().toLowerCase() : '');

          if (variantValue && variantValue === recommendedValue) {
            return i;
          }
        }

        return null;
      },

      highlightVariantPills: function(suggestionIndex, variantIndex) {
        const pills = document.querySelectorAll('.variant-pill[data-suggestion-index]');
        pills.forEach(pill => {
          const matches = pill.dataset.suggestionIndex === String(suggestionIndex) && pill.dataset.variantIndex === String(variantIndex);
          pill.classList.toggle('active', matches);
        });
      },

      getVariantDetailTitle: function(suggestion, variant) {
        const label = this.getVariantDisplayLabel(suggestion, variant).replace(/\s+\([^)]*\)$/, '');
        const safeLabel = this.escapeHTML(label);
        if (suggestion.type === 'given-name') {
          return `Occurrences for ${safeLabel}`;
        }
        return `Occurrences for <span class="surname-variant">${safeLabel}</span>`;
      },

      showVariantDetails: function(suggestionIndex, variantIndex, suggestion, options = {}) {
        const variant = suggestion.variants[variantIndex];
        const items = Array.isArray(variant?.items) ? variant.items : [];

        // Debug info for troubleshooting
        const authorInfo = suggestion.authorInfo || {};
        const lookupKey = `${authorInfo.firstName || ''}|${variant.name || ''}`;
        // Debug: show first 3 items if any
        let debugInfo = `lookupKey=[${lookupKey}], items.length=${items.length}`;
        if (items.length > 0) {
          const sampleKeys = items.slice(0, 3).map(i => i.key).join(', ');
          debugInfo += `, sampleKeys=[${sampleKeys}]`;
        }
        console.error('DEBUG: ' + debugInfo);
        // Remaining dump() calls removed - they don't work in Zotero context

        if (!suggestion || !Array.isArray(suggestion.variants)) {
          this.clearVariantDetails();
          return;
        }

        if (!variant) {
          this.clearVariantDetails();
          return;
        }

        this.variantDetailState = { suggestionIndex, variantIndex };

        if (!options.suppressHighlight) {
          this.highlightVariantPills(suggestionIndex, variantIndex);
        }

        const panel = ZoteroNER_HTMLUtils.getElement('variant-detail-panel');
        if (!panel) {
          return;
        }

        // Remove placeholder classes so the detail view replaces the empty message
        panel.classList.remove('empty');
        panel.classList.remove('hidden');
        panel.style.display = 'block';

        const titleEl = ZoteroNER_HTMLUtils.getElement('variant-detail-title');
        if (titleEl) {
          titleEl.innerHTML = this.getVariantDetailTitle(suggestion, variant);
        }

        const contextEl = ZoteroNER_HTMLUtils.getElement('variant-detail-context');
        if (contextEl) {
          const pieces = [];
          const freq = typeof variant.frequency === 'number' ? variant.frequency : 0;
          pieces.push(`Occurrences: ${freq}`);
          if (suggestion.type === 'given-name') {
            pieces.push(`Surname: ${this.titleCase(suggestion.surname || suggestion.primary || '')}`);
          }
          contextEl.textContent = pieces.join(' Â· ');
        }

        const listEl = ZoteroNER_HTMLUtils.getElement('variant-detail-items');
        if (listEl) {
          listEl.innerHTML = '';
          const items = Array.isArray(variant.items) ? variant.items : [];
          const authorInfo = suggestion.authorInfo || {};
          const lookupKey = `${authorInfo.firstName || ''}|${variant.name || ''}`;

          if (items.length === 0) {
            const emptyLi = document.createElement('li');
            emptyLi.innerHTML = `<span style="color:red;">No items found. lookupKey=[${lookupKey}]</span>`;
            listEl.appendChild(emptyLi);
          } else {
            items.forEach(item => {
              const li = document.createElement('li');
              const html = this.formatItemSummaryHTML(item);
              li.innerHTML = html;
              listEl.appendChild(li);
            });

            if ((variant.frequency || 0) > items.length) {
              const moreLi = document.createElement('li');
              moreLi.className = 'variant-meta';
              moreLi.textContent = `â€¦and ${(variant.frequency || 0) - items.length} more entries`;
              listEl.appendChild(moreLi);
            }
          }
        }
      },

      clearVariantDetails: function() {
        this.variantDetailState = null;
        const panel = ZoteroNER_HTMLUtils.getElement('variant-detail-panel');
        if (panel) {
          panel.style.display = 'none';
          panel.classList.add('empty');
          panel.classList.add('hidden');
        }

        const contextEl = ZoteroNER_HTMLUtils.getElement('variant-detail-context');
        if (contextEl) {
          contextEl.textContent = '';
        }

        const listEl = ZoteroNER_HTMLUtils.getElement('variant-detail-items');
        if (listEl) {
          listEl.innerHTML = '';
        }

        const pills = document.querySelectorAll('.variant-pill');
        pills.forEach(pill => pill.classList.remove('active'));
      },

      formatItemSummary: function(item) {
        if (!item) {
          return 'Untitled item';
        }

        const title = item.title || 'Untitled';
        const year = item.year || item.date || '';
        const author = item.author || '';

        // Build display: Author - Title (Year) or Title (Year) if no author
        const yearStr = year ? ` (${year})` : '';
        const authorStr = author ? `${author} â€” ` : '';

        // Truncate title if too long
        const maxTitleLength = 100;
        const trimmedTitle = title.length > maxTitleLength ? title.slice(0, maxTitleLength) + 'â€¦' : title;

        return authorStr + trimmedTitle + yearStr;
      },

      formatItemSummaryHTML: function(item) {
        if (!item) {
          return '<span class="item-title">Untitled item</span>';
        }

        const title = item.title || 'Untitled';
        const year = item.year || item.date || '';
        const author = item.author || '';
        const itemKey = item.key || '';

        // Truncate title if too long
        const maxTitleLength = 100;
        const trimmedTitle = title.length > maxTitleLength ? title.slice(0, maxTitleLength) + 'â€¦' : title;

        // Escape HTML for safe rendering
        const safeTitle = this.escapeHTML(trimmedTitle);
        const safeAuthor = this.escapeHTML(author);
        const safeYear = this.escapeHTML(year);

        let html = '<div class="item-details">';

        if (safeAuthor) {
          html += `<span class="item-author">${safeAuthor}</span>`;
        }

        // Make title clickable with zotero://select/ URL
        if (itemKey) {
          html += `<a href="#" class="item-link" data-item-key="${this.escapeHTML(itemKey)}">${safeTitle}</a>`;
        } else {
          html += `<span class="item-title">${safeTitle}</span>`;
        }

        if (safeYear) {
          html += `<span class="item-year">(${safeYear})</span>`;
        }

        html += '</div>';
        return html;
      },

      buildSelectionControls: function(index, suggestion) {
        const choiceGroup = ZoteroNER_HTMLUtils.createElement('div', { class: 'radio-group', id: 'ner-variant-group-choice-' + index });
        const selection = this.ensureUserSelection(index, suggestion);
        const recommendedValue = this.getDefaultNormalizationValue(suggestion);
        const recommendedLabelText = suggestion.type === 'given-name'
          ? (recommendedValue ? `Use recommended full name: ${recommendedValue}` : 'Use recommended full name')
          : (recommendedValue ? `Use recommended normalization: ${recommendedValue}` : 'Use recommended normalization');

        const primaryRow = this.createSelectionRadioRow(index, suggestion, {
          mode: 'primary',
          label: recommendedLabelText,
          checked: selection.mode === 'primary',
          selectionUpdate: () => ({ mode: 'primary', value: recommendedValue })
        });
        choiceGroup.appendChild(primaryRow);

        const keepRow = this.createSelectionRadioRow(index, suggestion, {
          mode: 'keep',
          label: 'Keep existing forms as-is',
          checked: selection.mode === 'keep',
          selectionUpdate: () => ({ mode: 'keep', apply: false })
        });
        choiceGroup.appendChild(keepRow);

        (suggestion.variants || []).forEach((variant, variantIndex) => {
          const label = this.getVariantSelectionLabel(suggestion, variant);
          const variantRow = this.createSelectionRadioRow(index, suggestion, {
            mode: 'variant',
            label,
            checked: selection.mode === 'variant' && selection.variantIndex === variantIndex,
            onSelect: () => {
              this.showVariantDetails(index, variantIndex, suggestion);
            },
            selectionUpdate: () => {
              const variantValue = (typeof variant.name === 'string' && variant.name)
                ? variant.name.trim()
                : (variant.firstName ? `${variant.firstName} ${variant.lastName || suggestion.primary || ''}`.trim() : '');
              return {
                mode: 'variant',
                variantIndex,
                value: variantValue
              };
            }
          });
          choiceGroup.appendChild(variantRow);
        });

        const customRow = this.createCustomSelectionRow(index, suggestion, selection, recommendedValue);
        choiceGroup.appendChild(customRow);

        return choiceGroup;
      },

      createSelectionRadioRow: function(index, suggestion, option) {
        const row = ZoteroNER_HTMLUtils.createElement('div');
        const radioId = `choice-${index}-${option.mode}-${Math.random().toString(16).slice(2, 7)}`;
        const radio = ZoteroNER_HTMLUtils.createElement('input', {
          type: 'radio',
          id: radioId,
          name: `choice-${index}`,
          value: option.mode
        });
        if (option.checked) {
          radio.checked = true;
        }

        radio.addEventListener('change', () => {
          if (typeof option.onSelect === 'function') {
            option.onSelect();
          }
          const update = typeof option.selectionUpdate === 'function'
            ? option.selectionUpdate()
            : { mode: option.mode };
          this.updateSelection(index, suggestion, update);
        });

        const label = ZoteroNER_HTMLUtils.createElement('label', { for: radioId });
        label.textContent = option.label;

        row.appendChild(radio);
        row.appendChild(label);
        return row;
      },

      createCustomSelectionRow: function(index, suggestion, selection, defaultValue) {
        const container = ZoteroNER_HTMLUtils.createElement('div', { class: 'custom-normalization' });
        const radioId = `choice-${index}-custom`;
        const radio = ZoteroNER_HTMLUtils.createElement('input', {
          type: 'radio',
          id: radioId,
          name: `choice-${index}`,
          value: 'custom'
        });
        radio.checked = selection.mode === 'custom';

        const label = ZoteroNER_HTMLUtils.createElement('label', { for: radioId });
        label.textContent = 'Use a custom normalization:';

        const input = document.createElement('input');
        input.type = 'text';
        input.value = selection.customValue || defaultValue || '';
        input.disabled = selection.mode !== 'custom';
        input.placeholder = defaultValue || 'Enter normalized name';

        radio.addEventListener('change', () => {
          input.disabled = !radio.checked;
          if (radio.checked) {
            this.updateSelection(index, suggestion, {
              mode: 'custom',
              value: input.value,
              customValue: input.value,
              variantIndex: null
            });
          }
        });

        input.addEventListener('input', (event) => {
          const value = event.target.value;
          const current = this.ensureUserSelection(index, suggestion);
          const updates = { customValue: value };
          if (current.mode === 'custom') {
            updates.value = value;
          }
          this.updateSelection(index, suggestion, updates);
        });

        input.addEventListener('focus', () => {
          if (!radio.checked) {
            radio.checked = true;
            radio.dispatchEvent(new Event('change'));
          }
        });

        container.appendChild(radio);
        container.appendChild(label);
        container.appendChild(input);

        return container;
      },

      buildRelatedGivenNamesSection: function(suggestion) {
        const wrapper = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-meta' });
        const variants = suggestion.relatedGivenNameVariants || [];
        if (!variants.length) {
          return wrapper;
        }

        const intro = document.createElement('div');
        intro.textContent = 'Associated given name variants:';
        wrapper.appendChild(intro);

        const list = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-list' });
        variants.forEach(variant => {
          const pill = document.createElement('span');
          pill.className = 'variant-pill';
          pill.textContent = `${this.titleCase(variant.firstName || '')} (${variant.frequency || 0})`;
          list.appendChild(pill);
        });

        wrapper.appendChild(list);
        return wrapper;
      },

      populateVariantGroupList: function() {
        const container = ZoteroNER_HTMLUtils.getElement('variant-groups-container');
        if (!container) {
          return false;
        }

        container.innerHTML = '';

        const suggestions = (this.analysisResults && Array.isArray(this.analysisResults.suggestions))
          ? this.analysisResults.suggestions
          : [];
        const totalSuggestions = suggestions.length;

        if (totalSuggestions === 0) {
          this.showEmptyState('No variant groups were detected for the scanned surnames.');
          return false;
        }

        const emptyMsg = ZoteroNER_HTMLUtils.getElement('empty-message');
        if (emptyMsg) {
          emptyMsg.style.display = 'none';
        }

        const renderedIndexes = [];
        let visibleCount = 0;

        suggestions.forEach((suggestion, index) => {
          if (!suggestion) {
            return;
          }
          if (!this.matchesFilter(suggestion)) {
            return;
          }

          this.log('populateVariantGroupList: rendering card for index=' + index + ', type=' + suggestion.type);
          visibleCount++;
          renderedIndexes.push(index);
          this.ensureUserSelection(index, suggestion);
          const groupElement = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-group', 'data-suggestion-index': String(index) });

          const header = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-group-header' });
          const title = ZoteroNER_HTMLUtils.createElement('h3');
          title.innerHTML = this.getGroupTitle(index, suggestion);
          header.appendChild(title);

          const summary = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-group-summary' });
          summary.textContent = this.getVariantSummaryText(suggestion);
          header.appendChild(summary);

          const recommendedValue = this.getDefaultNormalizationValue(suggestion);
          if (recommendedValue) {
            const recommended = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-meta' });
            recommended.innerHTML = this.buildRecommendedHTML(suggestion, recommendedValue);
            header.appendChild(recommended);
          }

          groupElement.appendChild(header);

          const variantsContainer = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-group-variants' });
          const variantList = this.buildVariantListElement(index, suggestion);

          if (variantList && variantList.childElementCount > 0) {
            variantsContainer.appendChild(variantList);
          } else {
            const emptyVariants = document.createElement('div');
            emptyVariants.className = 'variant-meta';
            emptyVariants.textContent = 'No variants detected.';
            variantsContainer.appendChild(emptyVariants);
          }

          const controls = this.buildSelectionControls(index, suggestion);
          variantsContainer.appendChild(controls);

          if (suggestion.type === 'given-name') {
            const relatedSection = this.buildRelatedGivenNamesSection(suggestion);
            if (relatedSection && relatedSection.childNodes.length) {
              variantsContainer.appendChild(relatedSection);
            }
          }

          // Add per-card action buttons
          const cardActions = this.buildCardActions(index, suggestion);
          variantsContainer.appendChild(cardActions);

          groupElement.appendChild(variantsContainer);
          container.appendChild(groupElement);
        });

        this.updateFilterSummary(visibleCount, totalSuggestions);

        if (visibleCount === 0) {
          const noMatches = document.createElement('div');
          noMatches.className = 'empty-message';
          noMatches.textContent = this.filterText
            ? 'No variant groups match your filter. Adjust your search to see results.'
            : 'No variant groups were detected for the scanned surnames.';
          container.appendChild(noMatches);
          this.clearVariantDetails();
          this.refreshApplyButtonState();
          return false;
        }

        const { variantDetailState } = this;
        let detailSuggestionIndex = null;
        let detailVariantIndex = null;

        if (variantDetailState && renderedIndexes.includes(variantDetailState.suggestionIndex)) {
          detailSuggestionIndex = variantDetailState.suggestionIndex;
          detailVariantIndex = typeof variantDetailState.variantIndex === 'number'
            ? variantDetailState.variantIndex
            : null;
        } else {
          this.variantDetailState = null;
          detailSuggestionIndex = renderedIndexes[0];
        }

        const detailSuggestion = suggestions[detailSuggestionIndex];
        if (detailSuggestion && Array.isArray(detailSuggestion.variants) && detailSuggestion.variants.length > 0) {
          let variantIndexToShow = null;
          if (detailVariantIndex !== null && detailSuggestion.variants[detailVariantIndex]) {
            variantIndexToShow = detailVariantIndex;
          } else {
            const defaultVariantIndex = this.findRecommendedVariantIndex(detailSuggestion);
            variantIndexToShow = defaultVariantIndex !== null ? defaultVariantIndex : 0;
          }
          this.showVariantDetails(detailSuggestionIndex, variantIndexToShow, detailSuggestion);
        } else {
          this.clearVariantDetails();
        }

        this.refreshApplyButtonState();
        return true;
      },

      formatNameString: function(name) {
        if (typeof name === 'string') return name.trim();
        if (name && typeof name === 'object') {
          return `${name.firstName || ''} ${name.lastName || ''}`.trim();
        }
        return '';
      },

      escapeHTML: function(value) {
        if (typeof value !== 'string') {
          return '';
        }
        const map = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;'
        };
        return value.replace(/[&<>"']/g, (char) => map[char]);
      },

      formatSurnameKey: function(value) {
        if (!value || typeof value !== 'string') {
          return '';
        }
        const titleCased = this.titleCase(value);
        return this.escapeHTML(titleCased);
      },

      setApplyEnabled: function(enabled) {
        const applyButton = ZoteroNER_HTMLUtils.getElement('apply-button');
        const applyAllButton = ZoteroNER_HTMLUtils.getElement('apply-all-button');
        if (applyButton) applyButton.disabled = !enabled || this.isProcessing;
        if (applyAllButton) applyAllButton.disabled = !enabled || this.isProcessing;
      },

      setDialogBusy: function(isBusy) {
        this.isProcessing = isBusy;
        ZoteroNER_HTMLUtils.setHidden('progress-container', !isBusy);

        const applyButton = ZoteroNER_HTMLUtils.getElement('apply-button');
        const applyAllButton = ZoteroNER_HTMLUtils.getElement('apply-all-button');
        if (applyButton) applyButton.disabled = isBusy;
        if (applyAllButton) applyAllButton.disabled = isBusy;

        this.updateProgress();
      },

      handleApplyProgress: function(event) {
        if (!event) {
          return;
        }

        const nextState = Object.assign({}, this.currentProgressState || {});

        if (typeof event.stage === 'string') {
          nextState.stage = event.stage;
        }
        if (typeof event.total === 'number') {
          nextState.total = event.total;
        }
        if (typeof event.totalOperations === 'number') {
          nextState.total = event.totalOperations;
        }
        if (typeof event.totalSuggestions === 'number') {
          nextState.totalSuggestions = event.totalSuggestions;
        }
        if (typeof event.processed === 'number') {
          nextState.processed = event.processed;
        }
        if (typeof event.updatedCreators === 'number') {
          nextState.updatedCreators = event.updatedCreators;
        }
        if (typeof event.declined === 'number') {
          nextState.declined = event.declined;
        }
        if (typeof event.applied === 'number') {
          nextState.applied = event.applied;
        }
        if (typeof event.skipped === 'number') {
          nextState.skipped = event.skipped;
        }
        delete nextState.percent;
        if (typeof event.percent === 'number' && Number.isFinite(event.percent)) {
          nextState.percent = event.percent;
        }
        if (typeof event.affected === 'number') {
          nextState.affected = event.affected;
        }
        if (typeof event.matched === 'number') {
          nextState.matched = event.matched;
        }

        nextState.message = this.composeProgressMessage(event, nextState);
        this.currentProgressState = nextState;
        this.updateProgress();
      },

      composeProgressMessage: function(event, state) {
        switch (event.stage) {
          case 'prepare':
            return 'Preparing normalization updates...';
          case 'operations-planned':
            return `Preparing ${event.total || 0} database updates...`;
          case 'operation-preflight': {
            const total = event.total || state.total || 0;
            const labelTotal = total > 0 ? total : '?';
            const index = (event.processed || 0) + 1;
            if (event.operation) {
              return `Checking ${event.operation} (${index} of ${labelTotal})...`;
            }
            return 'Checking affected creators...';
          }
          case 'operation-complete': {
            const total = event.total || state.total || 0;
            const labelTotal = total > 0 ? total : '?';
            const index = event.processed || 0;
            if (event.operation) {
              return `Applied ${event.operation} (${index}/${labelTotal})`;
            }
            return 'Applied normalization update.';
          }
          case 'operations-finished':
            return `Database updates complete (${event.updatedCreators || state.updatedCreators || 0} creators touched)`;
          case 'finalizing':
            return 'Recording learning decisions...';
          case 'complete':
            if ((event.updatedCreators || state.updatedCreators || 0) > 0) {
              return `All done! Updated ${event.updatedCreators || state.updatedCreators} creators.`;
            }
            if ((event.declined || state.declined || 0) > 0) {
              return 'Saved â€œkeep existingâ€ choices. No changes applied.';
            }
            return 'Normalization finished.';
          case 'error':
            return 'An error occurred while applying normalizations.';
          default:
            return 'Applying normalizations...';
        }
      },

      updateProgress: function() {
        const progressLabel = ZoteroNER_HTMLUtils.getElement('progress-label');
        if (!progressLabel) return;

        const state = this.currentProgressState;
        if (state) {
          const total = typeof state.total === 'number'
            ? state.total
            : (typeof state.totalOperations === 'number' ? state.totalOperations : (typeof state.totalSuggestions === 'number' ? state.totalSuggestions : 0));
          const processed = typeof state.processed === 'number' ? state.processed : 0;
          let percent = Number.isFinite(state.percent) ? state.percent : null;

          if (percent === null) {
            if (total > 0) {
              percent = Math.min(100, Math.round((processed / total) * 100));
            } else if (state.stage === 'complete' || state.stage === 'operations-finished') {
              percent = 100;
            } else if (this.isProcessing) {
              percent = 50;
            } else {
              percent = 0;
            }
          }

          ZoteroNER_HTMLUtils.updateProgressBar(percent);
          ZoteroNER_HTMLUtils.updateProgressLabel(state.message || 'Applying normalizations...');
          return;
        }

        if (this.analysisResults && this.analysisResults.suggestions) {
          if (this.isProcessing) {
            ZoteroNER_HTMLUtils.updateProgressBar(50);
            ZoteroNER_HTMLUtils.updateProgressLabel('Applying normalizations...');
          } else {
            ZoteroNER_HTMLUtils.updateProgressBar(100);
            ZoteroNER_HTMLUtils.updateProgressLabel('Analysis complete: ' + this.analysisResults.suggestions.length + ' variant groups found');
          }
        } else if (this.isProcessing) {
          ZoteroNER_HTMLUtils.updateProgressBar(50);
          ZoteroNER_HTMLUtils.updateProgressLabel('Analyzing library...');
        } else {
          ZoteroNER_HTMLUtils.updateProgressBar(0);
          ZoteroNER_HTMLUtils.updateProgressLabel('Ready');
        }
      },

      applySelected: async function() {
        if (this.isProcessing || !this.analysisResults || !Array.isArray(this.analysisResults.suggestions)) {
          return;
        }

        const preparedSuggestions = [];
        const declinedSuggestions = [];

        this.analysisResults.suggestions.forEach((suggestion, index) => {
          const selection = this.ensureUserSelection(index, suggestion);
          if (!selection) {
            return;
          }

          const prepared = Object.assign({}, suggestion);
          prepared.originalPrimary = suggestion.primary;
          prepared.userSelection = Object.assign({}, selection);
          prepared.variants = (suggestion.variants || []).map(variant => {
            const variantClone = Object.assign({}, variant);
            if (Array.isArray(variantClone.items)) {
              variantClone.items = variantClone.items.map(item => Object.assign({}, item));
            }
            return variantClone;
          });

          if (selection.apply === false) {
            declinedSuggestions.push(prepared);
            return;
          }

          const normalizedValue = (selection.value || '').trim();
          if (!normalizedValue) {
            return;
          }

          prepared.primary = normalizedValue;

          if (selection.mode === 'variant' && typeof selection.variantIndex === 'number') {
            prepared.selectedVariant = prepared.variants[selection.variantIndex] || null;
          }

          if (selection.mode === 'custom') {
            prepared.customNormalization = normalizedValue;
          }

          preparedSuggestions.push(prepared);
        });

        if (preparedSuggestions.length === 0 && declinedSuggestions.length === 0) {
          this.alert('Author Name Normalizer', 'No normalization choices are selected to apply. Adjust your selections or close the dialog.');
          return;
        }

        this.currentProgressState = preparedSuggestions.length > 0
          ? { stage: 'prepare', total: preparedSuggestions.length, processed: 0, message: 'Preparing normalization updates...' }
          : { stage: 'prepare', total: declinedSuggestions.length, processed: 0, message: 'Saving â€œkeep existingâ€ choices...' };

        this.setDialogBusy(true);
        this.updateProgress();

        let applyError = null;

        try {
          // Try to use the main window's Zotero.NER which has proper Zotero context
          let results;
          if (window.opener && window.opener.Zotero && window.opener.Zotero.NER) {
            results = await window.opener.Zotero.NER.applyNormalizationSuggestions(
              preparedSuggestions,
              false,
              {
                declinedSuggestions,
                progressCallback: (event) => this.handleApplyProgress(event)
              }
            );
          } else if (typeof ZoteroNER !== 'undefined' && ZoteroNER.ZoteroDBAnalyzer) {
            // Fallback: instantiate in dialog context (will fail if Zotero is undefined)
            this.dbAnalyzer = new ZoteroNER.ZoteroDBAnalyzer();
            if (!this.dbAnalyzer || typeof this.dbAnalyzer.applyNormalizationSuggestions !== 'function') {
              throw new Error('Zotero database analyzer is not available in this context.');
            }
            results = await this.dbAnalyzer.applyNormalizationSuggestions(preparedSuggestions, false, {
              declinedSuggestions,
              progressCallback: (event) => this.handleApplyProgress(event)
            });
          } else {
            throw new Error('Zotero database analyzer is not available in this context.');
          }

          if (results.applied === 0 && results.updatedCreators === 0 && results.declinedRecorded > 0) {
            this.alert('Author Name Normalizer', 'No normalization changes were applied. Your â€œkeep existingâ€ choices were saved for future runs.');
          } else {
            const summary = [
              'Suggestions reviewed: ' + results.totalSuggestions,
              'Applied: ' + results.applied,
              'Skipped: ' + results.skipped,
              'Creators updated: ' + (results.updatedCreators || 0)
            ];

            if (results.declinedRecorded > 0) {
              summary.push('Saved â€œkeep existingâ€ decisions: ' + results.declinedRecorded);
            }

            if (results.errors > 0) {
              summary.push('Errors: ' + results.errors);
            }

            this.alert('Author Name Normalizer', 'Normalization selections applied!\n\n' + summary.join('\n'));
          }

        } catch (error) {
          applyError = error;
          console.error(error);
          this.alert('Error', 'Failed to apply normalization selections: ' + error.message);
        } finally {
          this.setDialogBusy(false);
          this.currentProgressState = null;
          this.updateProgress();
          if (!applyError) {
            window.close();
          }
        }
      },

      applyAllSelected: async function() {
        // Count how many normalizations are selected
        let selectedCount = 0;
        for (const [index, selection] of this.userSelections) {
          if (selection.apply !== false && selection.mode !== 'keep') {
            selectedCount++;
          }
        }

        if (selectedCount === 0) {
          this.alert('Author Name Normalizer', 'No normalization choices are selected to apply. Select at least one normalization to apply.');
          return;
        }

        // Show confirmation dialog for bulk operations
        const confirmed = this.confirm(
          'Apply Multiple Normalizations',
          `You are about to apply ${selectedCount} normalization(s) to your library.\n\n` +
          `This will modify author names in ${selectedCount} item(s).\n\n` +
          `Are you sure you want to continue?`
        );

        if (!confirmed) {
          this.log('User cancelled Apply All operation');
          return;
        }

        // Proceed with applying all selected normalizations
        this.log('User confirmed Apply All for ' + selectedCount + ' normalizations');
        await this.applySelected();
      },

      showLoadingState: function() {
        this.log('Showing loading state');
        
        // Hide empty message, show progress
        ZoteroNER_HTMLUtils.setHidden('empty-message', true);
        ZoteroNER_HTMLUtils.setHidden('summary-group', true);
        ZoteroNER_HTMLUtils.setHidden('variant-section', true);
        ZoteroNER_HTMLUtils.setHidden('progress-container', false);
        ZoteroNER_HTMLUtils.updateProgressLabel('Analyzing library...');
        ZoteroNER_HTMLUtils.updateProgressBar(0);
        this.setApplyEnabled(false);
      },
      
      handleAnalysisProgress: function(progress) {
        if (!progress) {
          this.log('handleAnalysisProgress: received null progress');
          return;
        }
        this.log('handleAnalysisProgress: stage=' + progress.stage + ', processed=' + progress.processed + ', total=' + progress.total + ', percent=' + progress.percent);
        ZoteroNER_HTMLUtils.setHidden('progress-container', false);
        // Log debug messages to file
        if (progress.stage === 'debug' && progress.message) {
          this.fileLogger.log('ANALYZER: ' + progress.message);
        }
        let message = 'Analyzing library...';
        let percent = 0;
        let isIndeterminate = false;
        if (progress.stage === 'filtering_items') {
          message = `Loading items... (${progress.processed || 0} of ${progress.total || '?'})`;
          percent = progress.percent || 0;
        } else if (progress.stage === 'analyzing_surnames') {
          this.log('handleAnalysisProgress: analyzing_surnames stage, percent=' + progress.percent);
          if (progress.total) {
            message = `Analyzing surnames... (${progress.processed || 0} of ${progress.total})`;
            percent = progress.percent || 0;
          } else {
            message = `Analyzing surnames... (${progress.processed || 0} comparisons)`;
            isIndeterminate = true;
          }
        } else if (progress.stage === 'generating_suggestions') {
          message = 'Generating normalization suggestions...';
          percent = 95;
        } else if (progress.stage === 'debug') {
          message = progress.message || 'Analyzing...';
          percent = progress.percent || 0;
        }
        ZoteroNER_HTMLUtils.updateProgressLabel(message);
        // Update progress bar with visual feedback
        const fill = document.getElementById('progress-fill');
        if (fill) {
          if (isIndeterminate) {
            fill.classList.add('indeterminate');
          } else {
            fill.classList.remove('indeterminate');
            fill.style.width = Math.max(percent, 3) + '%'; // Min 3% for visibility
          }
        }
      },
      
      updateAnalysisResults: function(analysisResults) {
        this.fileLogger.log('updateAnalysisResults called with ' + (analysisResults ? 'data' : 'NULL'));
        if (analysisResults) {
          this.fileLogger.log('  suggestions count: ' + (analysisResults.suggestions ? analysisResults.suggestions.length : 0));
          this.fileLogger.log('  totalUniqueSurnames: ' + (analysisResults.totalUniqueSurnames || 'undefined'));
        }

        // Mark analysis as complete to prevent timeout error
        this.analysisComplete = true;
        
        // Clear the timeout interval if it's still running
        if (this.checkAnalysisInterval) {
          clearInterval(this.checkAnalysisInterval);
          this.checkAnalysisInterval = null;
        }

        if (!analysisResults) {
          this.fileLogger.log('ERROR: updateAnalysisResults received NULL');
          this.showEmptyState('Analysis completed but no results were returned.');
          return;
        }

        this.log('Updating dialog with analysis results');
        this.log('Results contain: ' + (analysisResults.suggestions ? analysisResults.suggestions.length : 0) + ' suggestions');

        this.analysisResults = analysisResults;
        this.resetSelections();
        this.clearVariantDetails();
        
        // Show the variant section
        ZoteroNER_HTMLUtils.setHidden('variant-section', false);
        ZoteroNER_HTMLUtils.setHidden('progress-container', true);
        
        this.updateSummaryHeader();
        this.populateVariantGroupList();
        this.refreshApplyButtonState();
        this.updateProgress();
      }
    };

    // Event listeners
    document.getElementById('apply-button').addEventListener('click', function() {
      ZoteroNER_NormalizationDialog.applySelected();
    });

    document.getElementById('apply-all-button').addEventListener('click', function() {
      ZoteroNER_NormalizationDialog.applyAllSelected();
    });

    document.getElementById('cancel-button').addEventListener('click', function() {
      window.close();
    });

    // Expose controller globally so parent window can call it
    window.ZoteroNERController = ZoteroNER_NormalizationDialog;

    // Start
    ZoteroNER_NormalizationDialog.init();
  </script>
</body>
</html>