<!DOCTYPE html>
<html>
<head>
  <title>Author Name Normalizer</title>
  <style>
    html, body {
      font-family: -moz-dialog, Arial, sans-serif;
      padding: 12px;
      margin: 0;
      background: #f9f9f9;
      color: #333;
    }
    h1 { margin-top: 0; }
    .summary {
      background: #e8f4fd;
      padding: 10px;
      margin: 8px 0;
      border: 1px solid #b3d9ff;
      border-radius: 4px;
    }
    .summary-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .variant-group {
      margin: 6px 0;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
    }
    .variant-group h3 {
      margin: 0 0 4px 0;
      font-size: 1em;
      color: #0066cc;
    }
    .variant-group h4 { margin: 0 0 10px 0; color: #0066cc; }
    .variant-group-header {
      margin-bottom: 6px;
    }
    .variant-group-summary {
      font-size: 0.8em;
      color: #666;
      margin-bottom: 2px;
    }
    .surname-variant {
      font-style: italic;
    }
    .primary {
      font-weight: bold;
      color: #0066cc;
      margin-bottom: 10px;
      padding: 5px;
      background: #f0f8ff;
      border-radius: 3px;
    }
    .variants-list {
      list-style: none;
      padding: 0;
    }
    .variant {
      margin: 5px 0;
      padding: 5px;
      background: #f9f9f9;
      border-radius: 3px;
    }
    .variant-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin: 8px 0 4px 0;
    }
    .variant-pill {
      display: inline-flex;
      align-items: center;
      padding: 4px 10px;
      border: 1px solid #c8d1dc;
      border-radius: 16px;
      background: #f7f9fc;
      font-size: 0.9em;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
    }
    .variant-pill:hover {
      border-color: #007acc;
      background: #eef5ff;
    }
    .variant-pill.active {
      background: #ffd700 !important;
      border-color: #b8860b !important;
      color: #000 !important;
      box-shadow: 0 0 0 1px #ffd700;
      font-weight: 600;
    }
    .variant-pill.recommended {
      border-color: #2563eb;
      color: #1d4ed8;
      font-weight: 600;
    }
    .frequency { 
      color: #666; 
      font-size: 0.9em; 
      font-style: italic;
    }
    .radio-group {
      margin: 6px 0;
    }
    .radio-group input[type="radio"] {
      margin-right: 5px;
    }
    .radio-group label {
      word-wrap: break-word;
      max-width: 100%;
    }
    .confidence {
      font-size: 0.9em;
      color: #007acc;
      font-weight: bold;
    }
    button { 
      margin: 10px 5px; 
      padding: 8px 16px; 
      border: 1px solid #ccc; 
      border-radius: 3px;
      background: #f0f0f0;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      background: #e0e0e0;
    }
    .custom-normalization {
      margin-top: 12px;
      padding: 10px;
      background: #f6f8fa;
      border-radius: 4px;
      border: 1px solid #d8dee4;
    }
    .custom-normalization label {
      display: block;
      font-weight: 600;
      margin-bottom: 6px;
    }
    .custom-normalization input[type="text"] {
      width: 150px;
      padding: 4px 6px;
      border: 1px solid #c9d1d9;
      border-radius: 3px;
      font-size: 0.9em;
    }
    .custom-normalization input[type="text"]:disabled {
      background: #f0f0f0;
      color: #555;
    }
    .card-actions {
      display: flex;
      gap: 6px;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #e8e8e8;
    }
    .card-actions button {
      margin: 0;
      padding: 4px 10px;
      font-size: 0.85em;
    }
    .card-actions .apply-btn {
      background: #007acc;
      color: white;
      border-color: #0066a8;
    }
    .card-actions .apply-btn:hover:not(:disabled) {
      background: #0066a8;
    }
    .card-actions .not-variants-btn {
      background: #f9f9f9;
      color: #666;
      border-color: #ccc;
    }
    .card-actions .not-variants-btn:hover:not(:disabled) {
      background: #f0f0f0;
      color: #333;
    }
    .progress { 
      margin: 10px 0; 
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .progress-bar { 
      flex: 1; 
      height: 20px; 
      background: #f0f0f0; 
      border-radius: 10px; 
      overflow: hidden;
      border: 1px solid #ccc;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #0066cc, #007acc);
      transition: width 0.3s ease;
      width: 0%;
      min-width: 3px; /* Always show at least a small amount for visual feedback */
    }
    .progress-fill.indeterminate {
      background: linear-gradient(90deg, #0066cc 0%, #007acc 50%, #0066cc 100%);
      background-size: 200% 100%;
      animation: indeterminate-progress 1.5s ease-in-out infinite;
      width: 0%;
    }
    @keyframes indeterminate-progress {
      0% { background-position: 100% 0; }
      100% { background-position: -100% 0; }
    }
    .empty-message {
      text-align: center;
      color: #666;
      font-style: italic;
      padding: 20px;
    }
    .empty-message-content {
      text-align: left;
      color: #444;
      font-style: normal;
    }
    .empty-message-content p {
      margin: 8px 0;
    }
    .surname-frequency-list {
      list-style: disc;
      padding-left: 20px;
      margin: 6px 0 0 0;
    }
    .surname-frequency-list li {
      margin: 4px 0;
    }
    .surname-frequency-list .surname {
      font-weight: 600;
      color: #222;
    }
    #progress-container { display: none; }
    #suggestions-container:empty::after {
      content: "No suggestions to display.";
      display: block;
      text-align: center;
      color: #666;
      padding: 20px;
    }
    .selected {
      background-color: #e3f2fd;
      border-color: #2196f3;
    }
    .variant-meta {
      font-size: 0.85em;
      color: #555;
      margin-top: 4px;
    }
    #variant-filter-bar {
      margin: 12px 0 18px;
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    #variant-filter-input {
      flex: 1 1 150px;
      max-width: 200px;
      padding: 4px 6px;
      border: 1px solid #c9d1d9;
      border-radius: 4px;
      font-size: 0.85em;
      background: #fff;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    #variant-filter-input:focus {
      outline: none;
      border-color: #007acc;
      box-shadow: 0 0 0 3px rgba(0, 122, 204, 0.15);
    }
    #variant-filter-summary {
      font-size: 0.9em;
      color: #4b5563;
      white-space: nowrap;
    }
    #variant-section {
      margin: 20px 0;
    }
    #variant-layout {
      display: grid;
      grid-template-columns: 1fr 260px;
      grid-template-rows: auto;
      gap: 10px;
      width: 100%;
    }
    #variant-groups-column {
      grid-column: 1;
      grid-row: 1;
      min-width: 0;
      overflow-y: auto;
      max-height: calc(100vh - 250px);
    }
    .variant-detail {
      grid-column: 2;
      grid-row: 1;
      min-width: 250px;
      width: 250px;
      padding: 8px;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      background: #fff;
      box-shadow: 0 3px 8px rgba(15, 23, 42, 0.08);
      max-height: calc(100vh - 250px);
      overflow-y: auto;
      align-self: start;
      position: sticky;
      top: 0;
    }
    .variant-detail h4 {
      margin: 0 0 4px 0;
      color: #005a9c;
      font-size: 0.95em;
    }
    .variant-detail-context {
      font-size: 0.8em;
      color: #586069;
      margin-bottom: 6px;
    }
    .variant-detail-empty {
      font-size: 0.85em;
      color: #69737d;
      padding: 8px 0;
    }
    .variant-detail.empty #variant-detail-items,
    .variant-detail.empty .variant-detail-context {
      display: none;
    }
    .variant-detail:not(.empty) .variant-detail-empty {
      display: none;
    }
    .variant-detail-items {
      list-style: none;
      padding-left: 0;
      margin: 0;
      max-height: 200px;
      overflow-y: auto;
      font-size: 0.85em;
    }
    .variant-detail-items li {
      margin: 4px 0;
      padding: 3px 5px;
      background: #fafbfc;
      border-radius: 3px;
    }
    .variant-detail-items li:hover {
      background: #f0f4f8;
    }
    .item-author {
      color: #6a737e;
      font-size: 0.9em;
      font-weight: 500;
    }
    .item-title {
      color: #24292e;
    }
    .item-link {
      color: #005a9c;
      text-decoration: none;
      cursor: pointer;
    }
    .item-link:visited {
      color: #005a9c;
    }
    .item-link:hover {
      text-decoration: underline;
    }
    .item-year {
      color: #6a737e;
      font-size: 0.9em;
    }
    .item-details {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: baseline;
    }
    .item-details .item-author {
      flex: 0 0 auto;
    }
    .item-details .item-link {
      flex: 1 1 auto;
      min-width: 150px;
      color: #005a9c;
      text-decoration: none;
    }
    .item-details .item-link:hover {
      text-decoration: underline;
    }
    .item-details .item-year {
      flex: 0 0 auto;
    }
    @media (max-width: 960px) {
      #variant-layout {
        grid-template-columns: 1fr;
      }
      .variant-detail {
        position: static;
        max-height: none;
      }
    }
  </style>
</head>
<body>
  <h1 style="display:none;">Author Name Normalizer</h1>

  <!-- Summary header for full-library analysis -->
  <div id="summary-group" class="summary" style="display: none;">
    <h3>Library Analysis Summary</h3>
    <div class="summary-grid">
      <div><strong>Unique surnames:</strong> <span id="summary-total-creators">Loading...</span></div>
      <div><strong>Variant groups:</strong> <span id="summary-variant-groups">Loading...</span></div>
      <div><strong>Pending normalizations:</strong> <span id="summary-pending-normalizations">Loading...</span></div>
    </div>
  </div>

  <!-- Progress indicator for batch processing -->
  <div id="progress-container" class="progress">
    <div class="progress-bar">
      <div id="progress-fill" class="progress-fill"></div>
    </div>
    <span id="progress-label">Processing...</span>
  </div>

  <!-- Variant groups + detail layout -->
  <div id="variant-section">
    <h3>Creator Variant Groups</h3>
    <div id="variant-filter-bar">
      <input type="search" id="variant-filter-input" placeholder="Filter variant groupsâ€¦" aria-label="Filter variant groups">
      <span id="variant-filter-summary">Showing all groups</span>
    </div>
    <div id="variant-layout">
      <div id="variant-groups-column">
        <div id="variant-groups-container">
          <!-- Variant groups will be dynamically populated here -->
        </div>
      </div>
      <aside id="variant-detail-panel" class="variant-detail empty hidden">
        <h4 id="variant-detail-title">Variant details</h4>
        <div id="variant-detail-context" class="variant-detail-context"></div>
        <div id="variant-detail-empty" class="variant-detail-empty">Select a variant pill to review sample items and occurrences.</div>
        <ul id="variant-detail-items"></ul>
      </aside>
    </div>
  </div>

  <!-- Empty state -->
  <div id="empty-message" class="empty-message" style="display: none;">
    No variant groups found. All creator names appear to be consistent.
  </div>

  <!-- Action buttons -->
  <div style="text-align: right; margin-top: 20px;">
    <button id="apply-all-button" disabled style="margin-right: 10px;">Apply All Selected</button>
    <button id="apply-button" disabled>Apply Selected</button>
    <button id="cancel-button">Cancel</button>
  </div>

  <script type="application/javascript" src="chrome://zoteronamenormalizer/content/scripts/zotero-ner-bundled.js"></script>
  <script type="application/javascript">
    /* global Zotero, ZoteroNER */

    // HTML DOM utils
    const ZoteroNER_HTMLUtils = {
      getElement: function(id) {
        return document.getElementById(id);
      },
      createElement: function(tagName, attributes = {}) {
        const el = document.createElement(tagName);
        for (const [key, value] of Object.entries(attributes)) {
          el.setAttribute(key, value);
        }
        return el;
      },
      appendTo: function(parentId, child) {
        const parent = this.getElement(parentId);
        if (parent) parent.appendChild(child);
      },
      clearContainer: function(id) {
        const container = this.getElement(id);
        if (container) container.innerHTML = '';
      },
      setText: function(id, text) {
        const el = this.getElement(id);
        if (el) el.textContent = text;
      },
      setHidden: function(id, hidden) {
        const el = this.getElement(id);
        if (el) el.style.display = hidden ? 'none' : 'block';
      },
      updateProgressBar: function(percent) {
        const fill = document.getElementById('progress-fill');
        if (fill) {
          fill.classList.remove('indeterminate');
          fill.style.width = percent + '%';
        }
      },
      updateProgressLabel: function(text) {
        const label = document.getElementById('progress-label');
        if (label) label.textContent = text;
      },
      setProgressIndeterminate: function(indeterminate) {
        const fill = document.getElementById('progress-fill');
        if (fill) {
          if (indeterminate) {
            fill.classList.add('indeterminate');
          } else {
            fill.classList.remove('indeterminate');
          }
        }
      }
    };

    // Zotero API access helper - robust pattern for dialog context
    var ZoteroNER_ZoteroAPI = {
      /**
       * Get Zotero API reference from dialog context
       * Tries multiple patterns in order of preference
       * @returns {Object|null} Zotero API or null if unavailable
       */
      getZotero: function() {
        // Pattern 1: window.opener.Zotero (for dialogs opened via openDialog)
        if (window.opener && window.opener.Zotero) {
          return window.opener.Zotero;
        }

        // Pattern 2: parent frame Zotero (for iframes)
        let current = window;
        while (current.parent && current.parent !== current) {
          if (current.parent.Zotero) {
            return current.parent.Zotero;
          }
          current = current.parent;
        }

        // Pattern 3: Global Zotero (may not be available in dialog context)
        if (typeof Zotero !== 'undefined') {
          return Zotero;
        }

        return null;
      },

      /**
       * Get Zotero.NER / Zotero.NameNormalizer reference
       * @returns {Object|null} NameNormalizer API or null if unavailable
       */
      getNameNormalizer: function() {
        const zotero = this.getZotero();
        if (!zotero) return null;

        // Prefer Zotero.NameNormalizer (modern)
        if (zotero.NameNormalizer) {
          return zotero.NameNormalizer;
        }

        // Fall back to Zotero.NER (legacy alias)
        if (zotero.NER) {
          return zotero.NER;
        }

        return null;
      },

      /**
       * Check if Zotero APIs are available
       * @returns {boolean}
       */
      isAvailable: function() {
        return this.getZotero() !== null;
      }
    };

    // Embedded controller
    var ZoteroNER_NormalizationDialog = {
      dbAnalyzer: null,
      isProcessing: false,
    analysisResults: null,
    items: null,
    analysisResultsSource: null,
    userSelections: null,
    variantDetailState: null,
    filterText: '',
    currentProgressState: null,
    lastProgressTime: null,
    lastHeartbeat: null,
    progressUpdateTimer: null,

      init: function() {
        console.log('Dialog initialization started');
        this.userSelections = new Map();
        this.variantDetailState = null;
        this.filterText = '';
        this.currentProgressState = null;

        // Set up event delegation for clickable item links
        document.addEventListener('click', (event) => {
          const link = event.target.closest('.item-link');
          if (link) {
            event.preventDefault();
            const itemKey = link.getAttribute('data-item-key');
            // Show debug in the detail panel
            const debugEl = document.getElementById('variant-detail-items');
            if (debugEl && debugEl.firstChild && debugEl.firstChild.className === 'debug-info') {
              debugEl.firstChild.textContent = 'DEBUG: Clicked itemKey=' + itemKey;
            }
            if (itemKey) {
              // Try to select the item in Zotero using multiple methods
              const opener = window.opener;
              if (opener) {
                try {
                  // Method 1: Use ZoteroPane (internal API, most reliable)
                  if (opener.ZoteroPane && opener.ZoteroPane.selectItem) {
                    // Try to resolve key to ID if possible
                    if (opener.Zotero && opener.Zotero.Items && opener.Zotero.Items.getByLibraryAndKeyAsync) {
                      const libraryID = opener.Zotero.Libraries.userLibraryID;
                      opener.Zotero.Items.getByLibraryAndKeyAsync(libraryID, itemKey).then(item => {
                        if (item && item.id) {
                          opener.ZoteroPane.selectItem(item.id);
                        } else {
                          // Fallback: try with key (may not work)
                          opener.ZoteroPane.selectItem(itemKey);
                        }
                      }).catch(e => {
                        console.error('Failed to get item by key:', e);
                      });
                      return;
                    } else {
                      opener.ZoteroPane.selectItem(itemKey);
                      return;
                    }
                  }
                  // Method 2: Use Zotero.NameNormalizer.selectItem (our helper)
                  if (opener.Zotero && opener.Zotero.NameNormalizer && opener.Zotero.NameNormalizer.selectItem) {
                    opener.Zotero.NameNormalizer.selectItem(itemKey);
                    return;
                  }
                  // Method 3: Use Zotero.launchURL with zotero:// URI (least reliable)
                  if (opener.Zotero && opener.Zotero.launchURL) {
                    const url = 'zotero://select/library/items/' + itemKey;
                    opener.Zotero.launchURL(url);
                    return;
                  }
                  console.error('No method available to select item');
                } catch (e) {
                  console.error('Failed to select item:', e);
                  if (debugEl && debugEl.firstChild && debugEl.firstChild.className === 'debug-info') {
                    debugEl.firstChild.textContent = 'DEBUG: Error selecting item: ' + e.message;
                  }
                }
              } else {
                if (debugEl && debugEl.firstChild && debugEl.firstChild.className === 'debug-info') {
                  debugEl.firstChild.textContent = 'DEBUG: No opener window';
                }
              }
            }
          }
        });

        this.setupFilterInput();
        this.setupKeyboardShortcuts();
        Promise.resolve(this.initialize()).catch((error) => {
          console.error(error);
          this.alert('Error', 'Failed to initialize: ' + error.message);
          window.close();
        });
      },

      unwrapDialogParams: function(raw) {
        if (!raw) {
          return raw;
        }

        try {
          if (raw.wrappedJSObject) {
            return raw.wrappedJSObject;
          }
        } catch (err) {
          this.log('Failed to access wrappedJSObject: ' + err.message);
        }

        if (typeof raw.getProperty === 'function') {
          try {
            const wrapped = raw.getProperty('wrappedJSObject');
            if (wrapped) {
              return wrapped;
            }
          } catch (err) {
            this.log('No wrappedJSObject property in param bag: ' + err.message);
          }

          let items;
          let analysisResults;
          let analysisResultsJSON;

          try {
            items = raw.getProperty('items');
          } catch (err) {
            this.log('Unable to read items from param bag: ' + err.message);
          }

          try {
            analysisResults = raw.getProperty('analysisResults');
          } catch (err) {
            this.log('Unable to read analysisResults from param bag: ' + err.message);
          }

          try {
            analysisResultsJSON = raw.getProperty('analysisResultsJSON');
          } catch (err) {
            this.log('Unable to read analysisResultsJSON from param bag: ' + err.message);
          }

          if (analysisResultsJSON || analysisResults || items) {
            return {
              items,
              analysisResults,
              analysisResultsJSON
            };
          }
        }

        return raw;
      },

      sanitizeAnalysisResults: function(value, contextLabel = 'analysis results') {
        if (!value || typeof value !== 'object') {
          return null;
        }

        try {
          const plain = JSON.parse(JSON.stringify(value));
          this.log('Sanitized ' + contextLabel + ' (suggestions: ' + ((plain && Array.isArray(plain.suggestions)) ? plain.suggestions.length : 'unknown') + ')');
          return plain;
        } catch (err) {
          this.log('Failed to sanitize ' + contextLabel + ': ' + err.message);
        }

        return null;
      },

      safeParseJSON: function(jsonString, contextLabel = 'analysisResultsJSON') {
        if (!jsonString || typeof jsonString !== 'string') {
          return null;
        }

        try {
          const parsed = JSON.parse(jsonString);
          this.log('Parsed ' + contextLabel + ' (suggestions: ' + ((parsed && Array.isArray(parsed.suggestions)) ? parsed.suggestions.length : 'unknown') + ')');
          return parsed;
        } catch (err) {
          this.log('Failed to parse ' + contextLabel + ': ' + err.message);
        }

        return null;
      },

      resolveAnalysisResults: function(params, contextLabel = 'dialog params') {
        if (!params) {
          return null;
        }

        if (params.analysisResults && typeof params.analysisResults === 'object') {
          const sanitized = this.sanitizeAnalysisResults(params.analysisResults, contextLabel + '.analysisResults');
          if (sanitized) {
            this.analysisResultsSource = contextLabel + '.analysisResults';
            return sanitized;
          }
        }

        if (params.analysisResultsJSON) {
          const parsed = this.safeParseJSON(params.analysisResultsJSON, contextLabel + '.analysisResultsJSON');
          if (parsed) {
            this.analysisResultsSource = contextLabel + '.analysisResultsJSON';
            return parsed;
          }
        }

        return null;
      },

      log: function(message) {
        const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
        const logLine = 'NER-DIALOG:' + timestamp + ' ' + message;
        console.log(logLine);
        try {
          if (typeof Zotero !== 'undefined' && typeof Zotero.debug === 'function') {
            Zotero.debug('Zotero NER Dialog: ' + message);
          }
        } catch (e) {}
        // Note: XPCOM file logging removed (dead code, never worked in modern browsers)
      },

      alert: function(title, message) {
        try {
          if (typeof Zotero !== 'undefined' && typeof Zotero.alert === 'function') {
            Zotero.alert(null, title, message);
          } else {
            window.alert(title + ': ' + message);
          }
        } catch (e) {
          window.alert(title + ': ' + message);
        }
      },

      setupFilterInput: function() {
        const input = ZoteroNER_HTMLUtils.getElement('variant-filter-input');
        if (!input) {
          return;
        }

        input.value = this.filterText || '';
        input.addEventListener('input', (event) => {
          this.handleFilterInput(event.target.value);
        });
      },

      setupKeyboardShortcuts: function() {
        document.addEventListener('keydown', (event) => {
          // Ignore shortcuts when typing in input fields
          const tagName = event.target.tagName.toLowerCase();
          if (tagName === 'input' || tagName === 'textarea') {
            return;
          }

          const isMod = event.ctrlKey || event.metaKey;

          // Ctrl/Cmd + Enter - Apply selected
          if (isMod && event.key === 'Enter') {
            event.preventDefault();
            const applyBtn = document.getElementById('apply-button');
            if (applyBtn && !applyBtn.disabled) {
              this.applySelected();
            }
            return;
          }

          // Ctrl/Cmd + A - Apply all
          if (isMod && event.key.toLowerCase() === 'a') {
            event.preventDefault();
            const applyAllBtn = document.getElementById('apply-all-button');
            if (applyAllBtn && !applyAllBtn.disabled) {
              this.applyAllSelected();
            }
            return;
          }

          // Ctrl/Cmd + F - Focus filter
          if (isMod && event.key.toLowerCase() === 'f') {
            event.preventDefault();
            const filterInput = document.getElementById('variant-filter-input');
            if (filterInput) {
              filterInput.focus();
              filterInput.select();
            }
            return;
          }

          // Escape - Cancel/close
          if (event.key === 'Escape') {
            event.preventDefault();
            window.close();
            return;
          }

          // Arrow keys - Navigate pills within current group
          if (event.key === 'ArrowLeft' || event.key === 'ArrowRight' ||
              event.key === 'ArrowUp' || event.key === 'ArrowDown') {
            this.handlePillNavigation(event);
            return;
          }

          // Enter/Space - Activate focused pill
          if (event.key === 'Enter' || event.key === ' ') {
            const focusedPill = document.querySelector('.variant-pill:focus');
            if (focusedPill) {
              event.preventDefault();
              focusedPill.click();
            }
            return;
          }
        });
      },

      handlePillNavigation: function(event) {
        const direction = event.key === 'ArrowLeft' || event.key === 'ArrowUp' ? -1 : 1;
        const pills = Array.from(document.querySelectorAll('.variant-pill'));
        const focusedIndex = pills.findIndex(p => p === document.activeElement);

        if (focusedIndex === -1) {
          // No pill focused, focus first or last based on direction
          const targetIndex = direction === 1 ? 0 : pills.length - 1;
          if (pills[targetIndex]) {
            pills[targetIndex].focus();
          }
        } else {
          // Navigate to adjacent pill
          let newIndex = focusedIndex + direction;
          if (newIndex < 0) newIndex = pills.length - 1;
          if (newIndex >= pills.length) newIndex = 0;

          if (pills[newIndex]) {
            pills[newIndex].focus();
          }
        }

        event.preventDefault();
      },

      handleFilterInput: function(rawValue) {
        this.filterText = (rawValue || '').trim();
        this.populateVariantGroupList();
      },

      matchesFilter: function(suggestion) {
        const query = (this.filterText || '').toLowerCase();
        if (!query) {
          return true;
        }

        const terms = [];
        const capture = (value) => {
          if (!value) {
            return;
          }
          if (typeof value === 'string') {
            terms.push(value.toLowerCase());
          }
        };

        capture(suggestion.type);
        capture(suggestion.surname);
        capture(typeof suggestion.primary === 'string' ? suggestion.primary : this.formatNameString(suggestion.primary));
        capture(suggestion.recommendedFullName);
        capture(suggestion.recommendedFirstName);

        (suggestion.variants || []).forEach(variant => {
          capture(variant.name);
          capture(variant.firstName);
          capture(variant.lastName);
        });

        return terms.some(term => term.includes(query));
      },

      updateFilterSummary: function(visibleCount, totalCount) {
        const summaryEl = ZoteroNER_HTMLUtils.getElement('variant-filter-summary');
        if (!summaryEl) {
          return;
        }

        if (!totalCount) {
          summaryEl.textContent = 'No variant groups available';
          return;
        }

        if (!this.filterText) {
          summaryEl.textContent = `Showing all ${totalCount} variant groups`;
          return;
        }

        summaryEl.textContent = `Showing ${visibleCount} of ${totalCount} groups`;
      },
      
      initialize: async function() {
        this.log('Dialog initialize started');

        // Track when analysis is complete (set by updateAnalysisResults)
        this.analysisComplete = false;

        let params = null;

        try {
          if (typeof window.arguments !== 'undefined' && window.arguments.length > 0) {
            params = window.arguments[0];
          }
        } catch (err) {
          this.log('Unable to read window arguments: ' + err.message);
        }

        if (params) {
          params = this.unwrapDialogParams(params);
        }

        if (!params && window.ZoteroNERDialogParams) {
          params = this.unwrapDialogParams(window.ZoteroNERDialogParams);
        }

        if (!params && window.ZoteroNERDialogParamsJSON) {
          params = { analysisResultsJSON: window.ZoteroNERDialogParamsJSON };
        }

        if (!params && window.opener) {
          try {
            if (window.opener.ZoteroNERDialogParams) {
              params = this.unwrapDialogParams(window.opener.ZoteroNERDialogParams);
            }
          } catch (err) {
            this.log('Unable to read ZoteroNERDialogParams from opener: ' + err.message);
          }
        }

        if (!params && window.opener && window.opener.ZoteroNERDialogParamsJSON) {
          params = { analysisResultsJSON: window.opener.ZoteroNERDialogParamsJSON };
        }

        if (!params && window.opener && window.opener.ZoteroNERAnalysisResultsJSON) {
          params = { analysisResultsJSON: window.opener.ZoteroNERAnalysisResultsJSON };
        }

        if (!params && window.opener && window.opener.ZoteroNERAnalysisResults) {
          const sanitized = this.sanitizeAnalysisResults(window.opener.ZoteroNERAnalysisResults, 'opener.ZoteroNERAnalysisResults');
          if (sanitized) {
            params = { analysisResults: sanitized };
          }
        }

        if (!params && window.ZoteroNERAnalysisResultsJSON) {
          params = { analysisResultsJSON: window.ZoteroNERAnalysisResultsJSON };
        }

        if (!params && window.ZoteroNERAnalysisResults) {
          const sanitizedCurrent = this.sanitizeAnalysisResults(window.ZoteroNERAnalysisResults, 'window.ZoteroNERAnalysisResults');
          if (sanitizedCurrent) {
            params = { analysisResults: sanitizedCurrent };
          }
        }

        let analysisResults = null;

        if (params) {
          params = this.unwrapDialogParams(params);
        }

        // Try to resolve analysisResults from params
        if (params) {
          analysisResults = this.resolveAnalysisResults(params, 'dialog params');
        }

        // Try other sources if needed
        if (!analysisResults && window.opener && window.opener.ZoteroNERAnalysisResultsJSON) {
          analysisResults = this.safeParseJSON(window.opener.ZoteroNERAnalysisResultsJSON, 'opener.ZoteroNERAnalysisResultsJSON');
        }

        if (!analysisResults && window.opener && window.opener.ZoteroNERAnalysisResults) {
          analysisResults = this.sanitizeAnalysisResults(window.opener.ZoteroNERAnalysisResults, 'opener.ZoteroNERAnalysisResults direct');
        }

        if (!analysisResults && window.ZoteroNERAnalysisResultsJSON) {
          analysisResults = this.safeParseJSON(window.ZoteroNERAnalysisResultsJSON, 'window.ZoteroNERAnalysisResultsJSON');
        }

        if (!analysisResults && window.ZoteroNERAnalysisResults) {
          analysisResults = this.sanitizeAnalysisResults(window.ZoteroNERAnalysisResults, 'window.ZoteroNERAnalysisResults direct');
        }

        // If still no results but params looks like results itself
        if (!analysisResults && params && typeof params === 'object' && !params.loading) {
          const direct = this.sanitizeAnalysisResults(params, 'dialog params direct');
          if (direct) {
            analysisResults = direct;
            this.analysisResultsSource = 'dialog params direct';
          }
        }

        if (params && params.items) {
          this.items = params.items;
        }

        if (!analysisResults) {
          this.log('No analysis results found');
          this.showEmptyState('No analysis results were provided to the dialog.');
          this.updateProgress();
          return;
        }

        // Check if this is a loading state OR if suggestions are NULL (stale cached data)
        // We need fresh analysis if:
        // 1. loading === true (explicitly waiting for analysis)
        // 2. suggestions is NULL (stale cached data with no results)
        if (analysisResults.loading === true || analysisResults.suggestions === null) {
          const reason = analysisResults.loading === true ? 'loading=true' : 'suggestions=NULL';
          this.log('Dialog opened in loading state (' + reason + ')');
          // Always show loading state first to ensure progress bar is visible immediately
          this.showLoadingState();
          // Then start progress tracking for timeout detection
          this.startProgressTracking();
          return;
        }

        this.analysisResults = analysisResults;
        this.resetSelections();
        this.clearVariantDetails();

        this.log('Analysis results source: ' + (this.analysisResultsSource || 'unknown'));
        this.log('Analysis results loaded: ' + (this.analysisResults.suggestions ? this.analysisResults.suggestions.length : 0) + ' suggestions; unique surnames: ' + (this.analysisResults.totalUniqueSurnames ?? 'unknown'));

        this.updateSummaryHeader();
        this.populateVariantGroupList();
        this.refreshApplyButtonState();
        // Hide progress container when showing results
        ZoteroNER_HTMLUtils.setHidden('progress-container', true);
        this.updateProgress();
      },

      showEmptyState: function(message) {
        // Ensure progress bar is hidden
        ZoteroNER_HTMLUtils.setHidden('progress-container', true);
        
        if (this.analysisResults) {
          this.updateSummaryHeader();
        } else {
          ZoteroNER_HTMLUtils.setHidden('summary-group', true);
        }

        const totalSuggestions = (this.analysisResults && Array.isArray(this.analysisResults.suggestions))
          ? this.analysisResults.suggestions.length
          : 0;
        this.updateFilterSummary(0, totalSuggestions);

        ZoteroNER_HTMLUtils.clearContainer('variant-groups-container');
        this.clearVariantDetails();

        this.setApplyEnabled(false);

        const emptyMsg = ZoteroNER_HTMLUtils.getElement('empty-message');
        if (emptyMsg) {
          const frequencies = this.analysisResults && this.analysisResults.surnameFrequencies
            ? Object.entries(this.analysisResults.surnameFrequencies)
            : [];
          const totalUnique = this.analysisResults && typeof this.analysisResults.totalUniqueSurnames === 'number'
            ? this.analysisResults.totalUniqueSurnames
            : 0;
          const topFrequencies = frequencies
            .sort((a, b) => b[1] - a[1])
            .slice(0, 10);

          let html = '<div class="empty-message-content">';
          html += `<p>${message || 'No variant groups found. All creator names appear to be consistent.'}</p>`;

          if (totalUnique) {
            html += `<p><strong>Total unique surnames scanned:</strong> ${totalUnique}</p>`;
          }

          if (topFrequencies.length > 0) {
            html += '<p><strong>Top surnames by frequency:</strong></p>';
            html += '<ul class="surname-frequency-list">';
            topFrequencies.forEach(([name, count]) => {
              html += `<li><span class="surname">${this.formatSurnameKey(name)}</span> <span class="frequency">(${count})</span></li>`;
            });
            html += '</ul>';
          }

          html += '</div>';
          emptyMsg.innerHTML = html;
          emptyMsg.style.display = 'block';
        }
      },

      updateSummaryHeader: function() {
        if (!this.analysisResults) return;

        ZoteroNER_HTMLUtils.setHidden('summary-group', false);
        ZoteroNER_HTMLUtils.setText('summary-total-creators', this.analysisResults.totalUniqueSurnames || '0');
        ZoteroNER_HTMLUtils.setText('summary-variant-groups', this.analysisResults.totalVariantGroups || '0');
        ZoteroNER_HTMLUtils.setText('summary-pending-normalizations', this.analysisResults.suggestions ? this.analysisResults.suggestions.length : '0');
      },

      resetSelections: function() {
        this.userSelections = new Map();
        if (!this.analysisResults || !Array.isArray(this.analysisResults.suggestions)) {
          return;
        }

        this.analysisResults.suggestions.forEach((suggestion, index) => {
          this.ensureUserSelection(index, suggestion);
        });
      },

      ensureUserSelection: function(index, suggestion) {
        if (!this.userSelections) {
          this.userSelections = new Map();
        }

        if (!this.userSelections.has(index)) {
          // Default to NOT applying - user must explicitly select a normalization
          // This prevents accidental bulk changes to the library
          const defaultValue = this.getDefaultNormalizationValue(suggestion);
          this.userSelections.set(index, {
            mode: 'primary',
            value: defaultValue,
            variantIndex: null,
            customValue: defaultValue,
            apply: false  // Changed from true to require explicit opt-in
          });
        }

        return this.userSelections.get(index);
      },

      updateSelection: function(index, suggestion, updates) {
        const current = this.ensureUserSelection(index, suggestion);
        const next = Object.assign({}, current, updates || {});

        if (updates && Object.prototype.hasOwnProperty.call(updates, 'mode')) {
          if (updates.mode === 'keep') {
            next.apply = false;
            next.variantIndex = null;
          } else {
            next.apply = true;
            if (updates.mode !== 'variant') {
              next.variantIndex = null;
            }
          }
        }

        if (updates && Object.prototype.hasOwnProperty.call(updates, 'variantIndex') && next.mode !== 'variant') {
          next.variantIndex = updates.variantIndex;
        }

        if (updates && Object.prototype.hasOwnProperty.call(updates, 'customValue')) {
          next.customValue = updates.customValue;
          if (next.mode === 'custom' && !Object.prototype.hasOwnProperty.call(updates, 'value')) {
            next.value = updates.customValue;
          }
        }

        if (updates && Object.prototype.hasOwnProperty.call(updates, 'value')) {
          next.value = updates.value;
        }

        this.userSelections.set(index, next);
        this.refreshApplyButtonState();
        return next;
      },

      refreshApplyButtonState: function() {
        this.setApplyEnabled(this.hasSelectedNormalizations());
      },

      hasSelectedNormalizations: function() {
        if (!this.analysisResults || !Array.isArray(this.analysisResults.suggestions) || this.analysisResults.suggestions.length === 0) {
          return false;
        }

        if (!this.userSelections || this.userSelections.size === 0) {
          return true;
        }

        for (let i = 0; i < this.analysisResults.suggestions.length; i++) {
          const selection = this.userSelections.get(i);
          if (!selection || selection.apply !== false) {
            return true;
          }
        }

        return false;
      },

      // Per-card apply: apply a single suggestion and remove its card from the UI
      applyCard: async function(index, suggestion) {
        this.log('applyCard called: index=' + index + ', suggestion.type=' + (suggestion ? suggestion.type : 'null'));
        const selection = this.ensureUserSelection(index, suggestion);
        if (!selection) {
          this.log('applyCard: no selection found, returning false');
          return false;
        }

        this.log('applyCard: selection.mode=' + selection.mode + ', apply=' + selection.apply + ', value=' + selection.value + ', customValue=' + selection.customValue);

        // Check if there's a valid selection to apply
        const normalizedValue = (selection.value || selection.customValue || '').trim();
        this.log('applyCard: normalizedValue="' + normalizedValue + '"');

        // For per-card Apply button: if no explicit apply flag but we have a normalized value, allow it
        // This allows the button to work even if user hasn't explicitly selected a radio option yet
        if (!normalizedValue) {
          this.log('applyCard: early return - no normalized value');
          return false;
        }

        if (selection.apply === false && selection.mode !== 'primary') {
          this.log('applyCard: early return - apply=false and not in primary mode');
          return false;
        }

        // Prepare this specific suggestion for application
        const preparedSuggestion = Object.assign({}, suggestion);
        preparedSuggestion.originalPrimary = suggestion.primary;
        preparedSuggestion.userSelection = Object.assign({}, selection);
        preparedSuggestion.variants = (suggestion.variants || []).map(variant => {
          const variantClone = Object.assign({}, variant);
          if (Array.isArray(variantClone.items)) {
            variantClone.items = variantClone.items.map(item => Object.assign({}, item));
          }
          return variantClone;
        });

        // Update the primary value with the selected normalization
        preparedSuggestion.primary = normalizedValue;

        if (selection.mode === 'variant' && typeof selection.variantIndex === 'number') {
          preparedSuggestion.selectedVariant = preparedSuggestion.variants[selection.variantIndex] || null;
        }

        if (selection.mode === 'custom') {
          preparedSuggestion.customNormalization = normalizedValue;
        }

        // Mark as applied
        selection.applied = true;
        this.log('applyCard: marked as applied, looking for card');

        // Apply the normalization to the database
        try {
          // Try to use the main window's Zotero API which has proper Zotero context
          let results;
          const zotero = ZoteroNER_ZoteroAPI.getZotero();
          this.log('applyCard: zotero available=' + (zotero ? 'yes' : 'no'));
          
          const nameNormalizer = ZoteroNER_ZoteroAPI.getNameNormalizer();
          this.log('applyCard: nameNormalizer available=' + (nameNormalizer ? 'yes' : 'no'));
          this.log('applyCard: nameNormalizer.applyNormalizationSuggestions=' + (nameNormalizer && typeof nameNormalizer.applyNormalizationSuggestions));

          if (nameNormalizer && typeof nameNormalizer.applyNormalizationSuggestions === 'function') {
            this.log('applyCard: calling applyNormalizationSuggestions with 1 suggestion');
            results = await nameNormalizer.applyNormalizationSuggestions(
              [preparedSuggestion],  // Apply only this one suggestion
              false,
              {
                declinedSuggestions: [],
                progressCallback: (event) => this.handleApplyProgress(event)
              }
            );

            this.log('applyCard: normalization applied successfully, results:', results);
          } else {
            this.log('applyCard: ERROR - nameNormalizer not available or missing method');
            throw new Error('Zotero NameNormalizer API not available');
          }
        } catch (error) {
          this.log('applyCard: EXCEPTION caught: ' + error.message);
          console.error('Error applying normalization in applyCard:', error);
          this.alert('Error', 'Failed to apply normalization: ' + error.message);
          return false;
        }

        // Find and remove the card
        const card = document.querySelector(`.variant-group[data-suggestion-index="${index}"]`);
        this.log('applyCard: card found=' + (card ? 'yes' : 'no'));

        if (card) {
          this.log('applyCard: removing card with animation');
          card.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
          card.style.opacity = '0';
          card.style.transform = 'translateX(-20px)';
          setTimeout(() => {
            this.log('applyCard: timeout fired, removing card DOM element');
            card.remove();
            this.checkAllCardsApplied();
          }, 300);
        }

        return true;
      },

      // Mark card as "not variants" (distinct authors) and remove from UI
      markNotVariants: function(index, suggestion) {
        const selection = this.ensureUserSelection(index, suggestion);
        if (!selection) {
          return false;
        }

        // Mark as declined (not variants)
        selection.apply = false;
        selection.notVariants = true;

        // Store user preference to never propose this normalization again
        this.storeNotVariantsPreference(suggestion);

        // Find and remove the card with animation
        const card = document.querySelector(`.variant-group[data-suggestion-index="${index}"]`);
        if (card) {
          card.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
          card.style.opacity = '0';
          card.style.transform = 'translateX(-20px)';
          setTimeout(() => {
            card.remove();
            this.checkAllCardsApplied();
          }, 300);
        }

        return true;
      },

      // Store user preference for "not variants" (distinct authors)
      storeNotVariantsPreference: function(suggestion) {
        // Create a unique key for this suggestion based on its characteristics
        const key = this.getNotVariantsKey(suggestion);

        // Get existing preferences
        const existingPrefs = this.getNotVariantsPreferences();
        if (!existingPrefs.includes(key)) {
          existingPrefs.push(key);
          this.saveNotVariantsPreferences(existingPrefs);
        }

        this.log('Stored "not variants" preference for: ' + key);
      },

      // Generate a unique key for identifying this suggestion
      // Sanitize values to prevent special characters from breaking the key format
      getNotVariantsKey: function(suggestion) {
        const sanitize = function(value) {
          return (value || '').replace(/[:\\/\n\r\t]/g, '_').substring(0, 100);
        };
        if (suggestion.type === 'given-name') {
          return `given-name:${sanitize(suggestion.surname)}:${sanitize(suggestion.primary)}`;
        }
        return `surname:${sanitize(suggestion.primary)}`;
      },

      // Get stored "not variants" preferences
      getNotVariantsPreferences: function() {
        try {
          const prefs = window.localStorage.getItem('zotero-ner-not-variants');
          return prefs ? JSON.parse(prefs) : [];
        } catch (e) {
          return [];
        }
      },

      // Save "not variants" preferences
      saveNotVariantsPreferences: function(prefs) {
        try {
          const json = JSON.stringify(prefs);
          window.localStorage.setItem('zotero-ner-not-variants', json);
        } catch (e) {
          this.log('Failed to save not-variants preferences: ' + e.message);
          // localStorage may fail in private browsing or when quota exceeded
          // The preference won't persist, but the UI interaction still works
        }
      },

      // Check if all cards have been applied/declined
      checkAllCardsApplied: function() {
        const remainingCards = document.querySelectorAll('.variant-group');
        if (remainingCards.length === 0) {
          // All cards have been handled - update empty message
          const emptyMsg = ZoteroNER_HTMLUtils.getElement('empty-message');
          if (emptyMsg) {
            const content = document.createElement('div');
            content.className = 'empty-message-content';
            const p = document.createElement('p');
            p.textContent = 'All variant groups have been processed. You can close this dialog.';
            content.appendChild(p);
            emptyMsg.innerHTML = '';
            emptyMsg.appendChild(content);
            emptyMsg.style.display = 'block';
          }
          // Disable the main apply buttons since there are no more cards
          this.setApplyEnabled(false);
        }
      },

      // Build the per-card action buttons (Apply and Not Variants)
      buildCardActions: function(index, suggestion) {
        this.log('buildCardActions: creating buttons for index=' + index);
        const container = ZoteroNER_HTMLUtils.createElement('div', { class: 'card-actions' });

        // Apply button
        const applyBtn = ZoteroNER_HTMLUtils.createElement('button', {
          type: 'button',
          class: 'apply-btn',
          'data-suggestion-index': String(index)
        });
        applyBtn.textContent = 'Apply';

        // Not Variants button (Distinct Authors)
        const notVariantsBtn = ZoteroNER_HTMLUtils.createElement('button', {
          type: 'button',
          class: 'not-variants-btn',
          'data-suggestion-index': String(index),
          title: 'Mark these as distinct authors - this will not be proposed again'
        });
        notVariantsBtn.textContent = 'Not Variants';

        // Add click handlers
        applyBtn.addEventListener('click', async (event) => {
          this.log('Apply button clicked for index=' + index);
          // Prevent multiple clicks during processing
          applyBtn.disabled = true;
          applyBtn.textContent = 'Applying...';

          try {
            // Ensure the selection is marked as apply=true before applying
            const currentSelection = this.ensureUserSelection(index, suggestion);
            if (currentSelection) {
              currentSelection.apply = true;
            }
            await this.applyCard(index, suggestion);
          } finally {
            // Re-enable button after processing
            applyBtn.disabled = false;
            applyBtn.textContent = 'Apply';
          }
        });

        notVariantsBtn.addEventListener('click', (event) => {
          this.markNotVariants(index, suggestion);
        });

        container.appendChild(applyBtn);
        container.appendChild(notVariantsBtn);

        return container;
      },

      getDefaultNormalizationValue: function(suggestion) {
        if (!suggestion) {
          return '';
        }

        if (suggestion.type === 'given-name') {
          if (suggestion.recommendedFullName) {
            return suggestion.recommendedFullName;
          }
        }

        if (typeof suggestion.primary === 'string') {
          // For surname suggestions, return a title-cased display value
          return suggestion.type === 'surname'
            ? this.formatSurnameKey(suggestion.primary.trim())
            : suggestion.primary.trim();
        }

        return this.formatNameString(suggestion.primary);
      },

      titleCase: function(value) {
        if (!value || typeof value !== 'string') {
          return '';
        }

        const cleaned = value.normalize('NFC').replace(/[\u200B-\u200D\uFEFF]/g, '');
        return cleaned
          .split(/\s+/)
          .filter(Boolean)
          .map(part => part.toLowerCase().replace(/(^|['`-])(\p{L})/gu, (match, prefix, letter) => prefix + letter.toUpperCase()))
          .join(' ');
      },

      getGroupTitle: function(index, suggestion) {
        const groupNumber = index + 1;
        if (suggestion.type === 'given-name') {
          const surname = this.titleCase(suggestion.surname || suggestion.primary || '');
          const safeSurname = this.escapeHTML(surname);
          return surname
            ? `Given name variants <span class="surname-variant">${safeSurname}</span>`
            : `Given name variants Group ${groupNumber}`;
        }

        const surname = this.titleCase(suggestion.primary || '');
        const safeSurname = this.escapeHTML(surname);
        return surname
          ? `Surname variants <span class="surname-variant">${safeSurname}</span>`
          : `Variant Group ${groupNumber}`;
      },

      buildRecommendedHTML: function(suggestion, recommendedValue) {
        const rawValue = recommendedValue || '';
        const safeValue = this.escapeHTML(rawValue);
        if (suggestion.type === 'given-name') {
          return 'Recommended full name: <strong>' + safeValue + '</strong>';
        }
        // For surname recommendations, display a title-cased, escaped version
        const display = this.formatSurnameKey(rawValue);
        return 'Recommended normalization: <strong>' + display + '</strong>';
      },

      getVariantSummaryText: function(suggestion) {
        const variantCount = Array.isArray(suggestion.variants) ? suggestion.variants.length : 0;

        if (suggestion.type === 'given-name') {
          const total = suggestion.totalFrequency || 0;
          return `${variantCount} given-name variants Â· ${total} occurrences`;
        }

        const totalOccurrences = (suggestion.variants || []).reduce((sum, variant) => sum + (variant.frequency || 0), 0);
        return `${variantCount} surname spellings Â· ${totalOccurrences} occurrences`;
      },

      getVariantDisplayLabel: function(suggestion, variant) {
        if (!variant) {
          return '';
        }

        const frequency = typeof variant.frequency === 'number' ? ` (${variant.frequency})` : '';

        if (suggestion.type === 'given-name') {
          const name = variant.firstName || variant.name || '';
          return `${this.titleCase(name)}${frequency}`;
        }

        // Preserve original casing of the variant name - don't title-case it
        const surnameDisplay = typeof variant.name === 'string'
          ? variant.name
          : this.formatNameString(variant.name);
        return `${surnameDisplay}${frequency}`;
      },

      getVariantSelectionLabel: function(suggestion, variant) {
        if (!variant) {
          return '';
        }

        const occurrences = typeof variant.frequency === 'number' ? `${variant.frequency} occurrences` : 'variant';

        if (suggestion.type === 'given-name') {
          return `Normalize to ${this.titleCase(variant.firstName || variant.name || '')} (${occurrences})`;
        }

        // Preserve original casing for surname variants
        const variantSurname = typeof variant.name === 'string'
          ? variant.name
          : this.formatNameString(variant.name);
        return `Normalize to ${variantSurname} (${occurrences})`;
      },

      buildVariantListElement: function(index, suggestion) {
        const wrapper = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-list' });
        const recommendedValue = (this.getDefaultNormalizationValue(suggestion) || '').trim().toLowerCase();

        (suggestion.variants || []).forEach((variant, variantIndex) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'variant-pill';
          button.dataset.suggestionIndex = String(index);
          button.dataset.variantIndex = String(variantIndex);
          button.textContent = this.getVariantDisplayLabel(suggestion, variant);
          const variantValue = (typeof variant.name === 'string' && variant.name)
            ? variant.name.trim().toLowerCase()
            : (variant.firstName ? `${variant.firstName} ${variant.lastName || suggestion.primary || ''}`.trim().toLowerCase() : '');
          if (recommendedValue && variantValue && variantValue === recommendedValue) {
            button.classList.add('recommended');
          }
          button.addEventListener('click', () => {
            this.showVariantDetails(index, variantIndex, suggestion, { suppressHighlight: false });
          });
          wrapper.appendChild(button);
        });

        return wrapper;
      },

      findRecommendedVariantIndex: function(suggestion) {
        if (!suggestion || !Array.isArray(suggestion.variants) || suggestion.variants.length === 0) {
          return null;
        }

        const recommendedValue = (this.getDefaultNormalizationValue(suggestion) || '').trim().toLowerCase();
        if (!recommendedValue) {
          return null;
        }

        for (let i = 0; i < suggestion.variants.length; i++) {
          const variant = suggestion.variants[i];
          const variantValue = (typeof variant.name === 'string' && variant.name)
            ? variant.name.trim().toLowerCase()
            : (variant.firstName ? `${variant.firstName} ${variant.lastName || suggestion.primary || ''}`.trim().toLowerCase() : '');

          if (variantValue && variantValue === recommendedValue) {
            return i;
          }
        }

        return null;
      },

      highlightVariantPills: function(suggestionIndex, variantIndex) {
        const pills = document.querySelectorAll('.variant-pill[data-suggestion-index]');
        pills.forEach(pill => {
          const matches = pill.dataset.suggestionIndex === String(suggestionIndex) && pill.dataset.variantIndex === String(variantIndex);
          pill.classList.toggle('active', matches);
        });
      },

      getVariantDetailTitle: function(suggestion, variant) {
        const label = this.getVariantDisplayLabel(suggestion, variant).replace(/\s+\([^)]*\)$/, '');
        const safeLabel = this.escapeHTML(label);
        if (suggestion.type === 'given-name') {
          return `Occurrences for ${safeLabel}`;
        }
        return `Occurrences for <span class="surname-variant">${safeLabel}</span>`;
      },

      showVariantDetails: function(suggestionIndex, variantIndex, suggestion, options = {}) {
        const variant = suggestion.variants[variantIndex];
        const items = Array.isArray(variant?.items) ? variant.items : [];

        if (!suggestion || !Array.isArray(suggestion.variants)) {
          this.clearVariantDetails();
          return;
        }

        if (!variant) {
          this.clearVariantDetails();
          return;
        }

        this.variantDetailState = { suggestionIndex, variantIndex };

        if (!options.suppressHighlight) {
          this.highlightVariantPills(suggestionIndex, variantIndex);
        }

        const panel = ZoteroNER_HTMLUtils.getElement('variant-detail-panel');
        if (!panel) {
          return;
        }

        // Remove placeholder classes so the detail view replaces the empty message
        panel.classList.remove('empty');
        panel.classList.remove('hidden');
        panel.style.display = 'block';

        // Scroll the column so the selected variant group aligns with the detail panel
        const groupContainer = ZoteroNER_HTMLUtils.getElement('variant-groups-container');
        const variantGroup = groupContainer?.querySelector(`[data-suggestion-index="${suggestionIndex}"]`);
        const scrollContainer = ZoteroNER_HTMLUtils.getElement('variant-groups-column');
        if (variantGroup && scrollContainer) {
          variantGroup.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        const titleEl = ZoteroNER_HTMLUtils.getElement('variant-detail-title');
        if (titleEl) {
          titleEl.innerHTML = this.getVariantDetailTitle(suggestion, variant);
        }

        const contextEl = ZoteroNER_HTMLUtils.getElement('variant-detail-context');
        if (contextEl) {
          const pieces = [];
          const freq = typeof variant.frequency === 'number' ? variant.frequency : 0;
          pieces.push(`Occurrences: ${freq}`);
          if (suggestion.type === 'given-name') {
            pieces.push(`Surname: ${this.titleCase(suggestion.surname || suggestion.primary || '')}`);
          }
          contextEl.textContent = pieces.join(' Â· ');
        }

        const listEl = ZoteroNER_HTMLUtils.getElement('variant-detail-items');
        if (listEl) {
          listEl.innerHTML = '';
          const items = Array.isArray(variant.items) ? variant.items : [];

          if (items.length === 0) {
            const emptyLi = document.createElement('li');
            emptyLi.className = 'variant-meta';
            emptyLi.textContent = 'No items found for this variant.';
            listEl.appendChild(emptyLi);
          } else {
            items.forEach(item => {
              const li = document.createElement('li');
              const html = this.formatItemSummaryHTML(item);
              li.innerHTML = html;
              listEl.appendChild(li);
            });

            if ((variant.frequency || 0) > items.length) {
              const moreLi = document.createElement('li');
              moreLi.className = 'variant-meta';
              moreLi.textContent = `â€¦and ${(variant.frequency || 0) - items.length} more entries`;
              listEl.appendChild(moreLi);
            }
          }
        }
      },

      clearVariantDetails: function() {
        this.variantDetailState = null;
        const panel = ZoteroNER_HTMLUtils.getElement('variant-detail-panel');
        if (panel) {
          panel.style.display = 'none';
          panel.classList.add('empty');
          panel.classList.add('hidden');
        }

        const contextEl = ZoteroNER_HTMLUtils.getElement('variant-detail-context');
        if (contextEl) {
          contextEl.textContent = '';
        }

        const listEl = ZoteroNER_HTMLUtils.getElement('variant-detail-items');
        if (listEl) {
          listEl.innerHTML = '';
        }

        const pills = document.querySelectorAll('.variant-pill');
        pills.forEach(pill => pill.classList.remove('active'));
      },

      formatItemSummary: function(item) {
        if (!item) {
          return 'Untitled item';
        }

        const title = item.title || 'Untitled';
        const year = item.year || item.date || '';
        const author = item.author || '';

        // Build display: Author - Title (Year) or Title (Year) if no author
        const yearStr = year ? ` (${year})` : '';
        const authorStr = author ? `${author} â€” ` : '';

        // Truncate title if too long
        const maxTitleLength = 100;
        const trimmedTitle = title.length > maxTitleLength ? title.slice(0, maxTitleLength) + 'â€¦' : title;

        return authorStr + trimmedTitle + yearStr;
      },

      formatItemSummaryHTML: function(item) {
        if (!item) {
          return '<span class="item-title">Untitled item</span>';
        }

        const title = item.title || 'Untitled';
        const year = item.year || item.date || '';
        const author = item.author || '';
        const itemKey = item.key || '';

        // Truncate title if too long
        const maxTitleLength = 100;
        const trimmedTitle = title.length > maxTitleLength ? title.slice(0, maxTitleLength) + 'â€¦' : title;

        // Escape HTML for safe rendering
        const safeTitle = this.escapeHTML(trimmedTitle);
        const safeAuthor = this.escapeHTML(author);
        const safeYear = this.escapeHTML(year);

        let html = '<div class="item-details">';

        if (safeAuthor) {
          html += `<span class="item-author">${safeAuthor}</span>`;
        }

        // Make title clickable with zotero://select/ URL
        if (itemKey) {
          html += `<a href="#" class="item-link" data-item-key="${this.escapeHTML(itemKey)}">${safeTitle}</a>`;
        } else {
          html += `<span class="item-title">${safeTitle}</span>`;
        }

        if (safeYear) {
          html += `<span class="item-year">(${safeYear})</span>`;
        }

        html += '</div>';
        return html;
      },

      buildSelectionControls: function(index, suggestion) {
        const choiceGroup = ZoteroNER_HTMLUtils.createElement('div', { class: 'radio-group', id: 'ner-variant-group-choice-' + index });
        const selection = this.ensureUserSelection(index, suggestion);
        const recommendedValue = this.getDefaultNormalizationValue(suggestion);
        const recommendedLabelText = suggestion.type === 'given-name'
          ? (recommendedValue ? `Use recommended full name: ${recommendedValue}` : 'Use recommended full name')
          : (recommendedValue ? `Use recommended normalization: ${recommendedValue}` : 'Use recommended normalization');

        const primaryRow = this.createSelectionRadioRow(index, suggestion, {
          mode: 'primary',
          label: recommendedLabelText,
          checked: selection.mode === 'primary',
          selectionUpdate: () => ({ mode: 'primary', value: recommendedValue, apply: true })
        });
        choiceGroup.appendChild(primaryRow);

        const keepRow = this.createSelectionRadioRow(index, suggestion, {
          mode: 'keep',
          label: 'Keep existing forms as-is',
          checked: selection.mode === 'keep',
          selectionUpdate: () => ({ mode: 'keep', apply: false })
        });
        choiceGroup.appendChild(keepRow);

        (suggestion.variants || []).forEach((variant, variantIndex) => {
          const label = this.getVariantSelectionLabel(suggestion, variant);
          const variantRow = this.createSelectionRadioRow(index, suggestion, {
            mode: 'variant',
            label,
            checked: selection.mode === 'variant' && selection.variantIndex === variantIndex,
            onSelect: () => {
              this.showVariantDetails(index, variantIndex, suggestion);
            },
            selectionUpdate: () => {
              const variantValue = (typeof variant.name === 'string' && variant.name)
                ? variant.name.trim()
                : (variant.firstName ? `${variant.firstName} ${variant.lastName || suggestion.primary || ''}`.trim() : '');
              return {
                mode: 'variant',
                variantIndex,
                value: variantValue,
                apply: true
              };
            }
          });
          choiceGroup.appendChild(variantRow);
        });

        const customRow = this.createCustomSelectionRow(index, suggestion, selection, recommendedValue);
        choiceGroup.appendChild(customRow);

        return choiceGroup;
      },

      createSelectionRadioRow: function(index, suggestion, option) {
        const row = ZoteroNER_HTMLUtils.createElement('div');
        const radioId = `choice-${index}-${option.mode}-${Math.random().toString(16).slice(2, 7)}`;
        const radio = ZoteroNER_HTMLUtils.createElement('input', {
          type: 'radio',
          id: radioId,
          name: `choice-${index}`,
          value: option.mode
        });
        if (option.checked) {
          radio.checked = true;
        }

        radio.addEventListener('change', () => {
          if (typeof option.onSelect === 'function') {
            option.onSelect();
          }
          const update = typeof option.selectionUpdate === 'function'
            ? option.selectionUpdate()
            : { mode: option.mode };
          this.updateSelection(index, suggestion, update);
        });

        const label = ZoteroNER_HTMLUtils.createElement('label', { for: radioId });
        label.textContent = option.label;

        row.appendChild(radio);
        row.appendChild(label);
        return row;
      },

      createCustomSelectionRow: function(index, suggestion, selection, defaultValue) {
        const container = ZoteroNER_HTMLUtils.createElement('div', { class: 'custom-normalization' });
        const radioId = `choice-${index}-custom`;
        const radio = ZoteroNER_HTMLUtils.createElement('input', {
          type: 'radio',
          id: radioId,
          name: `choice-${index}`,
          value: 'custom'
        });
        radio.checked = selection.mode === 'custom';

        const label = ZoteroNER_HTMLUtils.createElement('label', { for: radioId });
        label.textContent = 'Use a custom normalization:';

        const input = document.createElement('input');
        input.type = 'text';
        input.value = selection.customValue || defaultValue || '';
        input.disabled = selection.mode !== 'custom';
        input.placeholder = defaultValue || 'Enter normalized name';

        radio.addEventListener('change', () => {
          input.disabled = !radio.checked;
          if (radio.checked) {
            this.updateSelection(index, suggestion, {
              mode: 'custom',
              value: input.value,
              customValue: input.value,
              variantIndex: null,
              apply: true
            });
          }
        });

        input.addEventListener('input', (event) => {
          const value = event.target.value;
          const current = this.ensureUserSelection(index, suggestion);
          const updates = { customValue: value };
          if (current.mode === 'custom') {
            updates.value = value;
          }
          this.updateSelection(index, suggestion, updates);
        });

        input.addEventListener('focus', () => {
          if (!radio.checked) {
            radio.checked = true;
            radio.dispatchEvent(new Event('change'));
          }
        });

        container.appendChild(radio);
        container.appendChild(label);
        container.appendChild(input);

        return container;
      },

      buildRelatedGivenNamesSection: function(suggestion) {
        const wrapper = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-meta' });
        const variants = suggestion.relatedGivenNameVariants || [];
        if (!variants.length) {
          return wrapper;
        }

        const intro = document.createElement('div');
        intro.textContent = 'Associated given name variants:';
        wrapper.appendChild(intro);

        const list = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-list' });
        variants.forEach(variant => {
          const pill = document.createElement('span');
          pill.className = 'variant-pill';
          pill.textContent = `${this.titleCase(variant.firstName || '')} (${variant.frequency || 0})`;
          list.appendChild(pill);
        });

        wrapper.appendChild(list);
        return wrapper;
      },

      populateVariantGroupList: function() {
        const container = ZoteroNER_HTMLUtils.getElement('variant-groups-container');
        if (!container) {
          return false;
        }

        container.innerHTML = '';

        const suggestions = (this.analysisResults && Array.isArray(this.analysisResults.suggestions))
          ? this.analysisResults.suggestions
          : [];
        const totalSuggestions = suggestions.length;

        if (totalSuggestions === 0) {
          this.showEmptyState('No variant groups were detected for the scanned surnames.');
          return false;
        }

        const emptyMsg = ZoteroNER_HTMLUtils.getElement('empty-message');
        if (emptyMsg) {
          emptyMsg.style.display = 'none';
        }

        const renderedIndexes = [];
        let visibleCount = 0;

        suggestions.forEach((suggestion, index) => {
          if (!suggestion) {
            return;
          }
          if (!this.matchesFilter(suggestion)) {
            return;
          }

          this.log('populateVariantGroupList: rendering card for index=' + index + ', type=' + suggestion.type);
          visibleCount++;
          renderedIndexes.push(index);
          this.ensureUserSelection(index, suggestion);
          const groupElement = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-group', 'data-suggestion-index': String(index) });

          const header = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-group-header' });
          const title = ZoteroNER_HTMLUtils.createElement('h3');
          title.innerHTML = this.getGroupTitle(index, suggestion);
          header.appendChild(title);

          const summary = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-group-summary' });
          summary.textContent = this.getVariantSummaryText(suggestion);
          header.appendChild(summary);

          const recommendedValue = this.getDefaultNormalizationValue(suggestion);
          if (recommendedValue) {
            const recommended = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-meta' });
            recommended.innerHTML = this.buildRecommendedHTML(suggestion, recommendedValue);
            header.appendChild(recommended);
          }

          groupElement.appendChild(header);

          const variantsContainer = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-group-variants' });
          const variantList = this.buildVariantListElement(index, suggestion);

          if (variantList && variantList.childElementCount > 0) {
            variantsContainer.appendChild(variantList);
          } else {
            const emptyVariants = document.createElement('div');
            emptyVariants.className = 'variant-meta';
            emptyVariants.textContent = 'No variants detected.';
            variantsContainer.appendChild(emptyVariants);
          }

          const controls = this.buildSelectionControls(index, suggestion);
          variantsContainer.appendChild(controls);

          if (suggestion.type === 'given-name') {
            const relatedSection = this.buildRelatedGivenNamesSection(suggestion);
            if (relatedSection && relatedSection.childNodes.length) {
              variantsContainer.appendChild(relatedSection);
            }
          }

          // Add per-card action buttons
          const cardActions = this.buildCardActions(index, suggestion);
          variantsContainer.appendChild(cardActions);

          groupElement.appendChild(variantsContainer);
          container.appendChild(groupElement);
        });

        this.updateFilterSummary(visibleCount, totalSuggestions);

        if (visibleCount === 0) {
          const noMatches = document.createElement('div');
          noMatches.className = 'empty-message';
          noMatches.textContent = this.filterText
            ? 'No variant groups match your filter. Adjust your search to see results.'
            : 'No variant groups were detected for the scanned surnames.';
          container.appendChild(noMatches);
          this.clearVariantDetails();
          this.refreshApplyButtonState();
          return false;
        }

        const { variantDetailState } = this;
        let detailSuggestionIndex = null;
        let detailVariantIndex = null;

        if (variantDetailState && renderedIndexes.includes(variantDetailState.suggestionIndex)) {
          detailSuggestionIndex = variantDetailState.suggestionIndex;
          detailVariantIndex = typeof variantDetailState.variantIndex === 'number'
            ? variantDetailState.variantIndex
            : null;
        } else {
          this.variantDetailState = null;
          detailSuggestionIndex = renderedIndexes[0];
        }

        const detailSuggestion = suggestions[detailSuggestionIndex];
        if (detailSuggestion && Array.isArray(detailSuggestion.variants) && detailSuggestion.variants.length > 0) {
          let variantIndexToShow = null;
          if (detailVariantIndex !== null && detailSuggestion.variants[detailVariantIndex]) {
            variantIndexToShow = detailVariantIndex;
          } else {
            const defaultVariantIndex = this.findRecommendedVariantIndex(detailSuggestion);
            variantIndexToShow = defaultVariantIndex !== null ? defaultVariantIndex : 0;
          }
          this.showVariantDetails(detailSuggestionIndex, variantIndexToShow, detailSuggestion);
        } else {
          this.clearVariantDetails();
        }

        this.refreshApplyButtonState();
        return true;
      },

      formatNameString: function(name) {
        if (typeof name === 'string') return name.trim();
        if (name && typeof name === 'object') {
          return `${name.firstName || ''} ${name.lastName || ''}`.trim();
        }
        return '';
      },

      escapeHTML: function(value) {
        if (typeof value !== 'string') {
          return '';
        }
        const map = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;'
        };
        return value.replace(/[&<>"']/g, (char) => map[char]);
      },

      formatSurnameKey: function(value) {
        if (!value || typeof value !== 'string') {
          return '';
        }
        const titleCased = this.titleCase(value);
        return this.escapeHTML(titleCased);
      },

      setApplyEnabled: function(enabled) {
        const applyButton = ZoteroNER_HTMLUtils.getElement('apply-button');
        const applyAllButton = ZoteroNER_HTMLUtils.getElement('apply-all-button');
        if (applyButton) applyButton.disabled = !enabled || this.isProcessing;
        if (applyAllButton) applyAllButton.disabled = !enabled || this.isProcessing;
      },

      setDialogBusy: function(isBusy) {
        this.isProcessing = isBusy;
        ZoteroNER_HTMLUtils.setHidden('progress-container', !isBusy);

        const applyButton = ZoteroNER_HTMLUtils.getElement('apply-button');
        const applyAllButton = ZoteroNER_HTMLUtils.getElement('apply-all-button');
        if (applyButton) applyButton.disabled = isBusy;
        if (applyAllButton) applyAllButton.disabled = isBusy;

        this.updateProgress();
      },

      handleApplyProgress: function(event) {
        if (!event) {
          return;
        }

        const nextState = Object.assign({}, this.currentProgressState || {});

        if (typeof event.stage === 'string') {
          nextState.stage = event.stage;
        }
        if (typeof event.total === 'number') {
          nextState.total = event.total;
        }
        if (typeof event.totalOperations === 'number') {
          nextState.total = event.totalOperations;
        }
        if (typeof event.totalSuggestions === 'number') {
          nextState.totalSuggestions = event.totalSuggestions;
        }
        if (typeof event.processed === 'number') {
          nextState.processed = event.processed;
        }
        if (typeof event.updatedCreators === 'number') {
          nextState.updatedCreators = event.updatedCreators;
        }
        if (typeof event.declined === 'number') {
          nextState.declined = event.declined;
        }
        if (typeof event.applied === 'number') {
          nextState.applied = event.applied;
        }
        if (typeof event.skipped === 'number') {
          nextState.skipped = event.skipped;
        }
        delete nextState.percent;
        if (typeof event.percent === 'number' && Number.isFinite(event.percent)) {
          nextState.percent = event.percent;
        }
        if (typeof event.affected === 'number') {
          nextState.affected = event.affected;
        }
        if (typeof event.matched === 'number') {
          nextState.matched = event.matched;
        }

        nextState.message = this.composeProgressMessage(event, nextState);
        this.currentProgressState = nextState;
        this.updateProgress();
      },

      composeProgressMessage: function(event, state) {
        switch (event.stage) {
          case 'prepare':
            return 'Preparing normalization updates...';
          case 'operations-planned':
            return `Preparing ${event.total || 0} database updates...`;
          case 'operation-preflight': {
            const total = event.total || state.total || 0;
            const labelTotal = total > 0 ? total : '?';
            const index = (event.processed || 0) + 1;
            if (event.operation) {
              return `Checking ${event.operation} (${index} of ${labelTotal})...`;
            }
            return 'Checking affected creators...';
          }
          case 'operation-complete': {
            const total = event.total || state.total || 0;
            const labelTotal = total > 0 ? total : '?';
            const index = event.processed || 0;
            if (event.operation) {
              return `Applied ${event.operation} (${index}/${labelTotal})`;
            }
            return 'Applied normalization update.';
          }
          case 'operations-finished':
            return `Database updates complete (${event.updatedCreators || state.updatedCreators || 0} creators touched)`;
          case 'finalizing':
            return 'Recording learning decisions...';
          case 'complete':
            if ((event.updatedCreators || state.updatedCreators || 0) > 0) {
              return `All done! Updated ${event.updatedCreators || state.updatedCreators} creators.`;
            }
            if ((event.declined || state.declined || 0) > 0) {
              return 'Saved â€œkeep existingâ€ choices. No changes applied.';
            }
            return 'Normalization finished.';
          case 'error':
            return 'An error occurred while applying normalizations.';
          default:
            return 'Applying normalizations...';
        }
      },

      updateProgress: function() {
        const progressLabel = ZoteroNER_HTMLUtils.getElement('progress-label');
        if (!progressLabel) return;

        const state = this.currentProgressState;
        if (state) {
          const total = typeof state.total === 'number'
            ? state.total
            : (typeof state.totalOperations === 'number' ? state.totalOperations : (typeof state.totalSuggestions === 'number' ? state.totalSuggestions : 0));
          const processed = typeof state.processed === 'number' ? state.processed : 0;
          let percent = Number.isFinite(state.percent) ? state.percent : null;

          if (percent === null) {
            if (total > 0) {
              percent = Math.min(100, Math.round((processed / total) * 100));
            } else if (state.stage === 'complete' || state.stage === 'operations-finished') {
              percent = 100;
            } else if (this.isProcessing) {
              percent = 50;
            } else {
              percent = 0;
            }
          }

          ZoteroNER_HTMLUtils.updateProgressBar(percent);
          ZoteroNER_HTMLUtils.updateProgressLabel(state.message || 'Applying normalizations...');
          return;
        }

        if (this.analysisResults && this.analysisResults.suggestions) {
          if (this.isProcessing) {
            ZoteroNER_HTMLUtils.updateProgressBar(50);
            ZoteroNER_HTMLUtils.updateProgressLabel('Applying normalizations...');
          } else {
            ZoteroNER_HTMLUtils.updateProgressBar(100);
            ZoteroNER_HTMLUtils.updateProgressLabel('Analysis complete: ' + this.analysisResults.suggestions.length + ' variant groups found');
          }
        } else if (this.isProcessing) {
          ZoteroNER_HTMLUtils.updateProgressBar(50);
          ZoteroNER_HTMLUtils.updateProgressLabel('Analyzing library...');
        } else {
          ZoteroNER_HTMLUtils.updateProgressBar(0);
          ZoteroNER_HTMLUtils.updateProgressLabel('Ready');
        }
      },

      applySelected: async function() {
        if (this.isProcessing || !this.analysisResults || !Array.isArray(this.analysisResults.suggestions)) {
          return;
        }

        const preparedSuggestions = [];
        const declinedSuggestions = [];

        this.analysisResults.suggestions.forEach((suggestion, index) => {
          const selection = this.ensureUserSelection(index, suggestion);
          if (!selection) {
            return;
          }

          const prepared = Object.assign({}, suggestion);
          prepared.originalPrimary = suggestion.primary;
          prepared.userSelection = Object.assign({}, selection);
          prepared.variants = (suggestion.variants || []).map(variant => {
            const variantClone = Object.assign({}, variant);
            if (Array.isArray(variantClone.items)) {
              variantClone.items = variantClone.items.map(item => Object.assign({}, item));
            }
            return variantClone;
          });

          if (selection.apply === false) {
            declinedSuggestions.push(prepared);
            return;
          }

          const normalizedValue = (selection.value || '').trim();
          if (!normalizedValue) {
            return;
          }

          prepared.primary = normalizedValue;

          if (selection.mode === 'variant' && typeof selection.variantIndex === 'number') {
            prepared.selectedVariant = prepared.variants[selection.variantIndex] || null;
          }

          if (selection.mode === 'custom') {
            prepared.customNormalization = normalizedValue;
          }

          preparedSuggestions.push(prepared);
        });

        if (preparedSuggestions.length === 0 && declinedSuggestions.length === 0) {
          this.alert('Author Name Normalizer', 'No normalization choices are selected to apply. Adjust your selections or close the dialog.');
          return;
        }

        this.currentProgressState = preparedSuggestions.length > 0
          ? { stage: 'prepare', total: preparedSuggestions.length, processed: 0, message: 'Preparing normalization updates...' }
          : { stage: 'prepare', total: declinedSuggestions.length, processed: 0, message: 'Saving â€œkeep existingâ€ choices...' };

        this.setDialogBusy(true);
        this.updateProgress();

        let applyError = null;

        try {
          // Try to use the main window's Zotero API which has proper Zotero context
          let results;
          const nameNormalizer = ZoteroNER_ZoteroAPI.getNameNormalizer();

          if (nameNormalizer) {
            results = await nameNormalizer.applyNormalizationSuggestions(
              preparedSuggestions,
              false,
              {
                declinedSuggestions,
                progressCallback: (event) => this.handleApplyProgress(event)
              }
            );
          } else if (typeof ZoteroNER !== 'undefined' && ZoteroNER.ZoteroDBAnalyzer) {
            // Fallback: instantiate in dialog context (will fail if Zotero is undefined)
            this.dbAnalyzer = new ZoteroNER.ZoteroDBAnalyzer();
            if (!this.dbAnalyzer || typeof this.dbAnalyzer.applyNormalizationSuggestions !== 'function') {
              throw new Error('Zotero database analyzer is not available in this context.');
            }
            results = await this.dbAnalyzer.applyNormalizationSuggestions(preparedSuggestions, false, {
              declinedSuggestions,
              progressCallback: (event) => this.handleApplyProgress(event)
            });
          } else {
            throw new Error('Zotero API not available. Cannot apply normalizations.');
          }

          if (results.applied === 0 && results.updatedCreators === 0 && results.declinedRecorded > 0) {
            this.alert('Author Name Normalizer', 'No normalization changes were applied. Your â€œkeep existingâ€ choices were saved for future runs.');
          } else {
            const summary = [
              'Suggestions reviewed: ' + results.totalSuggestions,
              'Applied: ' + results.applied,
              'Skipped: ' + results.skipped,
              'Creators updated: ' + (results.updatedCreators || 0)
            ];

            if (results.declinedRecorded > 0) {
              summary.push('Saved â€œkeep existingâ€ decisions: ' + results.declinedRecorded);
            }

            if (results.errors > 0) {
              summary.push('Errors: ' + results.errors);
            }

            this.alert('Author Name Normalizer', 'Normalization selections applied!\n\n' + summary.join('\n'));
          }

        } catch (error) {
          applyError = error;
          console.error(error);
          this.alert('Error', 'Failed to apply normalization selections: ' + error.message);
        } finally {
          this.setDialogBusy(false);
          this.currentProgressState = null;
          this.updateProgress();
          if (!applyError) {
            window.close();
          }
        }
      },

      applyAllSelected: async function() {
        // Count how many normalizations are selected
        let selectedCount = 0;
        for (const [index, selection] of this.userSelections) {
          if (selection.apply !== false && selection.mode !== 'keep') {
            selectedCount++;
          }
        }

        if (selectedCount === 0) {
          this.alert('Author Name Normalizer', 'No normalization choices are selected to apply. Select at least one normalization to apply.');
          return;
        }

        // Show confirmation dialog for bulk operations
        const confirmed = window.confirm(
          `You are about to apply ${selectedCount} normalization(s) to your library.\n\n` +
          `This will modify author names in ${selectedCount} item(s).\n\n` +
          `Are you sure you want to continue?`
        );

        if (!confirmed) {
          this.log('User cancelled Apply All operation');
          return;
        }

        // Proceed with applying all selected normalizations
        this.log('User confirmed Apply All for ' + selectedCount + ' normalizations');
        await this.applySelected();
      },

      startProgressTracking: function() {
        this.log('Starting progress tracking');

        // Track when analysis is complete (set by updateAnalysisResults)
        this.analysisComplete = false;

        // Track last progress update time for adaptive timeout
        this.lastProgressTime = Date.now();
        this.lastHeartbeat = Date.now();

        const ADAPTIVE_TIMEOUT_MS = 120000;        // 120 seconds max for large libraries
        const PROGRESS_UPDATE_TIMEOUT_MS = 45000;  // 45 seconds since last progress = stuck
        const HEARTBEAT_TIMEOUT_MS = 30000;        // 30 seconds without heartbeat = stalled

        const analysisStartTime = Date.now();
        const self = this;

        // Clear any existing interval
        if (this.checkAnalysisInterval) {
          clearInterval(this.checkAnalysisInterval);
          this.checkAnalysisInterval = null;
        }

        // Set up the timeout check interval
        this.checkAnalysisInterval = setInterval(() => {
          // Check if analysis completed (flag set by updateAnalysisResults)
          if (self.analysisComplete) {
            clearInterval(self.checkAnalysisInterval);
            self.checkAnalysisInterval = null;
            const suggestionCount = (self.analysisResults && self.analysisResults.suggestions) ? self.analysisResults.suggestions.length : 0;
            self.log('Analysis completed with ' + suggestionCount + ' suggestions after ' + (Date.now() - analysisStartTime) + 'ms');
          } else if (self.analysisResults && self.analysisResults.suggestions) {
            // Results arrived but analysisComplete flag not set - complete now
            clearInterval(self.checkAnalysisInterval);
            self.checkAnalysisInterval = null;
            self.log('Analysis results received (timeout check), suggestions: ' + self.analysisResults.suggestions.length);
          } else {
            // Adaptive timeout: check max time, last progress, and heartbeat
            const timeSinceStart = Date.now() - analysisStartTime;
            const timeSinceProgress = Date.now() - self.lastProgressTime;
            const timeSinceHeartbeat = Date.now() - (self.lastHeartbeat || self.lastProgressTime);

            if (timeSinceStart > ADAPTIVE_TIMEOUT_MS) {
              // Absolute timeout: analysis running too long
              clearInterval(self.checkAnalysisInterval);
              self.checkAnalysisInterval = null;
              self.log('ERROR: Analysis timeout after ' + timeSinceStart + 'ms (adaptive)');
              self.showEmptyState('Analysis timed out. The library may be too large.');
            } else if (timeSinceHeartbeat > HEARTBEAT_TIMEOUT_MS) {
              // No heartbeat - analysis may be stalled
              self.log('No heartbeat for ' + timeSinceHeartbeat + 'ms, checking status...');
              self.lastHeartbeat = Date.now();  // Reset to avoid repeated warnings
            } else if (timeSinceProgress > PROGRESS_UPDATE_TIMEOUT_MS) {
              // No progress update, but heartbeat still coming - CPU busy, not stuck
              self.log('No progress update for ' + timeSinceProgress + 'ms (CPU busy, not stuck)');
              // Don't reset lastProgressTime - we want to track actual progress
            }
          }
        }, 500);

        // Note: showLoadingState() is now called separately in initialize()
        // before startProgressTracking() to ensure progress bar appears immediately
      },

      showLoadingState: function() {
        this.log('Showing loading state');

        // Hide empty message, show progress
        ZoteroNER_HTMLUtils.setHidden('empty-message', true);
        ZoteroNER_HTMLUtils.setHidden('summary-group', true);
        ZoteroNER_HTMLUtils.setHidden('variant-section', true);
        ZoteroNER_HTMLUtils.setHidden('progress-container', false);
        ZoteroNER_HTMLUtils.updateProgressLabel('Analyzing library...');
        // Use indeterminate animation so user sees progress even if analysis is fast
        ZoteroNER_HTMLUtils.setProgressIndeterminate(true);
        this.setApplyEnabled(false);
      },
      
      handleAnalysisProgress: function(progress) {
        // Always update timestamps first
        this.lastProgressTime = Date.now();
        this.lastHeartbeat = Date.now();

        this.log('handleAnalysisProgress: stage=' + (progress.stage || 'unknown') + ', percent=' + (progress.percent !== undefined ? progress.percent : 'N/A') + ', processed=' + (progress.processed || 'N/A') + ', total=' + (progress.total || 'N/A'));

        if (!progress) {
          this.log('handleAnalysisProgress: received null progress');
          return;
        }

        // Debounce rapid updates to prevent UI jank
        if (this.progressUpdateTimer) {
          clearTimeout(this.progressUpdateTimer);
        }

        this.progressUpdateTimer = setTimeout(() => {
          this.updateProgressUI(progress);
        }, 100);
      },

      receiveHeartbeat: function() {
        // Check if dialog is still open/valid
        if (!document.getElementById('progress-container')) {
          return;  // Dialog closing, ignore heartbeat
        }
        this.lastHeartbeat = Date.now();
        // Note: Do NOT update lastProgressTime - heartbeat != actual progress
      },

      updateProgressUI: function(progress) {
        // Ensure progress container is visible while updating
        if (!progress) return;

        ZoteroNER_HTMLUtils.setHidden('progress-container', false);

        let message = 'Analyzing library...';
        let percent = 0;
        let isIndeterminate = false;

        if (progress.stage === 'filtering_items') {
          message = `Loading items... (${progress.processed || 0} of ${progress.total || '?'})`;
          percent = progress.percent || 0;
        } else if (progress.stage === 'analyzing_surnames') {
          if (progress.total) {
            message = `Analyzing surnames... (${progress.processed || 0} of ${progress.total})`;
            percent = progress.percent || 0;
          } else {
            message = `Analyzing surnames... (${progress.processed || 0} comparisons)`;
            isIndeterminate = true;
          }
        } else if (progress.stage === 'generating_suggestions') {
          message = 'Generating normalization suggestions...';
          percent = 95;
        } else if (progress.stage === 'debug') {
          message = progress.message || 'Analyzing...';
          percent = progress.percent || 0;
        }

        ZoteroNER_HTMLUtils.updateProgressLabel(message);

        const fill = document.getElementById('progress-fill');
        if (fill) {
          if (isIndeterminate) {
            fill.classList.add('indeterminate');
          } else {
            fill.classList.remove('indeterminate');
            fill.style.width = Math.max(percent, 3) + '%';
          }
        }
      },
      
      updateAnalysisResults: function(analysisResults) {

        // Mark analysis as complete to prevent timeout error
        this.analysisComplete = true;
        
        // Clear the timeout interval if it's still running
        if (this.checkAnalysisInterval) {
          clearInterval(this.checkAnalysisInterval);
          this.checkAnalysisInterval = null;
        }

        // Clear any pending progress update timer
        if (this.progressUpdateTimer) {
          clearTimeout(this.progressUpdateTimer);
          this.progressUpdateTimer = null;
        }

        if (!analysisResults) {
          this.showEmptyState('Analysis completed but no results were returned.');
          ZoteroNER_HTMLUtils.setHidden('progress-container', true);
          return;
        }

        this.log('Updating dialog with analysis results');
        this.log('Results contain: ' + (analysisResults.suggestions ? analysisResults.suggestions.length : 0) + ' suggestions');

        this.analysisResults = analysisResults;
        this.resetSelections();
        this.clearVariantDetails();
        
        // Show 100% progress for a moment before hiding
        ZoteroNER_HTMLUtils.updateProgressLabel('Analysis complete!');
        ZoteroNER_HTMLUtils.updateProgressBar(100);
        
        // Hide progress container after a brief delay to show completion
        setTimeout(() => {
          ZoteroNER_HTMLUtils.setHidden('progress-container', true);
          ZoteroNER_HTMLUtils.setHidden('summary-group', false);
          ZoteroNER_HTMLUtils.setHidden('variant-section', false);
        }, 500);
        
        this.updateSummaryHeader();
        this.populateVariantGroupList();
        this.refreshApplyButtonState();
        this.updateProgress();
      }
    };

    // Event listeners
    document.getElementById('apply-button').addEventListener('click', function() {
      ZoteroNER_NormalizationDialog.applySelected();
    });

    document.getElementById('apply-all-button').addEventListener('click', function() {
      ZoteroNER_NormalizationDialog.applyAllSelected();
    });

    document.getElementById('cancel-button').addEventListener('click', function() {
      window.close();
    });

    // Expose controller globally so parent window can call it
    window.ZoteroNERController = ZoteroNER_NormalizationDialog;

    // Start
    ZoteroNER_NormalizationDialog.init();
  </script>
</body>
</html>