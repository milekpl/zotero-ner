<!DOCTYPE html>
<html>
<head>
  <title>Author Name Normalizer</title>
  <style>
    html, body {
      font-family: -moz-dialog, Arial, sans-serif;
      padding: 12px;
      margin: 0;
      background: #f9f9f9;
      color: #333;
    }
    h1 { margin-top: 0; }
    .summary {
      background: #e8f4fd;
      padding: 10px;
      margin: 8px 0;
      border: 1px solid #b3d9ff;
      border-radius: 4px;
    }
    .summary-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .variant-group {
      margin: 6px 0;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
    }
    .variant-group h3 {
      margin: 0 0 4px 0;
      font-size: 1em;
      color: #0066cc;
    }
    .variant-group h4 { margin: 0 0 10px 0; color: #0066cc; }
    .variant-group-header {
      margin-bottom: 6px;
    }
    .variant-group-summary {
      font-size: 0.8em;
      color: #666;
      margin-bottom: 2px;
    }
    .surname-variant {
      font-style: italic;
    }
    .primary {
      font-weight: bold;
      color: #0066cc;
      margin-bottom: 10px;
      padding: 5px;
      background: #f0f8ff;
      border-radius: 3px;
    }
    .variants-list {
      list-style: none;
      padding: 0;
    }
    .variant {
      margin: 5px 0;
      padding: 5px;
      background: #f9f9f9;
      border-radius: 3px;
    }
    .variant-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin: 8px 0 4px 0;
    }
    .variant-pill {
      display: inline-flex;
      align-items: center;
      padding: 4px 10px;
      border: 1px solid #c8d1dc;
      border-radius: 16px;
      background: #f7f9fc;
      font-size: 0.9em;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
    }
    .variant-pill:hover {
      border-color: #007acc;
      background: #eef5ff;
    }
    .variant-pill.active {
      background: #ffd700 !important;
      border-color: #b8860b !important;
      color: #000 !important;
      box-shadow: 0 0 0 1px #ffd700;
      font-weight: 600;
    }
    .variant-pill.recommended {
      border-color: #2563eb;
      color: #1d4ed8;
      font-weight: 600;
    }
    .frequency { 
      color: #666; 
      font-size: 0.9em; 
      font-style: italic;
    }
    .radio-group {
      margin: 6px 0;
    }
    .radio-group input[type="radio"] {
      margin-right: 5px;
    }
    .radio-group label {
      word-wrap: break-word;
      max-width: 100%;
    }
    .confidence {
      font-size: 0.9em;
      color: #007acc;
      font-weight: bold;
    }
    button { 
      margin: 10px 5px; 
      padding: 8px 16px; 
      border: 1px solid #ccc; 
      border-radius: 3px;
      background: #f0f0f0;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      background: #e0e0e0;
    }
    .custom-normalization {
      margin-top: 12px;
      padding: 10px;
      background: #f6f8fa;
      border-radius: 4px;
      border: 1px solid #d8dee4;
    }
    .custom-normalization label {
      display: block;
      font-weight: 600;
      margin-bottom: 6px;
    }
    .custom-normalization input[type="text"] {
      width: 150px;
      padding: 4px 6px;
      border: 1px solid #c9d1d9;
      border-radius: 3px;
      font-size: 0.9em;
    }
    .custom-normalization input[type="text"]:disabled {
      background: #f0f0f0;
      color: #555;
    }
    .card-actions {
      display: flex;
      gap: 6px;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #e8e8e8;
    }
    .card-actions button {
      margin: 0;
      padding: 4px 10px;
      font-size: 0.85em;
    }
    .card-actions .apply-btn {
      background: #007acc;
      color: white;
      border-color: #0066a8;
    }
    .card-actions .apply-btn:hover:not(:disabled) {
      background: #0066a8;
    }
    .card-actions .not-variants-btn {
      background: #f9f9f9;
      color: #666;
      border-color: #ccc;
    }
    .card-actions .not-variants-btn:hover:not(:disabled) {
      background: #f0f0f0;
      color: #333;
    }
    .progress { 
      margin: 10px 0; 
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .progress-bar { 
      flex: 1; 
      height: 20px; 
      background: #f0f0f0; 
      border-radius: 10px; 
      overflow: hidden;
      border: 1px solid #ccc;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #0066cc, #007acc);
      transition: width 0.3s ease;
      width: 0%;
      min-width: 3px; /* Always show at least a small amount for visual feedback */
    }
    .progress-fill.indeterminate {
      background: linear-gradient(90deg, #0066cc 0%, #007acc 50%, #0066cc 100%);
      background-size: 200% 100%;
      animation: indeterminate-progress 1.5s ease-in-out infinite;
      width: 0%;
    }
    @keyframes indeterminate-progress {
      0% { background-position: 100% 0; }
      100% { background-position: -100% 0; }
    }
    .empty-message {
      text-align: center;
      color: #666;
      font-style: italic;
      padding: 20px;
    }
    .empty-message-content {
      text-align: left;
      color: #444;
      font-style: normal;
    }
    .empty-message-content p {
      margin: 8px 0;
    }
    .surname-frequency-list {
      list-style: disc;
      padding-left: 20px;
      margin: 6px 0 0 0;
    }
    .surname-frequency-list li {
      margin: 4px 0;
    }
    .surname-frequency-list .surname {
      font-weight: 600;
      color: #222;
    }
    #progress-container { display: none; }
    #suggestions-container:empty::after {
      content: "No suggestions to display.";
      display: block;
      text-align: center;
      color: #666;
      padding: 20px;
    }
    .selected {
      background-color: #e3f2fd;
      border-color: #2196f3;
    }
    .variant-meta {
      font-size: 0.85em;
      color: #555;
      margin-top: 4px;
    }
    #variant-filter-bar {
      margin: 12px 0 18px;
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    #variant-filter-input {
      flex: 1 1 150px;
      max-width: 200px;
      padding: 4px 6px;
      border: 1px solid #c9d1d9;
      border-radius: 4px;
      font-size: 0.85em;
      background: #fff;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    #variant-filter-input:focus {
      outline: none;
      border-color: #007acc;
      box-shadow: 0 0 0 3px rgba(0, 122, 204, 0.15);
    }
    #variant-filter-summary {
      font-size: 0.9em;
      color: #4b5563;
      white-space: nowrap;
    }
    #variant-section {
      margin: 20px 0;
    }
    #variant-layout {
      display: grid;
      grid-template-columns: 1fr 260px;
      grid-template-rows: auto;
      gap: 10px;
      width: 100%;
    }
    #variant-groups-column {
      grid-column: 1;
      grid-row: 1;
      min-width: 0;
      overflow-y: auto;
      max-height: calc(100vh - 250px);
    }
    .variant-detail {
      grid-column: 2;
      grid-row: 1;
      min-width: 250px;
      width: 250px;
      padding: 8px;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      background: #fff;
      box-shadow: 0 3px 8px rgba(15, 23, 42, 0.08);
      max-height: calc(100vh - 250px);
      overflow-y: auto;
      align-self: start;
      position: sticky;
      top: 0;
    }
    .variant-detail h4 {
      margin: 0 0 4px 0;
      color: #005a9c;
      font-size: 0.95em;
    }
    .variant-detail-context {
      font-size: 0.8em;
      color: #586069;
      margin-bottom: 6px;
    }
    .variant-detail-empty {
      font-size: 0.85em;
      color: #69737d;
      padding: 8px 0;
    }
    .variant-detail.empty #variant-detail-items,
    .variant-detail.empty .variant-detail-context {
      display: none;
    }
    .variant-detail:not(.empty) .variant-detail-empty {
      display: none;
    }
    .variant-detail-items {
      list-style: none;
      padding-left: 0;
      margin: 0;
      max-height: 200px;
      overflow-y: auto;
      font-size: 0.85em;
    }
    .variant-detail-items li {
      margin: 4px 0;
      padding: 3px 5px;
      background: #fafbfc;
      border-radius: 3px;
    }
    .variant-detail-items li:hover {
      background: #f0f4f8;
    }
    .item-author {
      color: #6a737e;
      font-size: 0.9em;
      font-weight: 500;
    }
    .item-title {
      color: #24292e;
    }
    .item-link {
      color: #005a9c;
      text-decoration: none;
      cursor: pointer;
    }
    .item-link:visited {
      color: #005a9c;
    }
    .item-link:hover {
      text-decoration: underline;
    }
    .item-year {
      color: #6a737e;
      font-size: 0.9em;
    }
    .item-details {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: baseline;
    }
    .item-details .item-author {
      flex: 0 0 auto;
    }
    .item-details .item-link {
      flex: 1 1 auto;
      min-width: 150px;
      color: #005a9c;
      text-decoration: none;
    }
    .item-details .item-link:hover {
      text-decoration: underline;
    }
    .item-details .item-year {
      flex: 0 0 auto;
    }
    @media (max-width: 960px) {
      #variant-layout {
        grid-template-columns: 1fr;
      }
      .variant-detail {
        position: static;
        max-height: none;
      }
    }
    /* Field normalization section */
    #field-normalization-section {
      display: none;
      padding: 10px;
    }
    #field-normalization-section h2 {
      margin-top: 0;
      margin-bottom: 10px;
    }
    #field-filter-bar {
      margin: 12px 0 18px;
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    #field-filter-input {
      flex: 1 1 150px;
      max-width: 200px;
      padding: 4px 6px;
      border: 1px solid #c9d1d9;
      border-radius: 4px;
      font-size: 0.85em;
      background: #fff;
    }
    #field-filter-input:focus {
      outline: none;
      border-color: #007acc;
      box-shadow: 0 0 0 3px rgba(0, 122, 204, 0.15);
    }
    #field-filter-summary {
      font-size: 0.9em;
      color: #4b5563;
      white-space: nowrap;
    }
    #field-layout {
      display: block;
      width: 100%;
    }
    #field-values-column {
      width: 100%;
      overflow-y: auto;
      max-height: calc(100vh - 250px);
    }
    #field-detail-panel {
      display: none; /* Not used for field normalization */
    }
    .field-group {
      border: 1px solid #d0d7de;
      border-radius: 6px;
      margin: 0 0 8px 0;
      background: #fff;
    }
    .field-group.selected {
      background-color: #e3f2fd;
      border-color: #2196f3;
    }
    .field-group-header {
      padding: 8px 12px;
      border-bottom: 1px solid #eee;
    }
    .field-group-header:last-child {
      border-bottom: none;
    }
    .field-value-display {
      font-weight: 600;
      font-size: 1em;
      color: #222;
    }
    .field-count {
      font-size: 0.85em;
      color: #555;
      margin-top: 2px;
    }
    .field-normalized-section {
      padding: 8px 12px;
      background: #f8f9fa;
      border-top: 1px solid #eee;
    }
    .field-normalized-label {
      font-size: 0.8em;
      color: #666;
      margin-bottom: 4px;
    }
    .field-normalized-input {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid #c9d1d9;
      border-radius: 4px;
      font-size: 0.9em;
      box-sizing: border-box;
    }
    .field-normalized-input:focus {
      outline: none;
      border-color: #007acc;
    }
    .field-pill {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 16px;
      font-size: 0.85em;
      cursor: pointer;
      margin: 2px;
      border: 1px solid transparent;
    }
    .field-pill-normalized {
      background: #e8f5e9;
      color: #2e7d32;
      border-color: #a5d6a7;
    }
    .field-pill-unnormalized {
      background: #fff3e0;
      color: #e65100;
      border-color: #ffcc80;
    }
    .field-pill.selected {
      box-shadow: 0 0 0 2px #2196f3;
    }
    @media (max-width: 960px) {
      #field-layout {
        grid-template-columns: 1fr;
      }
      #field-detail-panel {
        position: static;
        max-height: none;
      }
    }
  </style>
</head>
<body>
  <h1 style="display:none;">Author Name Normalizer</h1>

  <!-- Summary header for full-library analysis -->
  <div id="summary-group" class="summary" style="display: none;">
    <h3>Library Analysis Summary</h3>
    <div class="summary-grid">
      <div><strong>Unique surnames:</strong> <span id="summary-total-creators">Loading...</span></div>
      <div><strong>Variant groups:</strong> <span id="summary-variant-groups">Loading...</span></div>
      <div><strong>Pending normalizations:</strong> <span id="summary-pending-normalizations">Loading...</span></div>
    </div>
  </div>

  <!-- Progress indicator for batch processing -->
  <div id="progress-container" class="progress">
    <div class="progress-bar">
      <div id="progress-fill" class="progress-fill"></div>
    </div>
    <span id="progress-label">Processing...</span>
  </div>

  <!-- Variant groups + detail layout -->
  <div id="variant-section">
    <h3>Creator Variant Groups</h3>
    <div id="variant-filter-bar">
      <input type="search" id="variant-filter-input" placeholder="Filter variant groupsâ€¦" aria-label="Filter variant groups">
      <span id="variant-filter-summary">Showing all groups</span>
    </div>
    <div id="variant-layout">
      <div id="variant-groups-column">
        <div id="variant-groups-container">
          <!-- Variant groups will be dynamically populated here -->
        </div>
      </div>
      <aside id="variant-detail-panel" class="variant-detail empty hidden">
        <h4 id="variant-detail-title">Variant details</h4>
        <div id="variant-detail-context" class="variant-detail-context"></div>
        <div id="variant-detail-empty" class="variant-detail-empty">Select a variant pill to review sample items and occurrences.</div>
        <ul id="variant-detail-items"></ul>
      </aside>
    </div>
  </div>

  <!-- Empty state -->
  <div id="empty-message" class="empty-message" style="display: none;">
    No variant groups found. All creator names appear to be consistent.
  </div>

  <!-- Action buttons -->
  <div style="text-align: right; margin-top: 20px;">
    <button id="export-button" style="margin-right: auto;">Export JSON</button>
    <button id="apply-all-button" disabled style="margin-right: 10px;">Apply All Selected</button>
    <button id="apply-button" disabled>Apply Selected</button>
    <button id="cancel-button">Cancel</button>
  </div>

  <script type="application/javascript" src="chrome://zoteronamenormalizer/content/scripts/zotero-ner-bundled.js"></script>
  <script type="application/javascript">
    /* global Zotero, ZoteroNER */

    console.log('DIALOG-SCRIPT: Inline script starting');

    // HTML DOM utils
    const ZoteroNER_HTMLUtils = {
      getElement: function(id) {
        return document.getElementById(id);
      },
      createElement: function(tagName, attributes = {}) {
        const el = document.createElement(tagName);
        for (const [key, value] of Object.entries(attributes)) {
          el.setAttribute(key, value);
        }
        return el;
      },
      appendTo: function(parentId, child) {
        const parent = this.getElement(parentId);
        if (parent) parent.appendChild(child);
      },
      clearContainer: function(id) {
        const container = this.getElement(id);
        if (container) container.innerHTML = '';
      },
      setText: function(id, text) {
        const el = this.getElement(id);
        if (el) el.textContent = text;
      },
      setHidden: function(id, hidden) {
        const el = this.getElement(id);
        if (el) el.style.display = hidden ? 'none' : 'block';
      },
      updateProgressBar: function(percent) {
        const fill = document.getElementById('progress-fill');
        if (fill) {
          fill.classList.remove('indeterminate');
          fill.style.width = percent + '%';
        }
      },
      updateProgressLabel: function(text) {
        const label = document.getElementById('progress-label');
        if (label) label.textContent = text;
      },
      setProgressIndeterminate: function(indeterminate) {
        const fill = document.getElementById('progress-fill');
        if (fill) {
          if (indeterminate) {
            fill.classList.add('indeterminate');
          } else {
            fill.classList.remove('indeterminate');
          }
        }
      }
    };

    // Zotero API access helper - robust pattern for dialog context
    var ZoteroNER_ZoteroAPI = {
      /**
       * Get Zotero API reference from dialog context
       * Tries multiple patterns in order of preference
       * @returns {Object|null} Zotero API or null if unavailable
       */
      getZotero: function() {
        // Pattern 1: window.opener.Zotero (for dialogs opened via openDialog)
        if (window.opener && window.opener.Zotero) {
          return window.opener.Zotero;
        }

        // Pattern 2: parent frame Zotero (for iframes)
        let current = window;
        while (current.parent && current.parent !== current) {
          if (current.parent.Zotero) {
            return current.parent.Zotero;
          }
          current = current.parent;
        }

        // Pattern 3: Global Zotero (may not be available in dialog context)
        if (typeof Zotero !== 'undefined') {
          return Zotero;
        }

        return null;
      },

      /**
       * Get Zotero.NER / Zotero.NameNormalizer reference
       * @returns {Object|null} NameNormalizer API or null if unavailable
       */
      getNameNormalizer: function() {
        const zotero = this.getZotero();
        if (!zotero) return null;

        // Prefer Zotero.NameNormalizer (modern)
        if (zotero.NameNormalizer) {
          return zotero.NameNormalizer;
        }

        // Fall back to Zotero.NER (legacy alias)
        if (zotero.NER) {
          return zotero.NER;
        }

        return null;
      },

      /**
       * Check if Zotero APIs are available
       * @returns {boolean}
       */
      isAvailable: function() {
        return this.getZotero() !== null;
      },

    };

    // Embedded controller
    var ZoteroNER_NormalizationDialog = {
      dbAnalyzer: null,
      isProcessing: false,
    analysisResults: null,
    items: null,
    analysisResultsSource: null,
    userSelections: null,
    variantDetailState: null,
    filterText: '',
    currentProgressState: null,
    lastProgressTime: null,
    lastHeartbeat: null,
    progressUpdateTimer: null,

      /**
       * Get Zotero API reference from dialog context
       * Tries multiple patterns in order of preference
       * @returns {Object|null} Zotero API or null if unavailable
       */
      getZotero: function() {
        // Pattern 1: window.opener.Zotero (for dialogs opened via openDialog)
        if (window.opener && window.opener.Zotero) {
          return window.opener.Zotero;
        }

        // Pattern 2: parent frame Zotero (for iframes)
        let current = window;
        while (current.parent && current.parent !== current) {
          if (current.parent.Zotero) {
            return current.parent.Zotero;
          }
          current = current.parent;
        }

        // Pattern 3: Global Zotero (may not be available in dialog context)
        if (typeof Zotero !== 'undefined') {
          return Zotero;
        }

        return null;
      },

      /**
       * Escape HTML special characters
       * @param {string} str - String to escape
       * @returns {string} Escaped string
       */
      escapeHtml: function(str) {
        if (!str) return '';
        return String(str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      },

      init: function() {
        console.log('Dialog initialization started');
        this.userSelections = new Map();
        this.variantDetailState = null;
        this.filterText = '';
        this.currentProgressState = null;

        // Set up event delegation for clickable item links
        document.addEventListener('click', (event) => {
          const link = event.target.closest('.item-link');
          if (link) {
            event.preventDefault();
            const itemKey = link.getAttribute('data-item-key');
            // Show debug in the detail panel
            const debugEl = document.getElementById('variant-detail-items');
            if (debugEl && debugEl.firstChild && debugEl.firstChild.className === 'debug-info') {
              debugEl.firstChild.textContent = 'DEBUG: Clicked itemKey=' + itemKey;
            }
            if (itemKey) {
              // Try to select the item in Zotero using multiple methods
              const opener = window.opener;
              if (opener) {
                try {
                  // Method 1: Use ZoteroPane (internal API, most reliable)
                  if (opener.ZoteroPane && opener.ZoteroPane.selectItem) {
                    // Try to resolve key to ID if possible
                    if (opener.Zotero && opener.Zotero.Items && opener.Zotero.Items.getByLibraryAndKeyAsync) {
                      const libraryID = opener.Zotero.Libraries.userLibraryID;
                      opener.Zotero.Items.getByLibraryAndKeyAsync(libraryID, itemKey).then(item => {
                        if (item && item.id) {
                          opener.ZoteroPane.selectItem(item.id);
                        } else {
                          // Fallback: try with key (may not work)
                          opener.ZoteroPane.selectItem(itemKey);
                        }
                      }).catch(e => {
                        console.error('Failed to get item by key:', e);
                      });
                      return;
                    } else {
                      opener.ZoteroPane.selectItem(itemKey);
                      return;
                    }
                  }
                  // Method 2: Use Zotero.NameNormalizer.selectItem (our helper)
                  if (opener.Zotero && opener.Zotero.NameNormalizer && opener.Zotero.NameNormalizer.selectItem) {
                    opener.Zotero.NameNormalizer.selectItem(itemKey);
                    return;
                  }
                  // Method 3: Use Zotero.launchURL with zotero:// URI (least reliable)
                  if (opener.Zotero && opener.Zotero.launchURL) {
                    const url = 'zotero://select/library/items/' + itemKey;
                    opener.Zotero.launchURL(url);
                    return;
                  }
                  console.error('No method available to select item');
                } catch (e) {
                  console.error('Failed to select item:', e);
                  if (debugEl && debugEl.firstChild && debugEl.firstChild.className === 'debug-info') {
                    debugEl.firstChild.textContent = 'DEBUG: Error selecting item: ' + e.message;
                  }
                }
              } else {
                if (debugEl && debugEl.firstChild && debugEl.firstChild.className === 'debug-info') {
                  debugEl.firstChild.textContent = 'DEBUG: No opener window';
                }
              }
            }
          }
        });

        this.setupFilterInput();
        this.setupKeyboardShortcuts();
        this.setupExportShortcut();
        this.setupFieldEventListeners();
        Promise.resolve(this.initialize()).catch((error) => {
          console.error(error);
          this.alert('Error', 'Failed to initialize: ' + error.message);
          window.close();
        });
      },

      unwrapDialogParams: function(raw) {
        if (!raw) {
          return raw;
        }

        try {
          if (raw.wrappedJSObject) {
            return raw.wrappedJSObject;
          }
        } catch (err) {
          this.log('Failed to access wrappedJSObject: ' + err.message);
        }

        if (typeof raw.getProperty === 'function') {
          try {
            const wrapped = raw.getProperty('wrappedJSObject');
            if (wrapped) {
              return wrapped;
            }
          } catch (err) {
            this.log('No wrappedJSObject property in param bag: ' + err.message);
          }

          let items;
          let analysisResults;
          let analysisResultsJSON;
          let fieldType;

          try {
            items = raw.getProperty('items');
          } catch (err) {
            this.log('Unable to read items from param bag: ' + err.message);
          }

          try {
            analysisResults = raw.getProperty('analysisResults');
          } catch (err) {
            this.log('Unable to read analysisResults from param bag: ' + err.message);
          }

          try {
            analysisResultsJSON = raw.getProperty('analysisResultsJSON');
          } catch (err) {
            this.log('Unable to read analysisResultsJSON from param bag: ' + err.message);
          }

          try {
            fieldType = raw.getProperty('fieldType');
          } catch (err) {}

          if (analysisResultsJSON || analysisResults || items || fieldType) {
            return {
              items,
              analysisResults,
              analysisResultsJSON,
              fieldType
            };
          }
        }

        return raw;
      },

      sanitizeAnalysisResults: function(value, contextLabel = 'analysis results') {
        if (!value || typeof value !== 'object') {
          return null;
        }

        try {
          const plain = JSON.parse(JSON.stringify(value));
          this.log('Sanitized ' + contextLabel + ' (suggestions: ' + ((plain && Array.isArray(plain.suggestions)) ? plain.suggestions.length : 'unknown') + ')');
          return plain;
        } catch (err) {
          this.log('Failed to sanitize ' + contextLabel + ': ' + err.message);
        }

        return null;
      },

      safeParseJSON: function(jsonString, contextLabel = 'analysisResultsJSON') {
        if (!jsonString || typeof jsonString !== 'string') {
          return null;
        }

        try {
          const parsed = JSON.parse(jsonString);
          this.log('Parsed ' + contextLabel + ' (suggestions: ' + ((parsed && Array.isArray(parsed.suggestions)) ? parsed.suggestions.length : 'unknown') + ')');
          return parsed;
        } catch (err) {
          this.log('Failed to parse ' + contextLabel + ': ' + err.message);
        }

        return null;
      },

      resolveAnalysisResults: function(params, contextLabel = 'dialog params') {
        if (!params) {
          return null;
        }

        if (params.analysisResults && typeof params.analysisResults === 'object') {
          const sanitized = this.sanitizeAnalysisResults(params.analysisResults, contextLabel + '.analysisResults');
          if (sanitized) {
            this.analysisResultsSource = contextLabel + '.analysisResults';
            return sanitized;
          }
        }

        if (params.analysisResultsJSON) {
          const parsed = this.safeParseJSON(params.analysisResultsJSON, contextLabel + '.analysisResultsJSON');
          if (parsed) {
            this.analysisResultsSource = contextLabel + '.analysisResultsJSON';
            return parsed;
          }
        }

        return null;
      },

      log: function(message) {
        const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
        const logLine = 'NER-DIALOG:' + timestamp + ' ' + message;
        console.log(logLine);
        try {
          if (typeof Zotero !== 'undefined' && typeof Zotero.debug === 'function') {
            Zotero.debug('Zotero NER Dialog: ' + message);
          }
        } catch (e) {}
        // Note: XPCOM file logging removed (dead code, never worked in modern browsers)
      },

      alert: function(title, message) {
        try {
          if (typeof Zotero !== 'undefined' && typeof Zotero.alert === 'function') {
            Zotero.alert(null, title, message);
          } else {
            window.alert(title + ': ' + message);
          }
        } catch (e) {
          window.alert(title + ': ' + message);
        }
      },

      confirm: async function(title, message) {
        // Create custom modal for cross-browser compatible confirm with custom title
        return new Promise((resolve) => {
          // Remove any existing modal
          const existing = document.getElementById('zoteroner-custom-confirm');
          if (existing) existing.remove();

          // Create modal overlay
          const overlay = document.createElement('div');
          overlay.id = 'zoteroner-custom-confirm';
          overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000000;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
          `;

          // Create modal dialog
          const dialog = document.createElement('div');
          dialog.style.cssText = `
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            min-width: 350px;
            max-width: 500px;
            overflow: hidden;
          `;

          // Header
          const header = document.createElement('div');
          header.style.cssText = `
            background: #f0f0f0;
            padding: 12px 16px;
            font-weight: 600;
            font-size: 14px;
            border-bottom: 1px solid #ddd;
          `;
          header.textContent = title;

          // Body
          const body = document.createElement('div');
          body.style.cssText = `
            padding: 20px 16px;
            font-size: 13px;
            line-height: 1.5;
            white-space: pre-wrap;
          `;
          body.textContent = message;

          // Buttons
          const buttons = document.createElement('div');
          buttons.style.cssText = `
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            padding: 12px 16px;
            background: #f9f9f9;
            border-top: 1px solid #eee;
          `;

          const createButton = (label, isPrimary) => {
            const btn = document.createElement('button');
            btn.textContent = label;
            btn.setAttribute('role', 'button');
            btn.setAttribute('aria-label', label);
            btn.style.cssText = `
              padding: 8px 16px;
              border-radius: 4px;
              border: 1px solid ${isPrimary ? '#4a90d9' : '#aaa'};
              background: ${isPrimary ? '#4a90d9' : '#fff'};
              color: ${isPrimary ? '#fff' : '#333'};
              font-size: 13px;
              cursor: pointer;
            `;
            btn.addEventListener('click', () => {
              overlay.remove();
              resolve(label === 'OK');
            });
            return btn;
          };

          buttons.appendChild(createButton('Cancel', false));
          buttons.appendChild(createButton('OK', true));

          dialog.appendChild(header);
          dialog.appendChild(body);
          dialog.appendChild(buttons);
          overlay.appendChild(dialog);
          document.body.appendChild(overlay);

          // Cleanup handler for event listeners
          const cleanup = () => {
            document.removeEventListener('keydown', escHandler);
          };

          // Close on escape
          const escHandler = (e) => {
            if (e.key === 'Escape') {
              overlay.remove();
              cleanup();
              resolve(false);
            }
          };
          document.addEventListener('keydown', escHandler);

          // Close on clicking outside the dialog
          overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
              overlay.remove();
              cleanup();
              resolve(false);
            }
          });
        });
      },

      setupFilterInput: function() {
        const input = ZoteroNER_HTMLUtils.getElement('variant-filter-input');
        if (!input) {
          return;
        }

        input.value = this.filterText || '';
        input.addEventListener('input', (event) => {
          this.handleFilterInput(event.target.value);
        });
      },

      setupKeyboardShortcuts: function() {
        document.addEventListener('keydown', (event) => {
          // Ignore shortcuts when typing in input fields
          const tagName = event.target.tagName.toLowerCase();
          if (tagName === 'input' || tagName === 'textarea') {
            return;
          }

          const isMod = event.ctrlKey || event.metaKey;

          // Ctrl/Cmd + Enter - Apply selected
          if (isMod && event.key === 'Enter') {
            event.preventDefault();
            const applyBtn = document.getElementById('apply-button');
            if (applyBtn && !applyBtn.disabled) {
              this.applySelected();
            }
            return;
          }

          // Ctrl/Cmd + A - Apply all
          if (isMod && event.key.toLowerCase() === 'a') {
            event.preventDefault();
            const applyAllBtn = document.getElementById('apply-all-button');
            if (applyAllBtn && !applyAllBtn.disabled) {
              this.applyAllSelected();
            }
            return;
          }

          // Ctrl/Cmd + F - Focus filter
          if (isMod && event.key.toLowerCase() === 'f') {
            event.preventDefault();
            const filterInput = document.getElementById('variant-filter-input');
            if (filterInput) {
              filterInput.focus();
              filterInput.select();
            }
            return;
          }

          // Escape - Cancel/close
          if (event.key === 'Escape') {
            event.preventDefault();
            window.close();
            return;
          }

          // Arrow keys - Navigate pills within current group
          if (event.key === 'ArrowLeft' || event.key === 'ArrowRight' ||
              event.key === 'ArrowUp' || event.key === 'ArrowDown') {
            this.handlePillNavigation(event);
            return;
          }

          // Enter/Space - Activate focused pill
          if (event.key === 'Enter' || event.key === ' ') {
            const focusedPill = document.querySelector('.variant-pill:focus');
            if (focusedPill) {
              event.preventDefault();
              focusedPill.click();
            }
            return;
          }
        });
      },

      handlePillNavigation: function(event) {
        const direction = event.key === 'ArrowLeft' || event.key === 'ArrowUp' ? -1 : 1;
        const pills = Array.from(document.querySelectorAll('.variant-pill'));
        const focusedIndex = pills.findIndex(p => p === document.activeElement);

        if (focusedIndex === -1) {
          // No pill focused, focus first or last based on direction
          const targetIndex = direction === 1 ? 0 : pills.length - 1;
          if (pills[targetIndex]) {
            pills[targetIndex].focus();
          }
        } else {
          // Navigate to adjacent pill
          let newIndex = focusedIndex + direction;
          if (newIndex < 0) newIndex = pills.length - 1;
          if (newIndex >= pills.length) newIndex = 0;

          if (pills[newIndex]) {
            pills[newIndex].focus();
          }
        }

        event.preventDefault();
      },

      setupExportShortcut: function() {
        // Export button click
        const exportBtn = document.getElementById('export-button');
        if (exportBtn) {
          exportBtn.addEventListener('click', () => {
            console.log('Export button clicked');
            this.exportToJSON();
          });
        }

        // Ctrl+S keyboard shortcut
        document.addEventListener('keydown', (event) => {
          const isMod = event.ctrlKey || event.metaKey;
          if (isMod && event.key.toLowerCase() === 's') {
            event.preventDefault();
            console.log('Ctrl+S pressed');
            this.exportToJSON();
          }
        });
      },

      setupFieldEventListeners: function() {
        // Apply field button
        const applyFieldBtn = document.getElementById('apply-field-button');
        if (applyFieldBtn) {
          applyFieldBtn.addEventListener('click', async () => {
            const result = await this.applySelectedFieldNormalizations();
            if (result.success && result.applied > 0) {
              this.alert('Field Normalizer', 'Successfully normalized ' + result.applied + ' item(s).');
              window.close();
            } else if (result.success) {
              this.alert('Field Normalizer', 'No changes to apply.');
            } else {
              this.alert('Field Normalizer', 'Error: ' + result.error);
            }
          });
        }

        // Apply all field button
        const applyAllFieldBtn = document.getElementById('apply-all-field-button');
        if (applyAllFieldBtn) {
          applyAllFieldBtn.addEventListener('click', async () => {
            let pendingCount = 0;
            this.fieldSelections.forEach(selection => {
              if (selection.apply) pendingCount++;
            });

            if (pendingCount === 0) {
              this.alert('Field Normalizer', 'No normalizations selected.');
              return;
            }

            const confirmed = await this.confirm(
              'Confirming Changes',
              'You are about to apply ' + pendingCount + ' normalization(s) to your library.\n\n' +
              'This will modify field values in ' + pendingCount + ' item(s).\n\n' +
              'Are you sure you want to continue?'
            );

            if (confirmed) {
              const result = await this.applySelectedFieldNormalizations();
              if (result.success && result.applied > 0) {
                this.alert('Field Normalizer', 'Successfully normalized ' + result.applied + ' item(s).');
                window.close();
              } else {
                this.alert('Field Normalizer', 'Error: ' + result.error);
              }
            }
          });
        }

        // Cancel field button
        const cancelFieldBtn = document.getElementById('cancel-field-button');
        if (cancelFieldBtn) {
          cancelFieldBtn.addEventListener('click', () => {
            window.close();
          });
        }

        // Field filter input
        const fieldFilterInput = document.getElementById('field-filter-input');
        if (fieldFilterInput) {
          fieldFilterInput.addEventListener('input', () => {
            this.filterText = fieldFilterInput.value;
            this.populateFieldValues();
          });
        }
      },

      exportToJSON: async function() {
        if (!this.analysisResults || !this.analysisResults.suggestions) {
          this.alert('Export', 'No data to export.');
          return;
        }

        const suggestions = this.analysisResults.suggestions;
        const exportData = {
          exportDate: new Date().toISOString(),
          totalVariantGroups: suggestions.length,
          totalUniqueSurnames: this.analysisResults.totalUniqueSurnames || 0,
          variantGroups: []
        };

        suggestions.forEach((suggestion, index) => {
          const selection = this.userSelections ? this.userSelections.get(index) : null;
          const totalOccurrences = (suggestion.variants || []).reduce((sum, v) => sum + (v.frequency || 0), 0);

          const group = {
            index: index,
            type: suggestion.type,
            surname: suggestion.surname || '',
            primary: suggestion.primary || '',
            variantCount: suggestion.variants ? suggestion.variants.length : 0,
            totalOccurrences: totalOccurrences,
            recommendedNormalization: this.getDefaultNormalizationValue(suggestion),
            variants: []
          };

          if (suggestion.variants) {
            suggestion.variants.forEach(variant => {
              const variantData = {
                name: variant.name || (variant.firstName ? `${variant.firstName} ${variant.lastName || ''}` : ''),
                firstName: variant.firstName || '',
                lastName: variant.lastName || '',
                frequency: variant.frequency || 0,
                items: []
              };

              if (variant.items) {
                variant.items.forEach(item => {
                  variantData.items.push({
                    title: item.title || 'Untitled',
                    year: item.year || item.date || '',
                    author: item.author || '',
                    key: item.key || ''
                  });
                });
              }

              group.variants.push(variantData);
            });
          }

          if (selection) {
            group.userSelection = {
              mode: selection.mode || 'primary',
              value: selection.value || selection.customValue || '',
              apply: selection.apply !== false,
              variantIndex: selection.variantIndex
            };
          }

          exportData.variantGroups.push(group);
        });

        const json = JSON.stringify(exportData, null, 2);
        const timestamp = new Date().toISOString().split('T')[0];
        const defaultName = `zotero-ner-variant-groups-${timestamp}.json`;

        try {
          // Get Zotero instance
          const zotero = window.opener && window.opener.Zotero ? window.opener.Zotero : 
                        (typeof Zotero !== 'undefined' ? Zotero : null);
          
          if (!zotero) {
            this.alert('Export Error', 'Zotero instance not available');
            return;
          }

          // Get Zotero data directory
          let exportDir = null;
          
          // Try various ways to get the data directory
          if (zotero.DataDirectory && zotero.DataDirectory.dir) {
            exportDir = zotero.DataDirectory.dir;
          } else if (zotero.getZoteroDirectory && typeof zotero.getZoteroDirectory === 'function') {
            const dirObj = zotero.getZoteroDirectory();
            exportDir = dirObj ? dirObj.path : null;
          } else if (typeof Cc !== 'undefined' && typeof Ci !== 'undefined') {
            // Fallback: use Zotero's profile directory
            const dirService = Cc['@mozilla.org/file/directory_service;1'].getService(Ci.nsIProperties);
            const profileDir = dirService.get('ProfD', Ci.nsIFile);
            exportDir = profileDir.path;
          }

          if (!exportDir) {
            this.alert('Export Error', 'Could not determine Zotero data directory');
            return;
          }

          console.warn('NER Export: Using directory:', exportDir);

          // Construct full path
          const exportPath = PathUtils.join(exportDir, defaultName);
          console.warn('NER Export: Full path:', exportPath);

          // Write the file
          await IOUtils.writeUTF8(exportPath, json);

          console.warn('NER Export: File written successfully');
          this.log('Exported to ' + exportPath);
          
          // Show success with file location
          window.alert('Export successful!\n\nFile saved to:\n' + exportPath);
          
        } catch (e) {
          console.error('NER Export FAILED:', e.message, e);
          this.log('Export error: ' + e.message);
          window.alert('Export failed: ' + e.message);
        }
      },

      handleFilterInput: function(rawValue) {
        this.filterText = (rawValue || '').trim();
        this.populateVariantGroupList();
      },

      matchesFilter: function(suggestion) {
        const query = (this.filterText || '').toLowerCase();
        if (!query) {
          return true;
        }

        const terms = [];
        const capture = (value) => {
          if (!value) {
            return;
          }
          if (typeof value === 'string') {
            terms.push(value.toLowerCase());
          }
        };

        capture(suggestion.type);
        capture(suggestion.surname);
        capture(typeof suggestion.primary === 'string' ? suggestion.primary : this.formatNameString(suggestion.primary));
        capture(suggestion.recommendedFullName);
        capture(suggestion.recommendedFirstName);

        (suggestion.variants || []).forEach(variant => {
          capture(variant.name);
          capture(variant.firstName);
          capture(variant.lastName);
        });

        return terms.some(term => term.includes(query));
      },

      updateFilterSummary: function(visibleCount, totalCount) {
        const summaryEl = ZoteroNER_HTMLUtils.getElement('variant-filter-summary');
        if (!summaryEl) {
          return;
        }

        if (!totalCount) {
          summaryEl.textContent = 'No variant groups available';
          return;
        }

        if (!this.filterText) {
          summaryEl.textContent = `Showing all ${totalCount} variant groups`;
          return;
        }

        summaryEl.textContent = `Showing ${visibleCount} of ${totalCount} groups`;
      },
      
      initialize: async function() {
        this.log('Dialog initialize started');

        // Track when analysis is complete (set by updateAnalysisResults)
        this.analysisComplete = false;

        let params = null;

        try {
          if (typeof window.arguments !== 'undefined' && window.arguments.length > 0) {
            params = window.arguments[0];
            this.log('Read window.arguments');
          }
        } catch (err) {
          this.log('Unable to read window arguments: ' + err.message);
        }

        if (params) {
          params = this.unwrapDialogParams(params);
          this.log('Unwrapped dialog params');
        }

        if (!params && window.ZoteroNERDialogParams) {
          params = this.unwrapDialogParams(window.ZoteroNERDialogParams);
        }

        if (!params && window.ZoteroNERDialogParamsJSON) {
          params = { analysisResultsJSON: window.ZoteroNERDialogParamsJSON };
        }

        this.log('params.fieldType = ' + (params && params.fieldType));

        // Check for field normalization params
        if (params && params.fieldType) {
          this.log('Field normalization requested for type: ' + params.fieldType);
          await this.initializeFieldNormalization(params);
          return;
        }

        if (!params && window.opener) {
          try {
            if (window.opener.ZoteroNERDialogParams) {
              params = this.unwrapDialogParams(window.opener.ZoteroNERDialogParams);
            }
          } catch (err) {
            this.log('Unable to read ZoteroNERDialogParams from opener: ' + err.message);
          }
        }

        if (!params && window.opener && window.opener.ZoteroNERDialogParamsJSON) {
          params = { analysisResultsJSON: window.opener.ZoteroNERDialogParamsJSON };
        }

        if (!params && window.opener && window.opener.ZoteroNERAnalysisResultsJSON) {
          params = { analysisResultsJSON: window.opener.ZoteroNERAnalysisResultsJSON };
        }

        if (!params && window.opener && window.opener.ZoteroNERAnalysisResults) {
          const sanitized = this.sanitizeAnalysisResults(window.opener.ZoteroNERAnalysisResults, 'opener.ZoteroNERAnalysisResults');
          if (sanitized) {
            params = { analysisResults: sanitized };
          }
        }

        if (!params && window.ZoteroNERAnalysisResultsJSON) {
          params = { analysisResultsJSON: window.ZoteroNERAnalysisResultsJSON };
        }

        if (!params && window.ZoteroNERAnalysisResults) {
          const sanitizedCurrent = this.sanitizeAnalysisResults(window.ZoteroNERAnalysisResults, 'window.ZoteroNERAnalysisResults');
          if (sanitizedCurrent) {
            params = { analysisResults: sanitizedCurrent };
          }
        }

        let analysisResults = null;

        if (params) {
          params = this.unwrapDialogParams(params);
        }

        // Try to resolve analysisResults from params
        if (params) {
          analysisResults = this.resolveAnalysisResults(params, 'dialog params');
        }

        // Try other sources if needed
        if (!analysisResults && window.opener && window.opener.ZoteroNERAnalysisResultsJSON) {
          analysisResults = this.safeParseJSON(window.opener.ZoteroNERAnalysisResultsJSON, 'opener.ZoteroNERAnalysisResultsJSON');
        }

        if (!analysisResults && window.opener && window.opener.ZoteroNERAnalysisResults) {
          analysisResults = this.sanitizeAnalysisResults(window.opener.ZoteroNERAnalysisResults, 'opener.ZoteroNERAnalysisResults direct');
        }

        if (!analysisResults && window.ZoteroNERAnalysisResultsJSON) {
          analysisResults = this.safeParseJSON(window.ZoteroNERAnalysisResultsJSON, 'window.ZoteroNERAnalysisResultsJSON');
        }

        if (!analysisResults && window.ZoteroNERAnalysisResults) {
          analysisResults = this.sanitizeAnalysisResults(window.ZoteroNERAnalysisResults, 'window.ZoteroNERAnalysisResults direct');
        }

        // If still no results but params looks like results itself
        if (!analysisResults && params && typeof params === 'object' && !params.loading) {
          const direct = this.sanitizeAnalysisResults(params, 'dialog params direct');
          if (direct) {
            analysisResults = direct;
            this.analysisResultsSource = 'dialog params direct';
          }
        }

        if (params && params.items) {
          this.items = params.items;
        }

        if (!analysisResults) {
          this.log('No analysis results found');
          this.showEmptyState('No analysis results were provided to the dialog.');
          this.updateProgress();
          return;
        }

        // Check if this is a loading state OR if suggestions are NULL (stale cached data)
        // We need fresh analysis if:
        // 1. loading === true (explicitly waiting for analysis)
        // 2. suggestions is NULL (stale cached data with no results)
        if (analysisResults.loading === true || analysisResults.suggestions === null) {
          const reason = analysisResults.loading === true ? 'loading=true' : 'suggestions=NULL';
          this.log('Dialog opened in loading state (' + reason + ')');
          // Always show loading state first to ensure progress bar is visible immediately
          this.showLoadingState();
          // Then start progress tracking for timeout detection
          this.startProgressTracking();
          return;
        }

        this.analysisResults = analysisResults;
        this.resetSelections();
        this.clearVariantDetails();

        this.log('Analysis results source: ' + (this.analysisResultsSource || 'unknown'));
        this.log('Analysis results loaded: ' + (this.analysisResults.suggestions ? this.analysisResults.suggestions.length : 0) + ' suggestions; unique surnames: ' + (this.analysisResults.totalUniqueSurnames ?? 'unknown'));

        this.updateSummaryHeader();
        this.populateVariantGroupList();
        this.refreshApplyButtonState();
        // Hide progress container when showing results
        ZoteroNER_HTMLUtils.setHidden('progress-container', true);
        this.updateProgress();
      },

      showEmptyState: function(message) {
        // Ensure progress bar is hidden
        ZoteroNER_HTMLUtils.setHidden('progress-container', true);
        
        if (this.analysisResults) {
          this.updateSummaryHeader();
        } else {
          ZoteroNER_HTMLUtils.setHidden('summary-group', true);
        }

        const totalSuggestions = (this.analysisResults && Array.isArray(this.analysisResults.suggestions))
          ? this.analysisResults.suggestions.length
          : 0;
        this.updateFilterSummary(0, totalSuggestions);

        ZoteroNER_HTMLUtils.clearContainer('variant-groups-container');
        this.clearVariantDetails();

        this.setApplyEnabled(false);

        const emptyMsg = ZoteroNER_HTMLUtils.getElement('empty-message');
        if (emptyMsg) {
          const frequencies = this.analysisResults && this.analysisResults.surnameFrequencies
            ? Object.entries(this.analysisResults.surnameFrequencies)
            : [];
          const totalUnique = this.analysisResults && typeof this.analysisResults.totalUniqueSurnames === 'number'
            ? this.analysisResults.totalUniqueSurnames
            : 0;
          const topFrequencies = frequencies
            .sort((a, b) => b[1] - a[1])
            .slice(0, 10);

          let html = '<div class="empty-message-content">';
          html += `<p>${message || 'No variant groups found. All creator names appear to be consistent.'}</p>`;

          if (totalUnique) {
            html += `<p><strong>Total unique surnames scanned:</strong> ${totalUnique}</p>`;
          }

          if (topFrequencies.length > 0) {
            html += '<p><strong>Top surnames by frequency:</strong></p>';
            html += '<ul class="surname-frequency-list">';
            topFrequencies.forEach(([name, count]) => {
              html += `<li><span class="surname">${this.formatSurnameKey(name)}</span> <span class="frequency">(${count})</span></li>`;
            });
            html += '</ul>';
          }

          html += '</div>';
          emptyMsg.innerHTML = html;
          emptyMsg.style.display = 'block';
        }
      },

      /**
       * Initialize field normalization mode
       */
      initializeFieldNormalization: async function(params) {
        this.log('Initializing field normalization for: ' + params.fieldType);

        // Set window title based on field type
        const fieldTypeLabel = params.fieldType ? params.fieldType.charAt(0).toUpperCase() + params.fieldType.slice(1) : 'Field';
        document.title = fieldTypeLabel + ' Normalization';

        // Show field normalization section, hide author normalization sections
        const fieldSection = document.getElementById('field-normalization-section');
        const variantSection = document.getElementById('variant-section');
        const summaryGroup = document.getElementById('summary-group');
        const emptyMessage = document.getElementById('empty-message');
        const actionButtons = document.querySelector('div[style="text-align: right; margin-top: 20px;"]');

        if (fieldSection) {
          fieldSection.style.display = 'block';
        }
        if (variantSection) {
          variantSection.style.display = 'none';
        }
        if (summaryGroup) {
          summaryGroup.style.display = 'none';
        }
        if (emptyMessage) {
          emptyMessage.style.display = 'none';
        }
        if (actionButtons) {
          actionButtons.style.display = 'none';
        }

        // Map UI field types to actual Zotero field names
        const fieldTypeMap = {
          'publisher': 'publisher',
          'location': 'place',
          'journal': 'publicationTitle'
        };

        // Set field type based on params
        const fieldType = params.fieldType || 'publisher';
        const zoteroField = fieldTypeMap[fieldType] || fieldType;

        // Update UI label
        const labelEl = document.getElementById('field-type-label');
        if (labelEl) {
          labelEl.textContent = fieldType;
        }

        // Get Zotero and items
        const Zotero = this.getZotero();
        if (!Zotero) {
          this.log('Zotero not available');
          this.showEmptyState('Zotero is not available. Field normalization requires Zotero.');
          return;
        }

        // Load all items from user's library
        let items = [];
        try {
          const libraryID = Zotero.Libraries.userLibraryID;
          if (!libraryID) {
            throw new Error('Could not determine user library ID');
          }
          items = await Zotero.Items.getAll(libraryID);
          this.log('Found ' + items.length + ' items in library');
        } catch (err) {
          this.log('Error loading items: ' + err.message);
          this.showEmptyState('Failed to load items: ' + err.message);
          return;
        }

        if (items.length === 0) {
          this.showEmptyState('No items found in library.');
          return;
        }

        this.log('Loaded ' + items.length + ' items for field normalization');

        // Show loading state
        this.showLoadingState('Processing ' + items.length + ' items...');

        try {
          // Process items for field normalization
          // Pass both zoteroField (for getting values) and fieldType (for similarity logic)
          const results = await this.processFieldItems(items, zoteroField, fieldType, null);
          this.log('processFieldItems completed, calling displayFieldResults');

          // Display results
          await this.displayFieldResults(results, fieldType, zoteroField, null);
          this.log('displayFieldResults completed');

        } catch (err) {
          this.log('Error in field normalization: ' + err.message);
          this.showEmptyState('Field normalization failed: ' + err.message);
        }
      },

      /**
       * Process items for field normalization with fuzzy matching
       * Groups similar values like "Oxford University Press" and "Oxford University Press USA"
       * @param {Array} items - Array of Zotero items
       * @param {string} zoteroField - The Zotero field name (e.g., 'publicationTitle', 'publisher')
       * @param {string} fieldType - The UI field type (e.g., 'journal', 'publisher', 'location')
       * @param {string|null} collectionId - Optional collection ID
       */
      processFieldItems: async function(items, zoteroField, fieldType, collectionId) {
        this.log('Processing ' + items.length + ' items for ' + fieldType + ' normalization');

        // Collect all unique values with their item counts
        // For publishers and locations, we first split on separators (; and /)
        const valueMap = new Map();

        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          const fieldValue = item.getField(zoteroField);
          if (!fieldValue) continue;

          // Split field values for publishers and locations
          const parts = this.splitFieldValue(fieldValue, fieldType);

          for (const part of parts) {
            if (!valueMap.has(part)) {
              valueMap.set(part, {
                rawValue: part,
                itemCount: 0,
                items: []
              });
            }
            const entry = valueMap.get(part);
            entry.itemCount++;
            entry.items.push(item);
          }

          // Update progress every 1000 items
          if (i % 1000 === 0) {
            await new Promise(r => setTimeout(r, 0));
          }
        }

        const uniqueValues = Array.from(valueMap.values());

        // Group similar values using fuzzy matching, passing fieldType
        const groups = this.groupFieldValues(uniqueValues, fieldType);

        // Convert groups to display format
        let displayItems = [];
        for (const group of groups) {
          // Find the most common variant as the default
          const sortedVariants = group.variants.sort((a, b) => b.itemCount - a.itemCount);
          const primary = sortedVariants[0];

          displayItems.push({
            item: primary.items[0], // Reference item for the group
            rawValue: primary.rawValue,
            normalized: primary.rawValue, // Will be editable by user
            variants: group.variants.map(v => v.rawValue),
            variantData: group.variants,
            groupKey: group.key,
            itemCount: group.variants.reduce((sum, v) => sum + v.itemCount, 0),
            alreadyLearned: false
          });
        }

        // Sort by total item count (most common first)
        displayItems.sort((a, b) => b.itemCount - a.itemCount);

        // Filter out groups with only one variant (nothing to normalize)
        const itemsWithChanges = displayItems.filter(item => item.variants.length > 1);
        const filteredCount = displayItems.length - itemsWithChanges.length;
        if (filteredCount > 0) {
          this.log('Filtered out ' + filteredCount + ' groups with single variant');
        }
        displayItems = itemsWithChanges;

        const results = {
          fieldType: fieldType,
          total: items.length,
          uniqueCount: displayItems.length,
          items: displayItems,
          groups: groups
        };

        this.log('Found ' + results.uniqueCount + ' normalized groups from ' + uniqueValues.length + ' unique values');
        return results;
      },

      /**
       * Group field values that are similar
       * Uses prefix matching and fuzzy token comparison
       * @param {Array} values - Array of value objects with rawValue and itemCount
       * @param {string} fieldType - The type of field (publisher, location, journal)
       * @returns {Array} - Array of grouped values
       */
      groupFieldValues: function(values, fieldType) {
        const groups = [];
        const assigned = new Set();

        // Sort by item count (most common first)
        const sorted = [...values].sort((a, b) => b.itemCount - a.itemCount);

        for (const value of sorted) {
          if (assigned.has(value.rawValue)) continue;

          // Start a new group
          const group = {
            key: this.getFieldValueKey(value.rawValue),
            variants: [value]
          };
          assigned.add(value.rawValue);

          // Find similar values to add to this group
          for (const other of sorted) {
            if (assigned.has(other.rawValue)) continue;

            if (this.areFieldValuesSimilar(value.rawValue, other.rawValue, fieldType)) {
              group.variants.push(other);
              assigned.add(other.rawValue);
            }
          }

          groups.push(group);
        }

        return groups;
      },

      /**
       * Create a key for grouping similar field values
       */
      getFieldValueKey: function(value) {
        // Normalize: lowercase, remove punctuation, get significant words
        const normalized = value.toLowerCase()
          .replace(/[&,\.\(\)]/g, ' ')
          .replace(/\s+/g, ' ')
          .trim();

        // Get tokens, keeping the first N significant words as the key
        const tokens = normalized.split(' ').filter(t => t.length > 0);

        // For publishers, first 3 words usually identify the publisher
        // e.g., "Oxford University Press" key = "oxford university press"
        // e.g., "Oxford University Press USA" key = "oxford university press"
        return tokens.slice(0, 4).join(' ');
      },

      /**
       * Split a field value by separators for multi-value fields
       * @param {string} value - The field value to split
       * @param {string} fieldType - The type of field (publisher, location, journal)
       * @returns {string[]} - Array of split values
       */
      splitFieldValue: function(value, fieldType) {
        if (!value || typeof value !== 'string') {
          return [value || ''];
        }

        // Journals are typically single values - no splitting
        if (fieldType === 'journal') {
          return [value];
        }

        // For publishers and locations, split on ; and /
        // Note: We don't split on comma because it's part of city/state format (e.g., "Cambridge, MA")
        const parts = value.split(/;\s*|\/\s*/);

        // Filter out empty strings and trim
        return parts.map(p => p.trim()).filter(p => p.length > 0);
      },

      /**
       * Check if two journal names are similar using strict rules
       * Only allows: exact match, "The" prefix difference, & vs "and"
       * @param {string} val1 - First journal name
       * @param {string} val2 - Second journal name
       * @returns {boolean} - True if similar
       */
      areJournalsSimilar: function(val1, val2) {
        // Normalize: lowercase, remove punctuation
        const norm1 = val1.toLowerCase().replace(/[&,\.\(\)]/g, ' ').replace(/\s+/g, ' ').trim();
        const norm2 = val2.toLowerCase().replace(/[&,\.\(\)]/g, ' ').replace(/\s+/g, ' ').trim();

        // Exact match (case-insensitive)
        if (norm1 === norm2) return true;

        // Check for "The" prefix difference
        // "The Journal of Philosophy" vs "Journal of Philosophy"
        const removeThe = (s) => s.replace(/^the\s+/, '');
        if (removeThe(norm1) === removeThe(norm2)) return true;

        // Check for "&" vs "and" substitution
        const withAnd1 = norm1.replace(/\s*&\s*/g, ' and ');
        const withAnd2 = norm2.replace(/\s*&\s*/g, ' and ');
        if (withAnd1 === withAnd2) return true;

        // Also check with "The" removed
        if (removeThe(withAnd1) === removeThe(withAnd2)) return true;

        return false;
      },

      /**
       * Normalize a location value by expanding/contracting US state abbreviations
       * @param {string} loc - Location string
       * @returns {string} - Normalized location
       */
      normalizeLocationState: function(loc) {
        // US state abbreviations to full names
        const stateAbbrToName = {
          'al': 'alabama', 'ak': 'alaska', 'az': 'arizona', 'ar': 'arkansas',
          'ca': 'california', 'co': 'colorado', 'ct': 'connecticut', 'de': 'delaware',
          'fl': 'florida', 'ga': 'georgia', 'hi': 'hawaii', 'id': 'idaho',
          'il': 'illinois', 'in': 'indiana', 'ia': 'iowa', 'ks': 'kansas',
          'ky': 'kentucky', 'la': 'louisiana', 'me': 'maine', 'md': 'maryland',
          'ma': 'massachusetts', 'mi': 'michigan', 'mn': 'minnesota', 'ms': 'mississippi',
          'mo': 'missouri', 'mt': 'montana', 'ne': 'nebraska', 'nv': 'nevada',
          'nh': 'new hampshire', 'nj': 'new jersey', 'nm': 'new mexico', 'ny': 'new york',
          'nc': 'north carolina', 'nd': 'north dakota', 'oh': 'ohio', 'ok': 'oklahoma',
          'or': 'oregon', 'pa': 'pennsylvania', 'ri': 'rhode island', 'sc': 'south carolina',
          'sd': 'south dakota', 'tn': 'tennessee', 'tx': 'texas', 'ut': 'utah',
          'vt': 'vermont', 'va': 'virginia', 'wa': 'washington', 'wv': 'west virginia',
          'wi': 'wisconsin', 'wy': 'wyoming', 'dc': 'district of columbia'
        };

        // Common state abbreviation variants (e.g., "Mass" -> "ma", "Penn" -> "pa")
        const stateVariants = {
          'mass': 'ma', 'penn': 'pa', 'conn': 'ct', ' Minn': 'mn',
          'ill': 'il', 'ken': 'ky', 'tenn': 'tn', 'wash': 'wa',
          'col': 'co', 'ariz': 'az', 'okla': 'ok', 'n y': 'ny',
          'n j': 'nj', 'n m': 'nm', 'n c': 'nc', 'n d': 'nd',
          'w va': 'wv', 'wisc': 'wi', 'wis': 'wi', 'mich': 'mi',
          'minn': 'mn', 'miss': 'ms', 'mont': 'mt', 'neb': 'ne',
          'okla': 'ok', 'ore': 'or', 'penna': 'pa', 'penna': 'pa',
          'ten': 'tn', 'tex': 'tx', 'wash': 'wa', 'washington d c': 'dc'
        };

        // Replace state names with abbreviations and vice versa
        let result = loc;

        // First replace common variants (Mass -> ma, Penn -> pa)
        for (const [variant, abbr] of Object.entries(stateVariants)) {
          const variantRegex = new RegExp('\\b' + variant + '\\b', 'gi');
          result = result.replace(variantRegex, abbr);
        }

        // Then replace full names
        for (const [abbr, name] of Object.entries(stateAbbrToName)) {
          // Replace abbreviations with standard form (abbreviation)
          const abbrRegex = new RegExp('\\b' + abbr + '\\b', 'gi');
          result = result.replace(abbrRegex, abbr);
          // Replace full names with abbreviations
          const nameRegex = new RegExp('\\b' + name + '\\b', 'gi');
          result = result.replace(nameRegex, abbr);
        }

        return result;
      },

      /**
       * Check if two location values are similar using strict rules
       * Only allows: exact match, punctuation differences, "&" vs "and"
       * Allows state abbreviation differences (e.g., "Cambridge, MA" = "Cambridge, Mass.")
       * Allows suffix differences (e.g., "New York, NY" vs "New York, NY, USA")
       * Does NOT allow grouping different cities together (e.g., "New York" vs "Oxford, New York")
       * @param {string} val1 - First location value
       * @param {string} val2 - Second location value
       * @returns {boolean} - True if similar
       */
      areLocationsSimilar: function(val1, val2) {
        // Normalize: lowercase, remove punctuation except & and :
        const norm1 = val1.toLowerCase().replace(/[,\.\(\)]/g, ' ').replace(/\s+/g, ' ').trim();
        const norm2 = val2.toLowerCase().replace(/[,\.\(\)]/g, ' ').replace(/\s+/g, ' ').trim();

        // Exact match (case-insensitive)
        if (norm1 === norm2) return true;

        // Normalize state abbreviations (e.g., "mass" -> "ma", "massachusetts" -> "ma")
        const stateNorm1 = this.normalizeLocationState(norm1);
        const stateNorm2 = this.normalizeLocationState(norm2);
        if (stateNorm1 === stateNorm2) return true;

        // Check for "&" vs "and" substitution
        const withAnd1 = stateNorm1.replace(/\s*&\s*/g, ' and ');
        const withAnd2 = stateNorm2.replace(/\s*&\s*/g, ' and ');
        if (withAnd1 === withAnd2) return true;

        // Check for ":" vs ", " substitution (e.g., "Oxford: New York" vs "Oxford, New York")
        const normalizePunct = (s) => s.replace(/:\s*/g, ', ').replace(/,\s*/g, ', ');
        if (normalizePunct(withAnd1) === normalizePunct(withAnd2)) return true;

        // Check if one is a prefix of the other (main location)
        // "New York, NY" vs "New York, NY, USA"
        const tokens1 = withAnd1.split(' ').filter(t => t.length > 0);
        const tokens2 = withAnd2.split(' ').filter(t => t.length > 0);

        const shorter = tokens1.length < tokens2.length ? tokens1 : tokens2;
        const longer = tokens1.length < tokens2.length ? tokens2 : tokens1;

        if (longer.slice(0, shorter.length).join(' ') === shorter.join(' ')) {
          // Check if the extra words are common location suffixes (country, etc.)
          const suffix = longer.slice(shorter.length).join(' ');
          const commonSuffixes = ['usa', 'uk', 'england', 'united kingdom', 'united states'];
          const suffixTokens = suffix.split(' ').filter(t => t.length > 0);

          // Allow if suffix is short (1-2 words) and all are common suffixes
          if (suffixTokens.length <= 2 && suffixTokens.every(t => commonSuffixes.includes(t))) {
            return true;
          }
        }

        return false;
      },

      /**
       * Check if two field values are similar enough to be grouped
       * @param {string} val1 - First field value
       * @param {string} val2 - Second field value
       * @param {string} fieldType - The type of field (publisher, location, journal)
       * @returns {boolean} - True if similar
       */
      areFieldValuesSimilar: function(val1, val2, fieldType) {
        // For journals and locations, use strict matching
        // They are proper nouns that should not be grouped unless truly equivalent
        if (fieldType === 'journal') {
          return this.areJournalsSimilar(val1, val2);
        }
        if (fieldType === 'location') {
          return this.areLocationsSimilar(val1, val2);
        }

        const norm1 = val1.toLowerCase().replace(/[&,\.\(\)]/g, ' ').replace(/\s+/g, ' ').trim();
        const norm2 = val2.toLowerCase().replace(/[&,\.\(\)]/g, ' ').replace(/\s+/g, ' ').trim();

        // Exact match
        if (norm1 === norm2) return true;

        const tokens1 = norm1.split(' ').filter(t => t.length > 0);
        const tokens2 = norm2.split(' ').filter(t => t.length > 0);

        // Check if one is a prefix of the other (main publisher name)
        // "Oxford University Press" vs "Oxford University Press USA"
        const shorter = tokens1.length < tokens2.length ? tokens1 : tokens2;
        const longer = tokens1.length < tokens2.length ? tokens2 : tokens1;

        if (longer.slice(0, shorter.length).join(' ') === shorter.join(' ')) {
          // Check if the extra words are common suffixes (country, state, etc.)
          const suffix = longer.slice(shorter.length).join(' ');
          const commonSuffixes = ['usa', 'uk', 'n y', 'ny', 'london', 'new york', 'berlin', 'paris', 'massachusetts', 'cambridge', 'oxford', 'harvard', 'mit', 'press', 'edition', 'inc', 'ltd', 'co'];
          const suffixTokens = suffix.split(' ').filter(t => t.length > 0);

          // Allow if suffix is short (1-2 words) and all are common
          if (suffixTokens.length <= 2 && suffixTokens.every(t => commonSuffixes.includes(t))) {
            return true;
          }
          // Allow if suffix looks like a location abbreviation
          if (suffixTokens.length === 1 && suffixTokens[0].length <= 4) {
            return true;
          }
        }

        // Check for "&" vs "and" substitution
        const withAnd1 = norm1.replace(/\s*&\s*/g, ' and ');
        const withAnd2 = norm2.replace(/\s*&\s*/g, ' and ');
        if (withAnd1 === withAnd2) return true;

        // Check if they're very similar (Jaccard similarity > 0.6)
        const set1 = new Set(tokens1);
        const set2 = new Set(tokens2);
        const intersection = new Set([...set1].filter(x => set2.has(x)));
        const union = new Set([...set1, ...set2]);

        if (union.size > 0) {
          const similarity = intersection.size / union.size;
          if (similarity > 0.6) return true;
        }

        return false;
      },

      /**
       * Display field normalization results
       */
      displayFieldResults: async function(results, fieldType, zoteroField, collectionId) {
        this.log('>>> displayFieldResults ENTER');
        this.log('Displaying field normalization results for ' + fieldType);

        // Store field results for later use
        this.fieldResults = results;
        this.fieldResultsZoteroField = zoteroField;
        this.fieldSelections = new Map();

        // Hide author normalization containers
        ZoteroNER_HTMLUtils.setHidden('progress-container', true);
        ZoteroNER_HTMLUtils.setHidden('summary-group', true);
        ZoteroNER_HTMLUtils.setHidden('variant-section', true);
        ZoteroNER_HTMLUtils.setHidden('empty-message', true);

        // Show field normalization section
        const fieldSection = document.getElementById('field-normalization-section');
        if (fieldSection) {
          fieldSection.style.display = 'block';
        }

        // Update title
        const titleEl = document.getElementById('field-normalization-title');
        if (titleEl) {
          const typeLabel = fieldType.charAt(0).toUpperCase() + fieldType.slice(1);
          titleEl.textContent = typeLabel + ' Normalization';
        }

        // Hide progress
        const progressEl = document.getElementById('field-progress-container');
        if (progressEl) {
          progressEl.style.display = 'none';
        }

        this.log('Field display: items=' + (results.items ? results.items.length : 'null'));

        if (!results.items || results.items.length === 0) {
          this.log('No ' + fieldType + ' values found');
          ZoteroNER_HTMLUtils.setHidden('field-summary', true);
          ZoteroNER_HTMLUtils.setHidden('field-values-column', true);
          const emptyMsg = document.getElementById('field-empty-message');
          if (emptyMsg) {
            emptyMsg.style.display = 'block';
            emptyMsg.innerHTML = '<p>No ' + fieldType + ' values found.</p>';
          }
          return;
        }

        this.log('Field display: showing ' + results.items.length + ' items');

        // Show summary
        ZoteroNER_HTMLUtils.setHidden('field-summary', false);
        ZoteroNER_HTMLUtils.setText('field-total-values', String(results.uniqueCount));

        // Populate field values
        this.log('Field display: calling populateFieldValues');
        this.populateFieldValues();
        this.log('Field display: populateFieldValues returned');

        // Update pending changes count (counts groups with multiple variants)
        this.log('Field display: calling updateFieldPendingCount');
        this.updateFieldPendingCount();

        // Enable apply buttons
        this.log('Field display: calling updateFieldApplyButtonState');
        this.updateFieldApplyButtonState();

        this.log('Field normalization UI displayed with ' + results.uniqueCount + ' unique values');
      },

      /**
       * Populate field value groups (reuses variant group structure)
       */
      populateFieldValues: function() {
        this.log('>>> populateFieldValues ENTER');
        const container = document.getElementById('field-values-container');
        if (!container) {
          this.log('ERROR: field-values-container not found');
          return false;
        }

        try {
        container.innerHTML = '';

        const items = this.fieldResults ? this.fieldResults.items : [];
        this.log('populateFieldValues: items=' + items.length);
        const totalItems = items.length;

        if (totalItems === 0) {
          ZoteroNER_HTMLUtils.setHidden('field-values-column', true);
          const emptyMsg = document.getElementById('field-empty-message');
          if (emptyMsg) {
            emptyMsg.style.display = 'block';
            emptyMsg.innerHTML = '<p>No values found.</p>';
          }
          return false;
        }

        ZoteroNER_HTMLUtils.setHidden('field-values-column', false);
        const emptyMsg = document.getElementById('field-empty-message');
        if (emptyMsg) {
          emptyMsg.style.display = 'none';
        }

        const filterQuery = (this.filterText || '').toLowerCase();
        let visibleCount = 0;

        items.forEach((item, index) => {
          // Check filter
          if (filterQuery && !item.rawValue.toLowerCase().includes(filterQuery)) {
            return;
          }

          visibleCount++;
          this.ensureFieldSelection(index, item);

          const groupEl = ZoteroNER_HTMLUtils.createElement('div', {
            class: 'field-group',
            'data-field-index': String(index)
          });

          // Header with field value
          const headerEl = ZoteroNER_HTMLUtils.createElement('div', { class: 'field-group-header' });
          const valueEl = ZoteroNER_HTMLUtils.createElement('div', { class: 'field-value-display' });
          valueEl.textContent = item.rawValue;
          headerEl.appendChild(valueEl);

          const countEl = ZoteroNER_HTMLUtils.createElement('div', { class: 'field-count' });
          const variantCount = item.variants ? item.variants.length : 1;
          countEl.textContent = item.itemCount + ' item' + (item.itemCount > 1 ? 's' : '') +
            (variantCount > 1 ? ' in ' + variantCount + ' variants' : '');
          headerEl.appendChild(countEl);

          groupEl.appendChild(headerEl);

          // Show variants if there are multiple
          if (item.variants && item.variants.length > 1) {
            const variantsSection = ZoteroNER_HTMLUtils.createElement('div', {
              class: 'field-variants-section',
              style: 'padding: 8px 12px; background: #f5f5f5; border-top: 1px solid #eee; font-size: 0.85em;'
            });
            const variantsLabel = ZoteroNER_HTMLUtils.createElement('div', {
              style: 'color: #666; margin-bottom: 4px;'
            });
            variantsLabel.textContent = 'Variants:';
            variantsSection.appendChild(variantsLabel);

            const variantsList = ZoteroNER_HTMLUtils.createElement('div', {
              style: 'display: flex; flex-wrap: wrap; gap: 4px;'
            });

            item.variantData.forEach((v, vIndex) => {
              const pill = ZoteroNER_HTMLUtils.createElement('span', {
                style: 'display: inline-block; padding: 2px 8px; background: #e0e0e0; border-radius: 12px; font-size: 0.9em;'
              });
              pill.textContent = v.rawValue + ' (' + v.itemCount + ')';
              if (vIndex === 0) {
                pill.style.fontWeight = 'bold';
                pill.style.background = '#d4edda';
              }
              variantsList.appendChild(pill);
            });

            variantsSection.appendChild(variantsList);
            groupEl.appendChild(variantsSection);
          }

          // Normalized input section
          const normSection = ZoteroNER_HTMLUtils.createElement('div', { class: 'field-normalized-section' });
          const normLabel = ZoteroNER_HTMLUtils.createElement('div', { class: 'field-normalized-label' });
          normLabel.textContent = 'Normalize all variants to:';
          normSection.appendChild(normLabel);

          const inputRow = ZoteroNER_HTMLUtils.createElement('div', {
            style: 'display: flex; gap: 8px;'
          });

          const input = document.createElement('input');
          input.type = 'text';
          input.className = 'field-normalized-input';
          input.style.cssText = 'flex: 1;';
          input.placeholder = item.rawValue;
          // Pre-fill with primary variant (first one in sorted list) as suggestion
          const primaryVariant = item.variantData && item.variantData[0] ? item.variantData[0].rawValue : item.rawValue;
          input.value = primaryVariant;
          input.setAttribute('data-idx', index);

          inputRow.appendChild(input);

          // Individual Apply button - use inline onclick
          const applyBtn = document.createElement('button');
          applyBtn.type = 'button';
          applyBtn.style.cssText = 'padding: 6px 12px; cursor: pointer;';
          applyBtn.textContent = 'Apply';
          applyBtn.onclick = function() {
            // Disable button to prevent double-click
            applyBtn.disabled = true;
            applyBtn.textContent = 'Applying...';
            // Re-enable after a short delay to allow the function to complete
            setTimeout(() => {
              window.applyFieldNormalization(index).then(() => {
                applyBtn.textContent = 'Applied';
              }).catch(() => {
                applyBtn.disabled = false;
                applyBtn.textContent = 'Apply';
              });
            }, 50);
          };
          inputRow.appendChild(applyBtn);

          normSection.appendChild(inputRow);
          groupEl.appendChild(normSection);

          container.appendChild(groupEl);
        });

        this.updateFieldFilterSummary(visibleCount, totalItems);
        return true;
        } catch (err) {
          this.log('ERROR in populateFieldValues: ' + err.message + '\n' + err.stack);
        }
      },

      /**
       * Ensure a selection exists for a field value
       */
      ensureFieldSelection: function(index, item) {
        if (!this.fieldSelections) {
          this.fieldSelections = new Map();
        }

        if (!this.fieldSelections.has(index)) {
          // Get the actual input value from the DOM - use correct selector for input with data-idx attribute
          const inputEl = document.querySelector('input[data-idx="' + index + '"]');
          const inputValue = inputEl ? inputEl.value : item.rawValue;

          // Check if there's a change to apply
          const hasChange = (inputValue !== item.rawValue);

          this.fieldSelections.set(index, {
            normalized: inputValue,
            apply: hasChange,
            rawValue: item.rawValue
          });
        }
      },

      /**
       * Handle field normalization input change
       */
      handleFieldNormalizationChange: function(index, newValue) {
        if (!this.fieldSelections) {
          this.fieldSelections = new Map();
        }

        const selection = this.fieldSelections.get(index);
        if (selection) {
          selection.normalized = newValue;
          selection.apply = (newValue !== selection.rawValue);
        }

        this.updateFieldApplyButtonState();
        this.updateFieldPendingCount();
      },

      /**
       * Select a field group (for detail view)
       */
      selectFieldGroup: function(index) {
        const item = this.fieldResults.items[index];
        if (!item) return;

        // Update selection styling
        document.querySelectorAll('.field-group').forEach(el => {
          el.classList.remove('selected');
        });
        const groupEl = document.querySelector('[data-field-index="' + index + '"]');
        if (groupEl) {
          groupEl.classList.add('selected');
        }

        // Show detail panel
        const detailPanel = document.getElementById('field-detail-panel');
        const detailTitle = document.getElementById('field-detail-title');
        const detailContext = document.getElementById('field-detail-context');
        const detailItems = document.getElementById('field-detail-items');

        if (detailTitle) {
          detailTitle.textContent = 'Items with "' + item.rawValue + '"';
        }

        if (detailContext) {
          const selection = this.fieldSelections.get(index);
          if (selection && selection.apply) {
            detailContext.innerHTML = '<p style="color: #2e7d32;">Will be normalized to: <strong>' + this.escapeHtml(selection.normalized) + '</strong></p>';
          } else {
            detailContext.innerHTML = '<p style="color: #666;">No change scheduled</p>';
          }
        }

        if (detailItems) {
          detailItems.innerHTML = '<p><em>Showing first 10 items...</em></p>';
        }
      },

      /**
       * Update field filter summary text
       */
      updateFieldFilterSummary: function(visible, total) {
        const summaryEl = document.getElementById('field-filter-summary');
        if (summaryEl) {
          if (visible === total) {
            summaryEl.textContent = 'Showing all ' + total + ' values';
          } else {
            summaryEl.textContent = 'Showing ' + visible + ' of ' + total + ' values';
          }
        }
      },

      /**
       * Update pending changes count
       * Counts groups with multiple variants as "pending" (suggested changes)
       */
      updateFieldPendingCount: function() {
        let pending = 0;
        if (this.fieldResults && this.fieldResults.items) {
          // Count groups with more than 1 variant as pending changes
          for (const item of this.fieldResults.items) {
            if (item && item.variants && item.variants.length > 1) {
              pending++;
            }
          }
        }
        const countEl = document.getElementById('field-pending-changes');
        if (countEl) {
          countEl.textContent = String(pending);
        }
      },

      /**
       * Apply a single field normalization (individual Apply button)
       */
      applySingleFieldNormalization: async function(index) {
        this.log('applySingleFieldNormalization: index=' + index);

        const group = this.fieldResults.items[index];
        if (!group) {
          this.log('ERROR: group not found for index ' + index);
          return { success: false, error: 'Group not found' };
        }

        // Get actual input value from DOM - look for input with data-idx attribute
        const inputEl = document.querySelector('input[data-idx="' + index + '"]');
        if (!inputEl) {
          this.log('ERROR: input element not found for index ' + index);
          return { success: false, error: 'Input element not found' };
        }

        const inputValue = inputEl.value.trim();
        const rawValue = group.rawValue;

        this.log('applySingleFieldNormalization: inputValue="' + inputValue + '", rawValue="' + rawValue + '"');

        // Check if there's a change - allow if input has content
        // Even if input matches rawValue, we allow it because rawValue is the suggested
        // normalized form and we want to normalize all variants TO this value
        if (!inputValue) {
          this.log('No change to apply (input empty)');
          this.alert('Field Normalizer', 'Please enter a normalized value.');
          return { success: false, error: 'No value' };
        }

        // Always allow applying - the input contains the target normalized value
        // Whether it matches rawValue or not, applying will normalize all variants to this value

        const Zotero = this.getZotero();
        if (!Zotero) {
          return { success: false, error: 'Zotero not available' };
        }

        // Confirm before applying
        const confirmed = await this.confirm(
          'Confirming Changes',
          'Normalize ' + group.itemCount + ' item(s) from:\n' +
          group.variants.map(v => '  - ' + v).join('\n') +
          '\n\nTo: ' + inputValue
        );

        if (!confirmed) return { success: true, applied: 0 };

        // Apply the change
        let applied = 0;
        try {
          if (group.variantData) {
            for (const v of group.variantData) {
              for (const item of v.items) {
                item.setField(this.fieldResultsZoteroField, inputValue);
                await item.saveTx();
                applied++;
              }
            }
          }
          this.alert('Field Normalizer', 'Successfully normalized ' + applied + ' item(s).');

          // Remove the group from the UI (like author normalization)
          const groupEl = document.querySelector('[data-field-index="' + index + '"]');
          if (groupEl) {
            groupEl.remove();
          }

          // Remove from fieldResults.items
          if (this.fieldResults && this.fieldResults.items) {
            this.fieldResults.items[index] = null; // Mark as removed
          }

          // Update counts
          this.updateFieldPendingCount();
          this.updateFieldApplyButtonState();

          // Update unique count display
          const remainingCount = this.fieldResults ? this.fieldResults.items.filter(i => i !== null).length : 0;
          const countEl = document.getElementById('field-total-values');
          if (countEl) {
            countEl.textContent = String(remainingCount);
          }

          return { success: true, applied };
        } catch (err) {
          this.alert('Field Normalizer', 'Error: ' + err.message);
          return { success: false, error: err.message };
        }
      },

      /**
       * Update field apply button state
       */
      updateFieldApplyButtonState: function() {
        let hasSelection = false;
        let hasApply = false;

        this.fieldSelections.forEach(selection => {
          hasSelection = true;
          if (selection.apply) hasApply = true;
        });

        const applyBtn = document.getElementById('apply-field-button');
        const applyAllBtn = document.getElementById('apply-all-field-button');

        if (applyBtn) applyBtn.disabled = !hasApply;
        if (applyAllBtn) applyAllBtn.disabled = !hasApply;
      },

      /**
       * Apply selected field normalizations
       */
      applySelectedFieldNormalizations: async function() {
        if (!this.fieldResults || !this.fieldResults.items) {
          return { success: false, error: 'No results to apply' };
        }

        const Zotero = this.getZotero();
        if (!Zotero) {
          return { success: false, error: 'Zotero not available' };
        }

        const changes = [];
        this.fieldSelections.forEach((selection, index) => {
          if (selection.apply) {
            const group = this.fieldResults.items[index];
            // Collect all items from all variants in this group
            const allItemIDs = [];
            if (group.variantData) {
              group.variantData.forEach(v => {
                v.items.forEach(item => {
                  allItemIDs.push(item.id);
                });
              });
            }
            changes.push({
              fromValues: group.variants, // All variant values in this group
              toValue: selection.normalized,
              itemIDs: allItemIDs
            });
          }
        });

        if (changes.length === 0) {
          return { success: true, applied: 0 };
        }

        // Apply changes
        let applied = 0;
        for (const change of changes) {
          try {
            // Get items and update them
            for (const itemID of change.itemIDs) {
              const item = await Zotero.Items.getAsync(itemID);
              if (item) {
                const currentValue = item.getField(this.fieldResultsZoteroField);
                if (change.fromValues.includes(currentValue)) {
                  item.setField(this.fieldResultsZoteroField, change.toValue);
                  await item.saveTx();
                  applied++;
                }
              }
            }
          } catch (err) {
            this.log('Error applying normalization: ' + err.message);
          }
        }

        return { success: true, applied: applied };
      },

      updateSummaryHeader: function() {
        if (!this.analysisResults) return;

        ZoteroNER_HTMLUtils.setHidden('summary-group', false);
        ZoteroNER_HTMLUtils.setText('summary-total-creators', this.analysisResults.totalUniqueSurnames || '0');
        ZoteroNER_HTMLUtils.setText('summary-variant-groups', this.analysisResults.totalVariantGroups || '0');
        ZoteroNER_HTMLUtils.setText('summary-pending-normalizations', this.analysisResults.suggestions ? this.analysisResults.suggestions.length : '0');
      },

      resetSelections: function() {
        this.userSelections = new Map();
        if (!this.analysisResults || !Array.isArray(this.analysisResults.suggestions)) {
          return;
        }

        this.analysisResults.suggestions.forEach((suggestion, index) => {
          this.ensureUserSelection(index, suggestion);
        });
      },

      ensureUserSelection: function(index, suggestion) {
        if (!this.userSelections) {
          this.userSelections = new Map();
        }

        if (!this.userSelections.has(index)) {
          // Default to NOT applying - user must explicitly select a normalization
          // This prevents accidental bulk changes to the library
          const defaultValue = this.getDefaultNormalizationValue(suggestion);
          this.userSelections.set(index, {
            mode: 'primary',
            value: defaultValue,
            variantIndex: null,
            customValue: defaultValue,
            apply: false  // Changed from true to require explicit opt-in
          });
        }

        return this.userSelections.get(index);
      },

      updateSelection: function(index, suggestion, updates) {
        const current = this.ensureUserSelection(index, suggestion);
        const next = Object.assign({}, current, updates || {});

        if (updates && Object.prototype.hasOwnProperty.call(updates, 'mode')) {
          if (updates.mode === 'keep') {
            next.apply = false;
            next.variantIndex = null;
          } else {
            next.apply = true;
            if (updates.mode !== 'variant') {
              next.variantIndex = null;
            }
          }
        }

        if (updates && Object.prototype.hasOwnProperty.call(updates, 'variantIndex') && next.mode !== 'variant') {
          next.variantIndex = updates.variantIndex;
        }

        if (updates && Object.prototype.hasOwnProperty.call(updates, 'customValue')) {
          next.customValue = updates.customValue;
          if (next.mode === 'custom' && !Object.prototype.hasOwnProperty.call(updates, 'value')) {
            next.value = updates.customValue;
          }
        }

        if (updates && Object.prototype.hasOwnProperty.call(updates, 'value')) {
          next.value = updates.value;
        }

        this.userSelections.set(index, next);
        this.refreshApplyButtonState();
        return next;
      },

      refreshApplyButtonState: function() {
        this.setApplyEnabled(this.hasSelectedNormalizations());
      },

      hasSelectedNormalizations: function() {
        if (!this.analysisResults || !Array.isArray(this.analysisResults.suggestions) || this.analysisResults.suggestions.length === 0) {
          return false;
        }

        if (!this.userSelections || this.userSelections.size === 0) {
          return true;
        }

        for (let i = 0; i < this.analysisResults.suggestions.length; i++) {
          const selection = this.userSelections.get(i);
          if (!selection || selection.apply !== false) {
            return true;
          }
        }

        return false;
      },

      // Per-card apply: apply a single suggestion and remove its card from the UI
      applyCard: async function(index, suggestion) {
        this.log('applyCard called: index=' + index + ', suggestion.type=' + (suggestion ? suggestion.type : 'null'));
        const selection = this.ensureUserSelection(index, suggestion);
        if (!selection) {
          this.log('applyCard: no selection found, returning false');
          return false;
        }

        this.log('applyCard: selection.mode=' + selection.mode + ', apply=' + selection.apply + ', value=' + selection.value + ', customValue=' + selection.customValue);

        // Check if there's a valid selection to apply
        const normalizedValue = (selection.value || selection.customValue || '').trim();
        this.log('applyCard: normalizedValue="' + normalizedValue + '"');

        // For per-card Apply button: if no explicit apply flag but we have a normalized value, allow it
        // This allows the button to work even if user hasn't explicitly selected a radio option yet
        if (!normalizedValue) {
          this.log('applyCard: early return - no normalized value');
          return false;
        }

        if (selection.apply === false && selection.mode !== 'primary') {
          this.log('applyCard: early return - apply=false and not in primary mode');
          return false;
        }

        // Prepare this specific suggestion for application
        const preparedSuggestion = Object.assign({}, suggestion);
        preparedSuggestion.originalPrimary = suggestion.primary;
        preparedSuggestion.userSelection = Object.assign({}, selection);
        preparedSuggestion.variants = (suggestion.variants || []).map(variant => {
          const variantClone = Object.assign({}, variant);
          if (Array.isArray(variantClone.items)) {
            variantClone.items = variantClone.items.map(item => Object.assign({}, item));
          }
          return variantClone;
        });

        // Update the primary value with the selected normalization
        preparedSuggestion.primary = normalizedValue;

        if (selection.mode === 'variant' && typeof selection.variantIndex === 'number') {
          preparedSuggestion.selectedVariant = preparedSuggestion.variants[selection.variantIndex] || null;
        }

        if (selection.mode === 'custom') {
          preparedSuggestion.customNormalization = normalizedValue;
        }

        // Mark as applied
        selection.applied = true;
        this.log('applyCard: marked as applied, looking for card');

        // Apply the normalization to the database
        try {
          // Try to use the main window's Zotero API which has proper Zotero context
          let results;
          const zotero = ZoteroNER_ZoteroAPI.getZotero();
          this.log('applyCard: zotero available=' + (zotero ? 'yes' : 'no'));
          
          const nameNormalizer = ZoteroNER_ZoteroAPI.getNameNormalizer();
          this.log('applyCard: nameNormalizer available=' + (nameNormalizer ? 'yes' : 'no'));
          this.log('applyCard: nameNormalizer.applyNormalizationSuggestions=' + (nameNormalizer && typeof nameNormalizer.applyNormalizationSuggestions));

          if (nameNormalizer && typeof nameNormalizer.applyNormalizationSuggestions === 'function') {
            this.log('applyCard: calling applyNormalizationSuggestions with 1 suggestion');
            results = await nameNormalizer.applyNormalizationSuggestions(
              [preparedSuggestion],  // Apply only this one suggestion
              false,
              {
                declinedSuggestions: [],
                progressCallback: (event) => this.handleApplyProgress(event)
              }
            );

            this.log('applyCard: normalization applied successfully, results:', results);
          } else {
            this.log('applyCard: ERROR - nameNormalizer not available or missing method');
            throw new Error('Zotero NameNormalizer API not available');
          }
        } catch (error) {
          this.log('applyCard: EXCEPTION caught: ' + error.message);
          console.error('Error applying normalization in applyCard:', error);
          this.alert('Error', 'Failed to apply normalization: ' + error.message);
          return false;
        }

        // Find and remove the card
        const card = document.querySelector(`.variant-group[data-suggestion-index="${index}"]`);
        this.log('applyCard: card found=' + (card ? 'yes' : 'no'));

        if (card) {
          this.log('applyCard: removing card with animation');
          card.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
          card.style.opacity = '0';
          card.style.transform = 'translateX(-20px)';
          setTimeout(() => {
            this.log('applyCard: timeout fired, removing card DOM element');
            card.remove();
            this.checkAllCardsApplied();
          }, 300);
        }

        return true;
      },

      // Mark card as "not variants" (distinct authors) and remove from UI
      markNotVariants: function(index, suggestion) {
        const selection = this.ensureUserSelection(index, suggestion);
        if (!selection) {
          return false;
        }

        // Mark as declined (not variants)
        selection.apply = false;
        selection.notVariants = true;

        // Store user preference to never propose this normalization again
        this.storeNotVariantsPreference(suggestion);

        // Find and remove the card with animation
        const card = document.querySelector(`.variant-group[data-suggestion-index="${index}"]`);
        if (card) {
          card.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
          card.style.opacity = '0';
          card.style.transform = 'translateX(-20px)';
          setTimeout(() => {
            card.remove();
            this.checkAllCardsApplied();
          }, 300);
        }

        return true;
      },

      // Store user preference for "not variants" (distinct authors)
      storeNotVariantsPreference: function(suggestion) {
        // Create a unique key for this suggestion based on its characteristics
        const key = this.getNotVariantsKey(suggestion);

        // Get existing preferences
        const existingPrefs = this.getNotVariantsPreferences();
        if (!existingPrefs.includes(key)) {
          existingPrefs.push(key);
          this.saveNotVariantsPreferences(existingPrefs);
        }

        this.log('Stored "not variants" preference for: ' + key);
      },

      // Generate a unique key for identifying this suggestion
      // Sanitize values to prevent special characters from breaking the key format
      getNotVariantsKey: function(suggestion) {
        const sanitize = function(value) {
          return (value || '').replace(/[:\\/\n\r\t]/g, '_').substring(0, 100);
        };
        if (suggestion.type === 'given-name') {
          return `given-name:${sanitize(suggestion.surname)}:${sanitize(suggestion.primary)}`;
        }
        return `surname:${sanitize(suggestion.primary)}`;
      },

      // Get stored "not variants" preferences
      getNotVariantsPreferences: function() {
        try {
          const prefs = window.localStorage.getItem('zotero-ner-not-variants');
          return prefs ? JSON.parse(prefs) : [];
        } catch (e) {
          return [];
        }
      },

      // Save "not variants" preferences
      saveNotVariantsPreferences: function(prefs) {
        try {
          const json = JSON.stringify(prefs);
          window.localStorage.setItem('zotero-ner-not-variants', json);
        } catch (e) {
          this.log('Failed to save not-variants preferences: ' + e.message);
          // localStorage may fail in private browsing or when quota exceeded
          // The preference won't persist, but the UI interaction still works
        }
      },

      // Check if all cards have been applied/declined
      checkAllCardsApplied: function() {
        const remainingCards = document.querySelectorAll('.variant-group');
        if (remainingCards.length === 0) {
          // All cards have been handled - update empty message
          const emptyMsg = ZoteroNER_HTMLUtils.getElement('empty-message');
          if (emptyMsg) {
            const content = document.createElement('div');
            content.className = 'empty-message-content';
            const p = document.createElement('p');
            p.textContent = 'All variant groups have been processed. You can close this dialog.';
            content.appendChild(p);
            emptyMsg.innerHTML = '';
            emptyMsg.appendChild(content);
            emptyMsg.style.display = 'block';
          }
          // Disable the main apply buttons since there are no more cards
          this.setApplyEnabled(false);
        }
      },

      // Build the per-card action buttons (Apply and Not Variants)
      buildCardActions: function(index, suggestion) {
        this.log('buildCardActions: creating buttons for index=' + index);
        const container = ZoteroNER_HTMLUtils.createElement('div', { class: 'card-actions' });

        // Apply button
        const applyBtn = ZoteroNER_HTMLUtils.createElement('button', {
          type: 'button',
          class: 'apply-btn',
          'data-suggestion-index': String(index)
        });
        applyBtn.textContent = 'Apply';

        // Not Variants button (Distinct Authors)
        const notVariantsBtn = ZoteroNER_HTMLUtils.createElement('button', {
          type: 'button',
          class: 'not-variants-btn',
          'data-suggestion-index': String(index),
          title: 'Mark these as distinct authors - this will not be proposed again'
        });
        notVariantsBtn.textContent = 'Not Variants';

        // Add click handlers
        applyBtn.addEventListener('click', async (event) => {
          this.log('Apply button clicked for index=' + index);
          // Prevent multiple clicks during processing
          applyBtn.disabled = true;
          applyBtn.textContent = 'Applying...';

          try {
            // Ensure the selection is marked as apply=true before applying
            const currentSelection = this.ensureUserSelection(index, suggestion);
            if (currentSelection) {
              currentSelection.apply = true;
            }
            await this.applyCard(index, suggestion);
          } finally {
            // Re-enable button after processing
            applyBtn.disabled = false;
            applyBtn.textContent = 'Apply';
          }
        });

        notVariantsBtn.addEventListener('click', (event) => {
          this.markNotVariants(index, suggestion);
        });

        container.appendChild(applyBtn);
        container.appendChild(notVariantsBtn);

        return container;
      },

      getDefaultNormalizationValue: function(suggestion) {
        if (!suggestion) {
          return '';
        }

        if (suggestion.type === 'given-name') {
          if (suggestion.recommendedFullName) {
            return suggestion.recommendedFullName;
          }
        }

        if (typeof suggestion.primary === 'string') {
          // For surname suggestions, return a title-cased display value
          return suggestion.type === 'surname'
            ? this.formatSurnameKey(suggestion.primary.trim())
            : suggestion.primary.trim();
        }

        return this.formatNameString(suggestion.primary);
      },

      titleCase: function(value) {
        if (!value || typeof value !== 'string') {
          return '';
        }

        const cleaned = value.normalize('NFC').replace(/[\u200B-\u200D\uFEFF]/g, '');

        // Surname prefixes that should remain lowercase:
        // - Dutch: van, de, der, den, la, le, het, op, ten, ter, aan, in, uit
        // - German: von
        // - Spanish: y (conjunction "and")
        const lowercasePrefixes = [
          'van', 'de', 'la', 'le', 'het', 'op', 'ten', 'ter', 'aan', 'in', 'uit',
          'von'
        ];

        // Multi-word prefixes (Dutch/German)
        const multiWordPrefixes = [
          'van der', 'van de', 'van den', 'van het',
          'von der', 'von dem'
        ];

        // Spanish conjunction that stays lowercase
        const spanishConjunction = 'y';

        // Build a map of words to skip (keep lowercase)
        const skipMap = new Set();

        // First pass: identify multi-word prefixes
        const words = cleaned.split(/\s+/);
        for (let i = 0; i < words.length; i++) {
          const lowerWord = words[i].toLowerCase();
          const combinedTwo = lowerWord + ' ' + (words[i + 1] || '').toLowerCase();

          // Check for multi-word prefix
          if (multiWordPrefixes.includes(combinedTwo)) {
            skipMap.add(i);
            skipMap.add(i + 1);
          }
        }

        // Second pass: process each word
        return words
          .filter(Boolean)
          .map((part, index) => {
            const lowerPart = part.toLowerCase();

            // Skip words identified in multi-word prefix detection
            if (skipMap.has(index)) {
              return lowerPart;
            }

            // Single-word prefix check (only if not already part of multi-word prefix)
            if (lowercasePrefixes.includes(lowerPart)) {
              return lowerPart;
            }

            // Spanish conjunction "y" (and) - should stay lowercase
            if (lowerPart === spanishConjunction) {
              return lowerPart;
            }

            // Handle "Mc" prefix - always capitalize next letter (Mc is consistently followed by capital)
            if (lowerPart.startsWith('mc') && lowerPart.length > 2) {
              return 'Mc' + lowerPart.substring(2).charAt(0).toUpperCase() + lowerPart.substring(3);
            }

            // Handle standalone "mc"
            if (lowerPart === 'mc') {
              return 'Mc';
            }

            // Handle "Mac" prefix
            // Scottish convention: capitalize first letter after "Mac" (MacDonald, MacArthur)
            // BUT preserve anglicized forms (Macdonald, Macarthur)
            // EXCEPTION: Names that start with "Mac" but should use standard title-case
            const macExceptions = ['machamer'];
            if (macExceptions.includes(lowerPart)) {
              // Standard title-case for exceptions
              return lowerPart.replace(/(^|['`-])(.)/gu, (match, prefix, letter) => prefix + letter.toUpperCase());
            }
            if (lowerPart.startsWith('mac') && lowerPart.length > 3) {
              const afterMac = lowerPart.substring(3);
              const originalAfterMac = part.substring(3, 4);

              // Check if this is an all-caps input
              const isAllCaps = part === part.toUpperCase() && part !== part.toLowerCase();
              if (isAllCaps) {
                // For all-caps, use standard pattern (capitalize after Mac)
                return 'Mac' + afterMac.charAt(0).toUpperCase() + afterMac.substring(1);
              } else if (originalAfterMac === originalAfterMac.toUpperCase() && originalAfterMac !== originalAfterMac.toLowerCase()) {
                // Original had capital after Mac (MacDonald) - preserve
                return 'Mac' + afterMac.charAt(0).toUpperCase() + afterMac.substring(1);
              } else {
                // Original had lowercase after Mac (Macdonald) - preserve anglicized form
                return 'Mac' + afterMac;
              }
            }

            // Handle standalone "mac"
            if (lowerPart === 'mac') {
              return 'Mac';
            }

            // Standard title-case: first letter capital after prefix/punctuation
            return lowerPart.replace(/(^|['`-])(.)/gu, (match, prefix, letter) => prefix + letter.toUpperCase());
          })
          .join(' ');
      },

      getGroupTitle: function(index, suggestion) {
        const groupNumber = index + 1;
        if (suggestion.type === 'given-name') {
          const surname = this.titleCase(suggestion.surname || suggestion.primary || '');
          const safeSurname = this.escapeHTML(surname);
          return surname
            ? `Given name variants <span class="surname-variant">${safeSurname}</span>`
            : `Given name variants Group ${groupNumber}`;
        }

        const surname = this.titleCase(suggestion.primary || '');
        const safeSurname = this.escapeHTML(surname);
        return surname
          ? `Surname variants <span class="surname-variant">${safeSurname}</span>`
          : `Variant Group ${groupNumber}`;
      },

      buildRecommendedHTML: function(suggestion, recommendedValue) {
        const rawValue = recommendedValue || '';
        const safeValue = this.escapeHTML(rawValue);
        if (suggestion.type === 'given-name') {
          return 'Recommended full name: <strong>' + safeValue + '</strong>';
        }
        // For surname recommendations, display a title-cased, escaped version
        const display = this.formatSurnameKey(rawValue);
        return 'Recommended normalization: <strong>' + display + '</strong>';
      },

      getVariantSummaryText: function(suggestion) {
        const variantCount = Array.isArray(suggestion.variants) ? suggestion.variants.length : 0;

        if (suggestion.type === 'given-name') {
          const total = suggestion.totalFrequency || 0;
          return `${variantCount} given-name variants Â· ${total} occurrences`;
        }

        const totalOccurrences = (suggestion.variants || []).reduce((sum, variant) => sum + (variant.frequency || 0), 0);
        return `${variantCount} surname spellings Â· ${totalOccurrences} occurrences`;
      },

      getVariantDisplayLabel: function(suggestion, variant) {
        if (!variant) {
          return '';
        }

        const frequency = typeof variant.frequency === 'number' ? ` (${variant.frequency})` : '';

        if (suggestion.type === 'given-name') {
          const name = variant.firstName || variant.name || '';
          return `${this.titleCase(name)}${frequency}`;
        }

        // Preserve original casing of the variant name - don't title-case it
        const surnameDisplay = typeof variant.name === 'string'
          ? variant.name
          : this.formatNameString(variant.name);
        return `${surnameDisplay}${frequency}`;
      },

      getVariantSelectionLabel: function(suggestion, variant) {
        if (!variant) {
          return '';
        }

        const occurrences = typeof variant.frequency === 'number' ? `${variant.frequency} occurrences` : 'variant';

        if (suggestion.type === 'given-name') {
          return `Normalize to ${this.titleCase(variant.firstName || variant.name || '')} (${occurrences})`;
        }

        // Preserve original casing for surname variants
        const variantSurname = typeof variant.name === 'string'
          ? variant.name
          : this.formatNameString(variant.name);
        return `Normalize to ${variantSurname} (${occurrences})`;
      },

      buildVariantListElement: function(index, suggestion) {
        const wrapper = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-list' });
        const recommendedValue = (this.getDefaultNormalizationValue(suggestion) || '').trim().toLowerCase();

        (suggestion.variants || []).forEach((variant, variantIndex) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'variant-pill';
          button.dataset.suggestionIndex = String(index);
          button.dataset.variantIndex = String(variantIndex);
          button.textContent = this.getVariantDisplayLabel(suggestion, variant);
          const variantValue = (typeof variant.name === 'string' && variant.name)
            ? variant.name.trim().toLowerCase()
            : (variant.firstName ? `${variant.firstName} ${variant.lastName || suggestion.primary || ''}`.trim().toLowerCase() : '');
          if (recommendedValue && variantValue && variantValue === recommendedValue) {
            button.classList.add('recommended');
          }
          button.addEventListener('click', () => {
            this.showVariantDetails(index, variantIndex, suggestion, { suppressHighlight: false });
          });
          wrapper.appendChild(button);
        });

        return wrapper;
      },

      findRecommendedVariantIndex: function(suggestion) {
        if (!suggestion || !Array.isArray(suggestion.variants) || suggestion.variants.length === 0) {
          return null;
        }

        const recommendedValue = (this.getDefaultNormalizationValue(suggestion) || '').trim().toLowerCase();
        if (!recommendedValue) {
          return null;
        }

        for (let i = 0; i < suggestion.variants.length; i++) {
          const variant = suggestion.variants[i];
          const variantValue = (typeof variant.name === 'string' && variant.name)
            ? variant.name.trim().toLowerCase()
            : (variant.firstName ? `${variant.firstName} ${variant.lastName || suggestion.primary || ''}`.trim().toLowerCase() : '');

          if (variantValue && variantValue === recommendedValue) {
            return i;
          }
        }

        return null;
      },

      highlightVariantPills: function(suggestionIndex, variantIndex) {
        const pills = document.querySelectorAll('.variant-pill[data-suggestion-index]');
        pills.forEach(pill => {
          const matches = pill.dataset.suggestionIndex === String(suggestionIndex) && pill.dataset.variantIndex === String(variantIndex);
          pill.classList.toggle('active', matches);
        });
      },

      getVariantDetailTitle: function(suggestion, variant) {
        const label = this.getVariantDisplayLabel(suggestion, variant).replace(/\s+\([^)]*\)$/, '');
        const safeLabel = this.escapeHTML(label);
        if (suggestion.type === 'given-name') {
          return `Occurrences for ${safeLabel}`;
        }
        return `Occurrences for <span class="surname-variant">${safeLabel}</span>`;
      },

      showVariantDetails: function(suggestionIndex, variantIndex, suggestion, options = {}) {
        const variant = suggestion.variants[variantIndex];
        const items = Array.isArray(variant?.items) ? variant.items : [];

        if (!suggestion || !Array.isArray(suggestion.variants)) {
          this.clearVariantDetails();
          return;
        }

        if (!variant) {
          this.clearVariantDetails();
          return;
        }

        this.variantDetailState = { suggestionIndex, variantIndex };

        if (!options.suppressHighlight) {
          this.highlightVariantPills(suggestionIndex, variantIndex);
        }

        const panel = ZoteroNER_HTMLUtils.getElement('variant-detail-panel');
        if (!panel) {
          return;
        }

        // Remove placeholder classes so the detail view replaces the empty message
        panel.classList.remove('empty');
        panel.classList.remove('hidden');
        panel.style.display = 'block';

        // Scroll the column so the selected variant group aligns with the detail panel
        const groupContainer = ZoteroNER_HTMLUtils.getElement('variant-groups-container');
        const variantGroup = groupContainer?.querySelector(`[data-suggestion-index="${suggestionIndex}"]`);
        const scrollContainer = ZoteroNER_HTMLUtils.getElement('variant-groups-column');
        if (variantGroup && scrollContainer) {
          variantGroup.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        const titleEl = ZoteroNER_HTMLUtils.getElement('variant-detail-title');
        if (titleEl) {
          titleEl.innerHTML = this.getVariantDetailTitle(suggestion, variant);
        }

        const contextEl = ZoteroNER_HTMLUtils.getElement('variant-detail-context');
        if (contextEl) {
          const pieces = [];
          const freq = typeof variant.frequency === 'number' ? variant.frequency : 0;
          pieces.push(`Occurrences: ${freq}`);
          if (suggestion.type === 'given-name') {
            pieces.push(`Surname: ${this.titleCase(suggestion.surname || suggestion.primary || '')}`);
          }
          contextEl.textContent = pieces.join(' Â· ');
        }

        const listEl = ZoteroNER_HTMLUtils.getElement('variant-detail-items');
        if (listEl) {
          listEl.innerHTML = '';
          const items = Array.isArray(variant.items) ? variant.items : [];

          if (items.length === 0) {
            const emptyLi = document.createElement('li');
            emptyLi.className = 'variant-meta';
            emptyLi.textContent = 'No items found for this variant.';
            listEl.appendChild(emptyLi);
          } else {
            items.forEach(item => {
              const li = document.createElement('li');
              const html = this.formatItemSummaryHTML(item);
              li.innerHTML = html;
              listEl.appendChild(li);
            });

            if ((variant.frequency || 0) > items.length) {
              const moreLi = document.createElement('li');
              moreLi.className = 'variant-meta';
              moreLi.textContent = `â€¦and ${(variant.frequency || 0) - items.length} more entries`;
              listEl.appendChild(moreLi);
            }
          }
        }
      },

      clearVariantDetails: function() {
        this.variantDetailState = null;
        const panel = ZoteroNER_HTMLUtils.getElement('variant-detail-panel');
        if (panel) {
          panel.style.display = 'none';
          panel.classList.add('empty');
          panel.classList.add('hidden');
        }

        const contextEl = ZoteroNER_HTMLUtils.getElement('variant-detail-context');
        if (contextEl) {
          contextEl.textContent = '';
        }

        const listEl = ZoteroNER_HTMLUtils.getElement('variant-detail-items');
        if (listEl) {
          listEl.innerHTML = '';
        }

        const pills = document.querySelectorAll('.variant-pill');
        pills.forEach(pill => pill.classList.remove('active'));
      },

      formatItemSummary: function(item) {
        if (!item) {
          return 'Untitled item';
        }

        const title = item.title || 'Untitled';
        const year = item.year || item.date || '';
        const author = item.author || '';

        // Build display: Author - Title (Year) or Title (Year) if no author
        const yearStr = year ? ` (${year})` : '';
        const authorStr = author ? `${author} â€” ` : '';

        // Truncate title if too long
        const maxTitleLength = 100;
        const trimmedTitle = title.length > maxTitleLength ? title.slice(0, maxTitleLength) + 'â€¦' : title;

        return authorStr + trimmedTitle + yearStr;
      },

      formatItemSummaryHTML: function(item) {
        if (!item) {
          return '<span class="item-title">Untitled item</span>';
        }

        const title = item.title || 'Untitled';
        const year = item.year || item.date || '';
        const author = item.author || '';
        const itemKey = item.key || '';

        // Truncate title if too long
        const maxTitleLength = 100;
        const trimmedTitle = title.length > maxTitleLength ? title.slice(0, maxTitleLength) + 'â€¦' : title;

        // Escape HTML for safe rendering
        const safeTitle = this.escapeHTML(trimmedTitle);
        const safeAuthor = this.escapeHTML(author);
        const safeYear = this.escapeHTML(year);

        let html = '<div class="item-details">';

        if (safeAuthor) {
          html += `<span class="item-author">${safeAuthor}</span>`;
        }

        // Make title clickable with zotero://select/ URL
        if (itemKey) {
          html += `<a href="#" class="item-link" data-item-key="${this.escapeHTML(itemKey)}">${safeTitle}</a>`;
        } else {
          html += `<span class="item-title">${safeTitle}</span>`;
        }

        if (safeYear) {
          html += `<span class="item-year">(${safeYear})</span>`;
        }

        html += '</div>';
        return html;
      },

      buildSelectionControls: function(index, suggestion) {
        const choiceGroup = ZoteroNER_HTMLUtils.createElement('div', { class: 'radio-group', id: 'ner-variant-group-choice-' + index });
        const selection = this.ensureUserSelection(index, suggestion);
        const recommendedValue = this.getDefaultNormalizationValue(suggestion);
        const recommendedLabelText = suggestion.type === 'given-name'
          ? (recommendedValue ? `Use recommended full name: ${recommendedValue}` : 'Use recommended full name')
          : (recommendedValue ? `Use recommended normalization: ${recommendedValue}` : 'Use recommended normalization');

        const primaryRow = this.createSelectionRadioRow(index, suggestion, {
          mode: 'primary',
          label: recommendedLabelText,
          checked: selection.mode === 'primary',
          selectionUpdate: () => ({ mode: 'primary', value: recommendedValue, apply: true })
        });
        choiceGroup.appendChild(primaryRow);

        const keepRow = this.createSelectionRadioRow(index, suggestion, {
          mode: 'keep',
          label: 'Keep existing forms as-is',
          checked: selection.mode === 'keep',
          selectionUpdate: () => ({ mode: 'keep', apply: false })
        });
        choiceGroup.appendChild(keepRow);

        (suggestion.variants || []).forEach((variant, variantIndex) => {
          const label = this.getVariantSelectionLabel(suggestion, variant);
          const variantRow = this.createSelectionRadioRow(index, suggestion, {
            mode: 'variant',
            label,
            checked: selection.mode === 'variant' && selection.variantIndex === variantIndex,
            onSelect: () => {
              this.showVariantDetails(index, variantIndex, suggestion);
            },
            selectionUpdate: () => {
              const variantValue = (typeof variant.name === 'string' && variant.name)
                ? variant.name.trim()
                : (variant.firstName ? `${variant.firstName} ${variant.lastName || suggestion.primary || ''}`.trim() : '');
              return {
                mode: 'variant',
                variantIndex,
                value: variantValue,
                apply: true
              };
            }
          });
          choiceGroup.appendChild(variantRow);
        });

        const customRow = this.createCustomSelectionRow(index, suggestion, selection, recommendedValue);
        choiceGroup.appendChild(customRow);

        return choiceGroup;
      },

      createSelectionRadioRow: function(index, suggestion, option) {
        const row = ZoteroNER_HTMLUtils.createElement('div');
        const radioId = `choice-${index}-${option.mode}-${Math.random().toString(16).slice(2, 7)}`;
        const radio = ZoteroNER_HTMLUtils.createElement('input', {
          type: 'radio',
          id: radioId,
          name: `choice-${index}`,
          value: option.mode
        });
        if (option.checked) {
          radio.checked = true;
        }

        radio.addEventListener('change', () => {
          if (typeof option.onSelect === 'function') {
            option.onSelect();
          }
          const update = typeof option.selectionUpdate === 'function'
            ? option.selectionUpdate()
            : { mode: option.mode };
          this.updateSelection(index, suggestion, update);
        });

        const label = ZoteroNER_HTMLUtils.createElement('label', { for: radioId });
        label.textContent = option.label;

        row.appendChild(radio);
        row.appendChild(label);
        return row;
      },

      createCustomSelectionRow: function(index, suggestion, selection, defaultValue) {
        const container = ZoteroNER_HTMLUtils.createElement('div', { class: 'custom-normalization' });
        const radioId = `choice-${index}-custom`;
        const radio = ZoteroNER_HTMLUtils.createElement('input', {
          type: 'radio',
          id: radioId,
          name: `choice-${index}`,
          value: 'custom'
        });
        radio.checked = selection.mode === 'custom';

        const label = ZoteroNER_HTMLUtils.createElement('label', { for: radioId });
        label.textContent = 'Use a custom normalization:';

        const input = document.createElement('input');
        input.type = 'text';
        input.value = selection.customValue || defaultValue || '';
        input.disabled = selection.mode !== 'custom';
        input.placeholder = defaultValue || 'Enter normalized name';

        radio.addEventListener('change', () => {
          input.disabled = !radio.checked;
          if (radio.checked) {
            this.updateSelection(index, suggestion, {
              mode: 'custom',
              value: input.value,
              customValue: input.value,
              variantIndex: null,
              apply: true
            });
          }
        });

        input.addEventListener('input', (event) => {
          const value = event.target.value;
          const current = this.ensureUserSelection(index, suggestion);
          const updates = { customValue: value };
          if (current.mode === 'custom') {
            updates.value = value;
          }
          this.updateSelection(index, suggestion, updates);
        });

        input.addEventListener('focus', () => {
          if (!radio.checked) {
            radio.checked = true;
            radio.dispatchEvent(new Event('change'));
          }
        });

        container.appendChild(radio);
        container.appendChild(label);
        container.appendChild(input);

        return container;
      },

      buildRelatedGivenNamesSection: function(suggestion) {
        const wrapper = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-meta' });
        const variants = suggestion.relatedGivenNameVariants || [];
        if (!variants.length) {
          return wrapper;
        }

        const intro = document.createElement('div');
        intro.textContent = 'Associated given name variants:';
        wrapper.appendChild(intro);

        const list = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-list' });
        variants.forEach(variant => {
          const pill = document.createElement('span');
          pill.className = 'variant-pill';
          pill.textContent = `${this.titleCase(variant.firstName || '')} (${variant.frequency || 0})`;
          list.appendChild(pill);
        });

        wrapper.appendChild(list);
        return wrapper;
      },

      populateVariantGroupList: function() {
        const container = ZoteroNER_HTMLUtils.getElement('variant-groups-container');
        if (!container) {
          return false;
        }

        container.innerHTML = '';

        const suggestions = (this.analysisResults && Array.isArray(this.analysisResults.suggestions))
          ? this.analysisResults.suggestions
          : [];
        const totalSuggestions = suggestions.length;

        if (totalSuggestions === 0) {
          this.showEmptyState('No variant groups were detected for the scanned surnames.');
          return false;
        }

        const emptyMsg = ZoteroNER_HTMLUtils.getElement('empty-message');
        if (emptyMsg) {
          emptyMsg.style.display = 'none';
        }

        const renderedIndexes = [];
        let visibleCount = 0;

        suggestions.forEach((suggestion, index) => {
          if (!suggestion) {
            return;
          }
          if (!this.matchesFilter(suggestion)) {
            return;
          }

          this.log('populateVariantGroupList: rendering card for index=' + index + ', type=' + suggestion.type);
          visibleCount++;
          renderedIndexes.push(index);
          this.ensureUserSelection(index, suggestion);
          const groupElement = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-group', 'data-suggestion-index': String(index) });

          const header = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-group-header' });
          const title = ZoteroNER_HTMLUtils.createElement('h3');
          title.innerHTML = this.getGroupTitle(index, suggestion);
          header.appendChild(title);

          const summary = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-group-summary' });
          summary.textContent = this.getVariantSummaryText(suggestion);
          header.appendChild(summary);

          const recommendedValue = this.getDefaultNormalizationValue(suggestion);
          if (recommendedValue) {
            const recommended = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-meta' });
            recommended.innerHTML = this.buildRecommendedHTML(suggestion, recommendedValue);
            header.appendChild(recommended);
          }

          groupElement.appendChild(header);

          const variantsContainer = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-group-variants' });
          const variantList = this.buildVariantListElement(index, suggestion);

          if (variantList && variantList.childElementCount > 0) {
            variantsContainer.appendChild(variantList);
          } else {
            const emptyVariants = document.createElement('div');
            emptyVariants.className = 'variant-meta';
            emptyVariants.textContent = 'No variants detected.';
            variantsContainer.appendChild(emptyVariants);
          }

          const controls = this.buildSelectionControls(index, suggestion);
          variantsContainer.appendChild(controls);

          if (suggestion.type === 'given-name') {
            const relatedSection = this.buildRelatedGivenNamesSection(suggestion);
            if (relatedSection && relatedSection.childNodes.length) {
              variantsContainer.appendChild(relatedSection);
            }
          }

          // Add per-card action buttons
          const cardActions = this.buildCardActions(index, suggestion);
          variantsContainer.appendChild(cardActions);

          groupElement.appendChild(variantsContainer);
          container.appendChild(groupElement);
        });

        this.updateFilterSummary(visibleCount, totalSuggestions);

        if (visibleCount === 0) {
          const noMatches = document.createElement('div');
          noMatches.className = 'empty-message';
          noMatches.textContent = this.filterText
            ? 'No variant groups match your filter. Adjust your search to see results.'
            : 'No variant groups were detected for the scanned surnames.';
          container.appendChild(noMatches);
          this.clearVariantDetails();
          this.refreshApplyButtonState();
          return false;
        }

        const { variantDetailState } = this;
        let detailSuggestionIndex = null;
        let detailVariantIndex = null;

        if (variantDetailState && renderedIndexes.includes(variantDetailState.suggestionIndex)) {
          detailSuggestionIndex = variantDetailState.suggestionIndex;
          detailVariantIndex = typeof variantDetailState.variantIndex === 'number'
            ? variantDetailState.variantIndex
            : null;
        } else {
          this.variantDetailState = null;
          detailSuggestionIndex = renderedIndexes[0];
        }

        const detailSuggestion = suggestions[detailSuggestionIndex];
        if (detailSuggestion && Array.isArray(detailSuggestion.variants) && detailSuggestion.variants.length > 0) {
          let variantIndexToShow = null;
          if (detailVariantIndex !== null && detailSuggestion.variants[detailVariantIndex]) {
            variantIndexToShow = detailVariantIndex;
          } else {
            const defaultVariantIndex = this.findRecommendedVariantIndex(detailSuggestion);
            variantIndexToShow = defaultVariantIndex !== null ? defaultVariantIndex : 0;
          }
          this.showVariantDetails(detailSuggestionIndex, variantIndexToShow, detailSuggestion);
        } else {
          this.clearVariantDetails();
        }

        this.refreshApplyButtonState();
        return true;
      },

      formatNameString: function(name) {
        if (typeof name === 'string') return name.trim();
        if (name && typeof name === 'object') {
          return `${name.firstName || ''} ${name.lastName || ''}`.trim();
        }
        return '';
      },

      escapeHTML: function(value) {
        if (typeof value !== 'string') {
          return '';
        }
        const map = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;'
        };
        return value.replace(/[&<>"']/g, (char) => map[char]);
      },

      formatSurnameKey: function(value) {
        if (!value || typeof value !== 'string') {
          return '';
        }
        const titleCased = this.titleCase(value);
        return this.escapeHTML(titleCased);
      },

      setApplyEnabled: function(enabled) {
        const applyButton = ZoteroNER_HTMLUtils.getElement('apply-button');
        const applyAllButton = ZoteroNER_HTMLUtils.getElement('apply-all-button');
        if (applyButton) applyButton.disabled = !enabled || this.isProcessing;
        if (applyAllButton) applyAllButton.disabled = !enabled || this.isProcessing;
      },

      setDialogBusy: function(isBusy) {
        this.isProcessing = isBusy;
        ZoteroNER_HTMLUtils.setHidden('progress-container', !isBusy);

        const applyButton = ZoteroNER_HTMLUtils.getElement('apply-button');
        const applyAllButton = ZoteroNER_HTMLUtils.getElement('apply-all-button');
        if (applyButton) applyButton.disabled = isBusy;
        if (applyAllButton) applyAllButton.disabled = isBusy;

        this.updateProgress();
      },

      handleApplyProgress: function(event) {
        if (!event) {
          return;
        }

        const nextState = Object.assign({}, this.currentProgressState || {});

        if (typeof event.stage === 'string') {
          nextState.stage = event.stage;
        }
        if (typeof event.total === 'number') {
          nextState.total = event.total;
        }
        if (typeof event.totalOperations === 'number') {
          nextState.total = event.totalOperations;
        }
        if (typeof event.totalSuggestions === 'number') {
          nextState.totalSuggestions = event.totalSuggestions;
        }
        if (typeof event.processed === 'number') {
          nextState.processed = event.processed;
        }
        if (typeof event.updatedCreators === 'number') {
          nextState.updatedCreators = event.updatedCreators;
        }
        if (typeof event.declined === 'number') {
          nextState.declined = event.declined;
        }
        if (typeof event.applied === 'number') {
          nextState.applied = event.applied;
        }
        if (typeof event.skipped === 'number') {
          nextState.skipped = event.skipped;
        }
        delete nextState.percent;
        if (typeof event.percent === 'number' && Number.isFinite(event.percent)) {
          nextState.percent = event.percent;
        }
        if (typeof event.affected === 'number') {
          nextState.affected = event.affected;
        }
        if (typeof event.matched === 'number') {
          nextState.matched = event.matched;
        }

        nextState.message = this.composeProgressMessage(event, nextState);
        this.currentProgressState = nextState;
        this.updateProgress();
      },

      composeProgressMessage: function(event, state) {
        switch (event.stage) {
          case 'prepare':
            return 'Preparing normalization updates...';
          case 'operations-planned':
            return `Preparing ${event.total || 0} database updates...`;
          case 'operation-preflight': {
            const total = event.total || state.total || 0;
            const labelTotal = total > 0 ? total : '?';
            const index = (event.processed || 0) + 1;
            if (event.operation) {
              return `Checking ${event.operation} (${index} of ${labelTotal})...`;
            }
            return 'Checking affected creators...';
          }
          case 'operation-complete': {
            const total = event.total || state.total || 0;
            const labelTotal = total > 0 ? total : '?';
            const index = event.processed || 0;
            if (event.operation) {
              return `Applied ${event.operation} (${index}/${labelTotal})`;
            }
            return 'Applied normalization update.';
          }
          case 'operations-finished':
            return `Database updates complete (${event.updatedCreators || state.updatedCreators || 0} creators touched)`;
          case 'finalizing':
            return 'Recording learning decisions...';
          case 'complete':
            if ((event.updatedCreators || state.updatedCreators || 0) > 0) {
              return `All done! Updated ${event.updatedCreators || state.updatedCreators} creators.`;
            }
            if ((event.declined || state.declined || 0) > 0) {
              return 'Saved â€œkeep existingâ€ choices. No changes applied.';
            }
            return 'Normalization finished.';
          case 'error':
            return 'An error occurred while applying normalizations.';
          default:
            return 'Applying normalizations...';
        }
      },

      updateProgress: function() {
        const progressLabel = ZoteroNER_HTMLUtils.getElement('progress-label');
        if (!progressLabel) return;

        const state = this.currentProgressState;
        if (state) {
          const total = typeof state.total === 'number'
            ? state.total
            : (typeof state.totalOperations === 'number' ? state.totalOperations : (typeof state.totalSuggestions === 'number' ? state.totalSuggestions : 0));
          const processed = typeof state.processed === 'number' ? state.processed : 0;
          let percent = Number.isFinite(state.percent) ? state.percent : null;

          if (percent === null) {
            if (total > 0) {
              percent = Math.min(100, Math.round((processed / total) * 100));
            } else if (state.stage === 'complete' || state.stage === 'operations-finished') {
              percent = 100;
            } else if (this.isProcessing) {
              percent = 50;
            } else {
              percent = 0;
            }
          }

          ZoteroNER_HTMLUtils.updateProgressBar(percent);
          ZoteroNER_HTMLUtils.updateProgressLabel(state.message || 'Applying normalizations...');
          return;
        }

        if (this.analysisResults && this.analysisResults.suggestions) {
          if (this.isProcessing) {
            ZoteroNER_HTMLUtils.updateProgressBar(50);
            ZoteroNER_HTMLUtils.updateProgressLabel('Applying normalizations...');
          } else {
            ZoteroNER_HTMLUtils.updateProgressBar(100);
            ZoteroNER_HTMLUtils.updateProgressLabel('Analysis complete: ' + this.analysisResults.suggestions.length + ' variant groups found');
          }
        } else if (this.isProcessing) {
          ZoteroNER_HTMLUtils.updateProgressBar(50);
          ZoteroNER_HTMLUtils.updateProgressLabel('Analyzing library...');
        } else {
          ZoteroNER_HTMLUtils.updateProgressBar(0);
          ZoteroNER_HTMLUtils.updateProgressLabel('Ready');
        }
      },

      applySelected: async function() {
        if (this.isProcessing || !this.analysisResults || !Array.isArray(this.analysisResults.suggestions)) {
          return;
        }

        const preparedSuggestions = [];
        const declinedSuggestions = [];

        this.analysisResults.suggestions.forEach((suggestion, index) => {
          const selection = this.ensureUserSelection(index, suggestion);
          if (!selection) {
            return;
          }

          const prepared = Object.assign({}, suggestion);
          prepared.originalPrimary = suggestion.primary;
          prepared.userSelection = Object.assign({}, selection);
          prepared.variants = (suggestion.variants || []).map(variant => {
            const variantClone = Object.assign({}, variant);
            if (Array.isArray(variantClone.items)) {
              variantClone.items = variantClone.items.map(item => Object.assign({}, item));
            }
            return variantClone;
          });

          if (selection.apply === false) {
            declinedSuggestions.push(prepared);
            return;
          }

          const normalizedValue = (selection.value || '').trim();
          if (!normalizedValue) {
            return;
          }

          prepared.primary = normalizedValue;

          if (selection.mode === 'variant' && typeof selection.variantIndex === 'number') {
            prepared.selectedVariant = prepared.variants[selection.variantIndex] || null;
          }

          if (selection.mode === 'custom') {
            prepared.customNormalization = normalizedValue;
          }

          preparedSuggestions.push(prepared);
        });

        if (preparedSuggestions.length === 0 && declinedSuggestions.length === 0) {
          this.alert('Author Name Normalizer', 'No normalization choices are selected to apply. Adjust your selections or close the dialog.');
          return;
        }

        this.currentProgressState = preparedSuggestions.length > 0
          ? { stage: 'prepare', total: preparedSuggestions.length, processed: 0, message: 'Preparing normalization updates...' }
          : { stage: 'prepare', total: declinedSuggestions.length, processed: 0, message: 'Saving â€œkeep existingâ€ choices...' };

        this.setDialogBusy(true);
        this.updateProgress();

        let applyError = null;

        try {
          // Try to use the main window's Zotero API which has proper Zotero context
          let results;
          const nameNormalizer = ZoteroNER_ZoteroAPI.getNameNormalizer();

          if (nameNormalizer) {
            results = await nameNormalizer.applyNormalizationSuggestions(
              preparedSuggestions,
              false,
              {
                declinedSuggestions,
                progressCallback: (event) => this.handleApplyProgress(event)
              }
            );
          } else if (typeof ZoteroNER !== 'undefined' && ZoteroNER.ZoteroDBAnalyzer) {
            // Fallback: instantiate in dialog context (will fail if Zotero is undefined)
            this.dbAnalyzer = new ZoteroNER.ZoteroDBAnalyzer();
            if (!this.dbAnalyzer || typeof this.dbAnalyzer.applyNormalizationSuggestions !== 'function') {
              throw new Error('Zotero database analyzer is not available in this context.');
            }
            results = await this.dbAnalyzer.applyNormalizationSuggestions(preparedSuggestions, false, {
              declinedSuggestions,
              progressCallback: (event) => this.handleApplyProgress(event)
            });
          } else {
            throw new Error('Zotero API not available. Cannot apply normalizations.');
          }

          if (results.applied === 0 && results.updatedCreators === 0 && results.declinedRecorded > 0) {
            this.alert('Author Name Normalizer', 'No normalization changes were applied. Your â€œkeep existingâ€ choices were saved for future runs.');
          } else {
            const summary = [
              'Suggestions reviewed: ' + results.totalSuggestions,
              'Applied: ' + results.applied,
              'Skipped: ' + results.skipped,
              'Creators updated: ' + (results.updatedCreators || 0)
            ];

            if (results.declinedRecorded > 0) {
              summary.push('Saved â€œkeep existingâ€ decisions: ' + results.declinedRecorded);
            }

            if (results.errors > 0) {
              summary.push('Errors: ' + results.errors);
            }

            this.alert('Author Name Normalizer', 'Normalization selections applied!\n\n' + summary.join('\n'));
          }

        } catch (error) {
          applyError = error;
          console.error(error);
          this.alert('Error', 'Failed to apply normalization selections: ' + error.message);
        } finally {
          this.setDialogBusy(false);
          this.currentProgressState = null;
          this.updateProgress();
          if (!applyError) {
            window.close();
          }
        }
      },

      applyAllSelected: async function() {
        // Count how many normalizations are selected
        let selectedCount = 0;
        for (const [index, selection] of this.userSelections) {
          if (selection.apply !== false && selection.mode !== 'keep') {
            selectedCount++;
          }
        }

        if (selectedCount === 0) {
          this.alert('Author Name Normalizer', 'No normalization choices are selected to apply. Select at least one normalization to apply.');
          return;
        }

        // Show confirmation dialog for bulk operations
        const confirmed = window.confirm(
          `You are about to apply ${selectedCount} normalization(s) to your library.\n\n` +
          `This will modify author names in ${selectedCount} item(s).\n\n` +
          `Are you sure you want to continue?`
        );

        if (!confirmed) {
          this.log('User cancelled Apply All operation');
          return;
        }

        // Proceed with applying all selected normalizations
        this.log('User confirmed Apply All for ' + selectedCount + ' normalizations');
        await this.applySelected();
      },

      startProgressTracking: function() {
        this.log('Starting progress tracking');

        // Track when analysis is complete (set by updateAnalysisResults)
        this.analysisComplete = false;

        // Track last progress update time for adaptive timeout
        this.lastProgressTime = Date.now();
        this.lastHeartbeat = Date.now();

        const ADAPTIVE_TIMEOUT_MS = 120000;        // 120 seconds max for large libraries
        const PROGRESS_UPDATE_TIMEOUT_MS = 45000;  // 45 seconds since last progress = stuck
        const HEARTBEAT_TIMEOUT_MS = 30000;        // 30 seconds without heartbeat = stalled

        const analysisStartTime = Date.now();
        const self = this;

        // Clear any existing interval
        if (this.checkAnalysisInterval) {
          clearInterval(this.checkAnalysisInterval);
          this.checkAnalysisInterval = null;
        }

        // Set up the timeout check interval
        this.checkAnalysisInterval = setInterval(() => {
          // Check if analysis completed (flag set by updateAnalysisResults)
          if (self.analysisComplete) {
            clearInterval(self.checkAnalysisInterval);
            self.checkAnalysisInterval = null;
            const suggestionCount = (self.analysisResults && self.analysisResults.suggestions) ? self.analysisResults.suggestions.length : 0;
            self.log('Analysis completed with ' + suggestionCount + ' suggestions after ' + (Date.now() - analysisStartTime) + 'ms');
          } else if (self.analysisResults && self.analysisResults.suggestions) {
            // Results arrived but analysisComplete flag not set - complete now
            clearInterval(self.checkAnalysisInterval);
            self.checkAnalysisInterval = null;
            self.log('Analysis results received (timeout check), suggestions: ' + self.analysisResults.suggestions.length);
          } else {
            // Adaptive timeout: check max time, last progress, and heartbeat
            const timeSinceStart = Date.now() - analysisStartTime;
            const timeSinceProgress = Date.now() - self.lastProgressTime;
            const timeSinceHeartbeat = Date.now() - (self.lastHeartbeat || self.lastProgressTime);

            if (timeSinceStart > ADAPTIVE_TIMEOUT_MS) {
              // Absolute timeout: analysis running too long
              clearInterval(self.checkAnalysisInterval);
              self.checkAnalysisInterval = null;
              self.log('ERROR: Analysis timeout after ' + timeSinceStart + 'ms (adaptive)');
              self.showEmptyState('Analysis timed out. The library may be too large.');
            } else if (timeSinceHeartbeat > HEARTBEAT_TIMEOUT_MS) {
              // No heartbeat - analysis may be stalled
              self.log('No heartbeat for ' + timeSinceHeartbeat + 'ms, checking status...');
              self.lastHeartbeat = Date.now();  // Reset to avoid repeated warnings
            } else if (timeSinceProgress > PROGRESS_UPDATE_TIMEOUT_MS) {
              // No progress update, but heartbeat still coming - CPU busy, not stuck
              self.log('No progress update for ' + timeSinceProgress + 'ms (CPU busy, not stuck)');
              // Don't reset lastProgressTime - we want to track actual progress
            }
          }
        }, 500);

        // Note: showLoadingState() is now called separately in initialize()
        // before startProgressTracking() to ensure progress bar appears immediately
      },

      showLoadingState: function() {
        this.log('Showing loading state');

        // Hide empty message, show progress
        ZoteroNER_HTMLUtils.setHidden('empty-message', true);
        ZoteroNER_HTMLUtils.setHidden('summary-group', true);
        ZoteroNER_HTMLUtils.setHidden('variant-section', true);
        ZoteroNER_HTMLUtils.setHidden('progress-container', false);
        ZoteroNER_HTMLUtils.updateProgressLabel('Analyzing library...');
        // Use indeterminate animation so user sees progress even if analysis is fast
        ZoteroNER_HTMLUtils.setProgressIndeterminate(true);
        this.setApplyEnabled(false);
      },
      
      handleAnalysisProgress: function(progress) {
        // Always update timestamps first
        this.lastProgressTime = Date.now();
        this.lastHeartbeat = Date.now();

        this.log('handleAnalysisProgress: stage=' + (progress.stage || 'unknown') + ', percent=' + (progress.percent !== undefined ? progress.percent : 'N/A') + ', processed=' + (progress.processed || 'N/A') + ', total=' + (progress.total || 'N/A'));

        if (!progress) {
          this.log('handleAnalysisProgress: received null progress');
          return;
        }

        // Debounce rapid updates to prevent UI jank
        if (this.progressUpdateTimer) {
          clearTimeout(this.progressUpdateTimer);
        }

        this.progressUpdateTimer = setTimeout(() => {
          this.updateProgressUI(progress);
        }, 100);
      },

      receiveHeartbeat: function() {
        // Check if dialog is still open/valid
        if (!document.getElementById('progress-container')) {
          return;  // Dialog closing, ignore heartbeat
        }
        this.lastHeartbeat = Date.now();
        // Note: Do NOT update lastProgressTime - heartbeat != actual progress
      },

      updateProgressUI: function(progress) {
        // Ensure progress container is visible while updating
        if (!progress) return;

        ZoteroNER_HTMLUtils.setHidden('progress-container', false);

        let message = 'Analyzing library...';
        let percent = 0;
        let isIndeterminate = false;

        if (progress.stage === 'filtering_items') {
          message = `Loading items... (${progress.processed || 0} of ${progress.total || '?'})`;
          percent = progress.percent || 0;
        } else if (progress.stage === 'analyzing_surnames') {
          if (progress.total) {
            message = `Analyzing surnames... (${progress.processed || 0} of ${progress.total})`;
            percent = progress.percent || 0;
          } else {
            message = `Analyzing surnames... (${progress.processed || 0} comparisons)`;
            isIndeterminate = true;
          }
        } else if (progress.stage === 'generating_suggestions') {
          message = 'Generating normalization suggestions...';
          percent = 95;
        } else if (progress.stage === 'debug') {
          message = progress.message || 'Analyzing...';
          percent = progress.percent || 0;
        }

        ZoteroNER_HTMLUtils.updateProgressLabel(message);

        const fill = document.getElementById('progress-fill');
        if (fill) {
          if (isIndeterminate) {
            fill.classList.add('indeterminate');
          } else {
            fill.classList.remove('indeterminate');
            fill.style.width = Math.max(percent, 3) + '%';
          }
        }
      },
      
      updateAnalysisResults: function(analysisResults) {

        // Mark analysis as complete to prevent timeout error
        this.analysisComplete = true;
        
        // Clear the timeout interval if it's still running
        if (this.checkAnalysisInterval) {
          clearInterval(this.checkAnalysisInterval);
          this.checkAnalysisInterval = null;
        }

        // Clear any pending progress update timer
        if (this.progressUpdateTimer) {
          clearTimeout(this.progressUpdateTimer);
          this.progressUpdateTimer = null;
        }

        if (!analysisResults) {
          this.showEmptyState('Analysis completed but no results were returned.');
          ZoteroNER_HTMLUtils.setHidden('progress-container', true);
          return;
        }

        this.log('Updating dialog with analysis results');
        this.log('Results contain: ' + (analysisResults.suggestions ? analysisResults.suggestions.length : 0) + ' suggestions');

        this.analysisResults = analysisResults;
        this.resetSelections();
        this.clearVariantDetails();
        
        // Show 100% progress for a moment before hiding
        ZoteroNER_HTMLUtils.updateProgressLabel('Analysis complete!');
        ZoteroNER_HTMLUtils.updateProgressBar(100);
        
        // Hide progress container after a brief delay to show completion
        setTimeout(() => {
          ZoteroNER_HTMLUtils.setHidden('progress-container', true);
          ZoteroNER_HTMLUtils.setHidden('summary-group', false);
          ZoteroNER_HTMLUtils.setHidden('variant-section', false);
        }, 500);
        
        this.updateSummaryHeader();
        this.populateVariantGroupList();
        this.refreshApplyButtonState();
        this.updateProgress();
      }
    };

    // Set up event listeners with error handling
    try {
    // Event listeners
    document.getElementById('apply-button').addEventListener('click', function() {
      ZoteroNER_NormalizationDialog.applySelected();
    });

    document.getElementById('apply-all-button').addEventListener('click', function() {
      ZoteroNER_NormalizationDialog.applyAllSelected();
    });

    document.getElementById('cancel-button').addEventListener('click', function() {
      window.close();
    });

    // Event delegation for dynamically created field apply buttons
    document.addEventListener('click', function(event) {
      ZoteroNER_NormalizationDialog.log('CLICK on: ' + event.target.tagName + ' class=' + (event.target.className || ''));
      const applyBtn = event.target.closest('.field-apply-button');
      if (applyBtn) {
        event.preventDefault();
        ZoteroNER_NormalizationDialog.log('Apply button detected');
        const idx = parseInt(applyBtn.getAttribute('data-idx'));
        ZoteroNER_NormalizationDialog.log('Apply button clicked: idx=' + idx);
        ZoteroNER_NormalizationDialog.applySingleFieldNormalization(idx);
        return;
      }
    });

    // Event delegation for field inputs
    document.addEventListener('input', function(event) {
      const fieldInput = event.target.closest('.field-normalized-input');
      if (fieldInput) {
        const idx = parseInt(fieldInput.getAttribute('data-idx'));
        ZoteroNER_NormalizationDialog.log('INPUT event: idx=' + idx + ', value=' + fieldInput.value);
        ZoteroNER_NormalizationDialog.handleFieldNormalizationChange(idx, fieldInput.value);
        return;
      }
    });

    // Expose controller globally so parent window can call it
    window.ZoteroNERController = ZoteroNER_NormalizationDialog;
    window.ZoteroNER_NormalizationDialog = ZoteroNER_NormalizationDialog;

    // Global wrapper for field normalization apply
    window.applyFieldNormalization = function(index) {
      return ZoteroNER_NormalizationDialog.applySingleFieldNormalization(index);
    };

    // Start when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function() {
        ZoteroNER_NormalizationDialog.init();
      });
    } else {
      ZoteroNER_NormalizationDialog.init();
    }
    } catch (err) {
      console.error('Error setting up event listeners: ' + err.message);
    }
  </script>

  <!-- Field Normalization Section - Reuses variant layout -->
  <div id="field-normalization-section">
    <h2 id="field-normalization-title">Field Normalization</h2>

    <!-- Summary -->
    <div id="field-summary" class="summary" style="display: none;">
      <div class="summary-grid">
        <div><strong>Unique values:</strong> <span id="field-total-values">0</span></div>
        <div><strong>Pending changes:</strong> <span id="field-pending-changes">0</span></div>
      </div>
    </div>

    <!-- Progress -->
    <div id="field-progress-container" class="progress" style="display: none;">
      <div class="progress-bar">
        <div id="field-progress-fill" class="progress-fill"></div>
      </div>
      <span id="field-progress-label">Processing...</span>
    </div>

    <!-- Filter bar -->
    <div id="field-filter-bar">
      <input type="search" id="field-filter-input" placeholder="Filter valuesâ€¦" aria-label="Filter field values">
      <span id="field-filter-summary">Showing all values</span>
    </div>

    <!-- Field values list (reuses variant layout) -->
    <div id="field-layout">
      <div id="field-values-column">
        <div id="field-values-container">
          <!-- Field value groups will be dynamically populated here -->
        </div>
      </div>
      <aside id="field-detail-panel" class="variant-detail">
        <h4 id="field-detail-title">Field details</h4>
        <div id="field-detail-context" class="variant-detail-context"></div>
        <div id="field-detail-items"></div>
      </aside>
    </div>

    <!-- Empty state -->
    <div id="field-empty-message" class="empty-message" style="display: none;">
      No field values found.
    </div>

    <!-- Action buttons -->
    <div style="text-align: right; margin-top: 20px;">
      <button id="apply-all-field-button" disabled style="margin-right: 10px;">Apply All Changes</button>
      <button id="apply-field-button" disabled>Apply Selected</button>
      <button id="cancel-field-button" style="margin-left: 10px;">Cancel</button>
    </div>
  </div>

</body>
</html>