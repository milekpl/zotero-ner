<!DOCTYPE html>
<html>
<head>
  <title>NER Author Name Normalizer</title>
  <style>
    body { 
      font-family: -moz-dialog, Arial, sans-serif; 
      padding: 20px; 
      margin: 0; 
      background: #f9f9f9;
      color: #333;
    }
    h1 { margin-top: 0; }
    .summary { 
      background: #e8f4fd; 
      padding: 15px; 
      margin: 10px 0; 
      border: 1px solid #b3d9ff; 
      border-radius: 4px; 
    }
    .summary-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .variant-group { 
      margin: 15px 0; 
      padding: 15px; 
      border: 1px solid #ddd; 
      border-radius: 4px; 
      background: white;
    }
    .variant-group h4 { margin: 0 0 10px 0; color: #0066cc; }
    .primary { 
      font-weight: bold; 
      color: #0066cc; 
      margin-bottom: 10px;
      padding: 5px;
      background: #f0f8ff;
      border-radius: 3px;
    }
    .variants-list {
      list-style: none;
      padding: 0;
    }
    .variant {
      margin: 5px 0;
      padding: 5px;
      background: #f9f9f9;
      border-radius: 3px;
    }
    .variant-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin: 8px 0 4px 0;
    }
    .variant-pill {
      display: inline-flex;
      align-items: center;
      padding: 4px 10px;
      border: 1px solid #c8d1dc;
      border-radius: 16px;
      background: #f7f9fc;
      font-size: 0.9em;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
    }
    .variant-pill:hover {
      border-color: #007acc;
      background: #eef5ff;
    }
    .variant-pill.active {
      background: #007acc;
      border-color: #007acc;
      color: #fff;
    }
    .variant-pill.recommended {
      border-color: #2563eb;
      color: #1d4ed8;
      font-weight: 600;
    }
    .frequency { 
      color: #666; 
      font-size: 0.9em; 
      font-style: italic;
    }
    .radio-group {
      margin: 10px 0;
    }
    .radio-group input[type="radio"] {
      margin-right: 5px;
    }
    .confidence {
      font-size: 0.9em;
      color: #007acc;
      font-weight: bold;
    }
    button { 
      margin: 10px 5px; 
      padding: 8px 16px; 
      border: 1px solid #ccc; 
      border-radius: 3px;
      background: #f0f0f0;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      background: #e0e0e0;
    }
    .custom-normalization {
      margin-top: 12px;
      padding: 10px;
      background: #f6f8fa;
      border-radius: 4px;
      border: 1px solid #d8dee4;
    }
    .custom-normalization label {
      display: block;
      font-weight: 600;
      margin-bottom: 6px;
    }
    .custom-normalization input[type="text"] {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid #c9d1d9;
      border-radius: 3px;
      font-size: 0.95em;
    }
    .custom-normalization input[type="text"]:disabled {
      background: #f0f0f0;
      color: #777;
    }
    .progress { 
      margin: 10px 0; 
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .progress-bar { 
      flex: 1; 
      height: 20px; 
      background: #f0f0f0; 
      border-radius: 10px; 
      overflow: hidden;
      border: 1px solid #ccc;
    }
    .progress-fill { 
      height: 100%; 
      background: linear-gradient(90deg, #0066cc, #007acc); 
      transition: width 0.3s ease;
      width: 0%;
    }
    .empty-message {
      text-align: center;
      color: #666;
      font-style: italic;
      padding: 20px;
    }
    .empty-message-content {
      text-align: left;
      color: #444;
      font-style: normal;
    }
    .empty-message-content p {
      margin: 8px 0;
    }
    .surname-frequency-list {
      list-style: disc;
      padding-left: 20px;
      margin: 6px 0 0 0;
    }
    .surname-frequency-list li {
      margin: 4px 0;
    }
    .surname-frequency-list .surname {
      font-weight: 600;
      color: #222;
    }
    #progress-container { display: none; }
    #suggestions-container:empty::after {
      content: "No suggestions to display.";
      display: block;
      text-align: center;
      color: #666;
      padding: 20px;
    }
    .selected {
      background-color: #e3f2fd;
      border-color: #2196f3;
    }
    .variant-meta {
      font-size: 0.85em;
      color: #555;
      margin-top: 4px;
    }
    #variant-section {
      margin: 20px 0;
    }
    #variant-layout {
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(260px, 1fr);
      gap: 20px;
      align-items: start;
    }
    #variant-groups-column {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .variant-detail {
      padding: 16px;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      background: #fff;
      box-shadow: 0 3px 8px rgba(15, 23, 42, 0.08);
      position: sticky;
      top: 0;
      max-height: calc(100vh - 220px);
      overflow: hidden;
      display: block;
      transition: box-shadow 0.2s ease;
    }
    .variant-detail.hidden {
      display: none;
    }
    .variant-detail h4 {
      margin: 0 0 6px 0;
      color: #005a9c;
      font-size: 1.05em;
    }
    .variant-detail-context {
      font-size: 0.9em;
      color: #586069;
      margin-bottom: 8px;
    }
    .variant-detail-empty {
      font-size: 0.9em;
      color: #69737d;
      line-height: 1.4;
      padding: 12px 0;
    }
    .variant-detail.empty #variant-detail-items,
    .variant-detail.empty .variant-detail-context {
      display: none;
    }
    .variant-detail:not(.empty) .variant-detail-empty {
      display: none;
    }
    .variant-detail-items {
      list-style: disc;
      padding-left: 18px;
      margin: 0;
      max-height: calc(100vh - 320px);
      overflow-y: auto;
    }
    .variant-detail-items li {
      margin: 4px 0;
      line-height: 1.35;
    }
    @media (max-width: 960px) {
      #variant-layout {
        grid-template-columns: 1fr;
      }
      .variant-detail {
        position: static;
        max-height: none;
      }
    }
  </style>
</head>
<body>
  <h1>NER Author Name Normalizer</h1>
  <p>Review and apply author name normalizations for your library.</p>

  <!-- Summary header for full-library analysis -->
  <div id="summary-group" class="summary" style="display: none;">
    <h3>Library Analysis Summary</h3>
    <div class="summary-grid">
      <div><strong>Unique surnames:</strong> <span id="summary-total-creators">Loading...</span></div>
      <div><strong>Variant groups:</strong> <span id="summary-variant-groups">Loading...</span></div>
      <div><strong>Pending normalizations:</strong> <span id="summary-pending-normalizations">Loading...</span></div>
    </div>
  </div>

  <!-- Progress indicator for batch processing -->
  <div id="progress-container" class="progress">
    <div class="progress-bar">
      <div id="progress-fill" class="progress-fill"></div>
    </div>
    <span id="progress-label">Processing...</span>
  </div>

  <!-- Variant groups + detail layout -->
  <div id="variant-section">
    <h3>Creator Variant Groups</h3>
    <p id="variant-groups-description">Review variant groups discovered in your library. Each entry represents multiple creator spellings that may refer to the same person.</p>
    <div id="variant-layout">
      <div id="variant-groups-column">
        <div id="variant-groups-container">
          <!-- Variant groups will be dynamically populated here -->
        </div>
      </div>
      <aside id="variant-detail-panel" class="variant-detail empty hidden">
        <h4 id="variant-detail-title">Variant details</h4>
        <div id="variant-detail-context" class="variant-detail-context"></div>
        <div id="variant-detail-empty" class="variant-detail-empty">Select a variant pill to review sample items and occurrences.</div>
        <ul id="variant-detail-items"></ul>
      </aside>
    </div>
  </div>

  <!-- Empty state -->
  <div id="empty-message" class="empty-message" style="display: none;">
    No variant groups found. All creator names appear to be consistent.
  </div>

  <!-- Action buttons -->
  <div style="text-align: right; margin-top: 20px;">
    <button id="apply-button" disabled>Apply Selected</button>
    <button id="cancel-button">Cancel</button>
  </div>

  <script type="application/javascript" src="chrome://zoteroner/content/scripts/zotero-ner-bundled.js"></script>
  <script type="application/javascript">
    /* global Zotero, ZoteroNER */

    // HTML DOM utils
    const ZoteroNER_HTMLUtils = {
      getElement: function(id) {
        return document.getElementById(id);
      },
      createElement: function(tagName, attributes = {}) {
        const el = document.createElement(tagName);
        for (const [key, value] of Object.entries(attributes)) {
          el.setAttribute(key, value);
        }
        return el;
      },
      appendTo: function(parentId, child) {
        const parent = this.getElement(parentId);
        if (parent) parent.appendChild(child);
      },
      clearContainer: function(id) {
        const container = this.getElement(id);
        if (container) container.innerHTML = '';
      },
      setText: function(id, text) {
        const el = this.getElement(id);
        if (el) el.textContent = text;
      },
      setHidden: function(id, hidden) {
        const el = this.getElement(id);
        if (el) el.style.display = hidden ? 'none' : 'block';
      },
      updateProgressBar: function(percent) {
        const fill = document.getElementById('progress-fill');
        if (fill) fill.style.width = percent + '%';
      },
      updateProgressLabel: function(text) {
        const label = document.getElementById('progress-label');
        if (label) label.textContent = text;
      }
    };

    // Embedded controller
    var ZoteroNER_NormalizationDialog = {
      dbAnalyzer: null,
      isProcessing: false,
      analysisResults: null,
      items: null,
      analysisResultsSource: null,
      userSelections: null,
      variantDetailState: null,

      init: function() {
        console.log('Dialog initialization started');
        this.userSelections = new Map();
        this.variantDetailState = null;
        Promise.resolve(this.initialize()).catch((error) => {
          console.error(error);
          this.alert('Error', 'Failed to initialize: ' + error.message);
          window.close();
        });
      },

      unwrapDialogParams: function(raw) {
        if (!raw) {
          return raw;
        }

        try {
          if (raw.wrappedJSObject) {
            return raw.wrappedJSObject;
          }
        } catch (err) {
          this.log('Failed to access wrappedJSObject: ' + err.message);
        }

        if (typeof raw.getProperty === 'function') {
          try {
            const wrapped = raw.getProperty('wrappedJSObject');
            if (wrapped) {
              return wrapped;
            }
          } catch (err) {
            this.log('No wrappedJSObject property in param bag: ' + err.message);
          }

          let items;
          let analysisResults;
          let analysisResultsJSON;

          try {
            items = raw.getProperty('items');
          } catch (err) {
            this.log('Unable to read items from param bag: ' + err.message);
          }

          try {
            analysisResults = raw.getProperty('analysisResults');
          } catch (err) {
            this.log('Unable to read analysisResults from param bag: ' + err.message);
          }

          try {
            analysisResultsJSON = raw.getProperty('analysisResultsJSON');
          } catch (err) {
            this.log('Unable to read analysisResultsJSON from param bag: ' + err.message);
          }

          if (analysisResultsJSON || analysisResults || items) {
            return {
              items,
              analysisResults,
              analysisResultsJSON
            };
          }
        }

        return raw;
      },

      sanitizeAnalysisResults: function(value, contextLabel = 'analysis results') {
        if (!value || typeof value !== 'object') {
          return null;
        }

        try {
          const plain = JSON.parse(JSON.stringify(value));
          this.log('Sanitized ' + contextLabel + ' (suggestions: ' + ((plain && Array.isArray(plain.suggestions)) ? plain.suggestions.length : 'unknown') + ')');
          return plain;
        } catch (err) {
          this.log('Failed to sanitize ' + contextLabel + ': ' + err.message);
        }

        return null;
      },

      safeParseJSON: function(jsonString, contextLabel = 'analysisResultsJSON') {
        if (!jsonString || typeof jsonString !== 'string') {
          return null;
        }

        try {
          const parsed = JSON.parse(jsonString);
          this.log('Parsed ' + contextLabel + ' (suggestions: ' + ((parsed && Array.isArray(parsed.suggestions)) ? parsed.suggestions.length : 'unknown') + ')');
          return parsed;
        } catch (err) {
          this.log('Failed to parse ' + contextLabel + ': ' + err.message);
        }

        return null;
      },

      resolveAnalysisResults: function(params, contextLabel = 'dialog params') {
        if (!params) {
          return null;
        }

        if (params.analysisResults && typeof params.analysisResults === 'object') {
          const sanitized = this.sanitizeAnalysisResults(params.analysisResults, contextLabel + '.analysisResults');
          if (sanitized) {
            this.analysisResultsSource = contextLabel + '.analysisResults';
            return sanitized;
          }
        }

        if (params.analysisResultsJSON) {
          const parsed = this.safeParseJSON(params.analysisResultsJSON, contextLabel + '.analysisResultsJSON');
          if (parsed) {
            this.analysisResultsSource = contextLabel + '.analysisResultsJSON';
            return parsed;
          }
        }

        return null;
      },

      log: function(message) {
        console.log('Zotero NER Dialog: ' + message);
        try {
          if (typeof Zotero !== 'undefined' && typeof Zotero.debug === 'function') {
            Zotero.debug('Zotero NER Dialog: ' + message);
          }
        } catch (e) {}
      },

      alert: function(title, message) {
        try {
          if (typeof Zotero !== 'undefined' && typeof Zotero.alert === 'function') {
            Zotero.alert(null, title, message);
          } else {
            window.alert(title + ': ' + message);
          }
        } catch (e) {
          window.alert(title + ': ' + message);
        }
      },
      
      initialize: async function() {
        this.log('Dialog initialize started');

        let params = null;

        try {
          if (typeof window.arguments !== 'undefined' && window.arguments.length > 0) {
            params = window.arguments[0];
          }
        } catch (err) {
          this.log('Unable to read window arguments: ' + err.message);
        }

        if (params) {
          params = this.unwrapDialogParams(params);
        }

        if (!params && window.ZoteroNERDialogParams) {
          params = this.unwrapDialogParams(window.ZoteroNERDialogParams);
        }

        if (!params && window.ZoteroNERDialogParamsJSON) {
          params = { analysisResultsJSON: window.ZoteroNERDialogParamsJSON };
        }

        if (!params && window.opener) {
          try {
            if (window.opener.ZoteroNERDialogParams) {
              params = this.unwrapDialogParams(window.opener.ZoteroNERDialogParams);
            }
          } catch (err) {
            this.log('Unable to read ZoteroNERDialogParams from opener: ' + err.message);
          }
        }

        if (!params && window.opener && window.opener.ZoteroNERDialogParamsJSON) {
          params = { analysisResultsJSON: window.opener.ZoteroNERDialogParamsJSON };
        }

        if (!params && window.opener && window.opener.ZoteroNERAnalysisResultsJSON) {
          params = { analysisResultsJSON: window.opener.ZoteroNERAnalysisResultsJSON };
        }

        if (!params && window.opener && window.opener.ZoteroNERAnalysisResults) {
          const sanitized = this.sanitizeAnalysisResults(window.opener.ZoteroNERAnalysisResults, 'opener.ZoteroNERAnalysisResults');
          if (sanitized) {
            params = { analysisResults: sanitized };
          }
        }

        if (!params && window.ZoteroNERAnalysisResultsJSON) {
          params = { analysisResultsJSON: window.ZoteroNERAnalysisResultsJSON };
        }

        if (!params && window.ZoteroNERAnalysisResults) {
          const sanitizedCurrent = this.sanitizeAnalysisResults(window.ZoteroNERAnalysisResults, 'window.ZoteroNERAnalysisResults');
          if (sanitizedCurrent) {
            params = { analysisResults: sanitizedCurrent };
          }
        }

        let analysisResults = null;
        if (params) {
          analysisResults = this.resolveAnalysisResults(params, 'dialog params');

          if (!analysisResults && !params.analysisResults && !params.analysisResultsJSON) {
            const direct = this.sanitizeAnalysisResults(params, 'dialog params direct');
            if (direct) {
              analysisResults = direct;
              this.analysisResultsSource = 'dialog params direct';
            }
          }

          if (params.items) {
            this.items = params.items;
          }
        }


            this.resetSelections();
        if (!analysisResults && window.opener && window.opener.ZoteroNERAnalysisResultsJSON) {
          analysisResults = this.safeParseJSON(window.opener.ZoteroNERAnalysisResultsJSON, 'opener.ZoteroNERAnalysisResultsJSON');
        }

        if (!analysisResults && window.opener && window.opener.ZoteroNERAnalysisResults) {
          analysisResults = this.sanitizeAnalysisResults(window.opener.ZoteroNERAnalysisResults, 'opener.ZoteroNERAnalysisResults direct');
        }

        if (!analysisResults && window.ZoteroNERAnalysisResultsJSON) {
          analysisResults = this.safeParseJSON(window.ZoteroNERAnalysisResultsJSON, 'window.ZoteroNERAnalysisResultsJSON');
        }

        if (!analysisResults && window.ZoteroNERAnalysisResults) {
          analysisResults = this.sanitizeAnalysisResults(window.ZoteroNERAnalysisResults, 'window.ZoteroNERAnalysisResults direct');
        }

        if (!analysisResults) {
          this.log('No analysis results found');
          this.showEmptyState('No analysis results were provided to the dialog.');
          this.updateProgress();
          return;
        }

        this.analysisResults = analysisResults;
        this.resetSelections();
        this.clearVariantDetails();

        this.log('Analysis results source: ' + (this.analysisResultsSource || 'unknown'));
        this.log('Analysis results loaded: ' + (this.analysisResults.suggestions ? this.analysisResults.suggestions.length : 0) + ' suggestions; unique surnames: ' + (this.analysisResults.totalUniqueSurnames ?? 'unknown'));

        this.updateSummaryHeader();
        this.populateVariantGroupList();
        this.refreshApplyButtonState();
        this.updateProgress();
      },

      showEmptyState: function(message) {
        if (this.analysisResults) {
          this.updateSummaryHeader();
        } else {
          ZoteroNER_HTMLUtils.setHidden('summary-group', true);
        }

        ZoteroNER_HTMLUtils.clearContainer('variant-groups-container');
        this.clearVariantDetails();

        this.setApplyEnabled(false);

        const emptyMsg = ZoteroNER_HTMLUtils.getElement('empty-message');
        if (emptyMsg) {
          const frequencies = this.analysisResults && this.analysisResults.surnameFrequencies
            ? Object.entries(this.analysisResults.surnameFrequencies)
            : [];
          const totalUnique = this.analysisResults && typeof this.analysisResults.totalUniqueSurnames === 'number'
            ? this.analysisResults.totalUniqueSurnames
            : 0;
          const topFrequencies = frequencies
            .sort((a, b) => b[1] - a[1])
            .slice(0, 10);

          let html = '<div class="empty-message-content">';
          html += `<p>${message || 'No variant groups found. All creator names appear to be consistent.'}</p>`;

          if (totalUnique) {
            html += `<p><strong>Total unique surnames scanned:</strong> ${totalUnique}</p>`;
          }

          if (topFrequencies.length > 0) {
            html += '<p><strong>Top surnames by frequency:</strong></p>';
            html += '<ul class="surname-frequency-list">';
            topFrequencies.forEach(([name, count]) => {
              html += `<li><span class="surname">${this.formatSurnameKey(name)}</span> <span class="frequency">(${count})</span></li>`;
            });
            html += '</ul>';
          }

          html += '</div>';
          emptyMsg.innerHTML = html;
          emptyMsg.style.display = 'block';
        }
      },

      updateSummaryHeader: function() {
        if (!this.analysisResults) return;

        ZoteroNER_HTMLUtils.setHidden('summary-group', false);
        ZoteroNER_HTMLUtils.setText('summary-total-creators', this.analysisResults.totalUniqueSurnames || '0');
        ZoteroNER_HTMLUtils.setText('summary-variant-groups', this.analysisResults.totalVariantGroups || '0');
        ZoteroNER_HTMLUtils.setText('summary-pending-normalizations', this.analysisResults.suggestions ? this.analysisResults.suggestions.length : '0');
      },

      resetSelections: function() {
        this.userSelections = new Map();
        if (!this.analysisResults || !Array.isArray(this.analysisResults.suggestions)) {
          return;
        }

        this.analysisResults.suggestions.forEach((suggestion, index) => {
          this.ensureUserSelection(index, suggestion);
        });
      },

      ensureUserSelection: function(index, suggestion) {
        if (!this.userSelections) {
          this.userSelections = new Map();
        }

        if (!this.userSelections.has(index)) {
          const defaultValue = this.getDefaultNormalizationValue(suggestion);
          this.userSelections.set(index, {
            mode: 'primary',
            value: defaultValue,
            variantIndex: null,
            customValue: defaultValue,
            apply: true
          });
        }

        return this.userSelections.get(index);
      },

      updateSelection: function(index, suggestion, updates) {
        const current = this.ensureUserSelection(index, suggestion);
        const next = Object.assign({}, current, updates || {});

        if (updates && Object.prototype.hasOwnProperty.call(updates, 'mode')) {
          if (updates.mode === 'keep') {
            next.apply = false;
            next.variantIndex = null;
          } else {
            next.apply = true;
            if (updates.mode !== 'variant') {
              next.variantIndex = null;
            }
          }
        }

        if (updates && Object.prototype.hasOwnProperty.call(updates, 'variantIndex') && next.mode !== 'variant') {
          next.variantIndex = updates.variantIndex;
        }

        if (updates && Object.prototype.hasOwnProperty.call(updates, 'customValue')) {
          next.customValue = updates.customValue;
          if (next.mode === 'custom' && !Object.prototype.hasOwnProperty.call(updates, 'value')) {
            next.value = updates.customValue;
          }
        }

        if (updates && Object.prototype.hasOwnProperty.call(updates, 'value')) {
          next.value = updates.value;
        }

        this.userSelections.set(index, next);
        this.refreshApplyButtonState();
        return next;
      },

      refreshApplyButtonState: function() {
        this.setApplyEnabled(this.hasSelectedNormalizations());
      },

      hasSelectedNormalizations: function() {
        if (!this.analysisResults || !Array.isArray(this.analysisResults.suggestions) || this.analysisResults.suggestions.length === 0) {
          return false;
        }

        if (!this.userSelections || this.userSelections.size === 0) {
          return true;
        }

        for (let i = 0; i < this.analysisResults.suggestions.length; i++) {
          const selection = this.userSelections.get(i);
          if (!selection || selection.apply !== false) {
            return true;
          }
        }

        return false;
      },

      getDefaultNormalizationValue: function(suggestion) {
        if (!suggestion) {
          return '';
        }

        if (suggestion.type === 'given-name') {
          if (suggestion.recommendedFullName) {
            return suggestion.recommendedFullName;
          }
        }

        if (typeof suggestion.primary === 'string') {
          return suggestion.primary.trim();
        }

        return this.formatNameString(suggestion.primary);
      },

      titleCase: function(value) {
        if (!value || typeof value !== 'string') {
          return '';
        }

        return value
          .split(/\s+/)
          .filter(Boolean)
          .map(part => part.charAt(0).toUpperCase() + part.slice(1))
          .join(' ');
      },

      getGroupTitle: function(index, suggestion) {
        const groupNumber = index + 1;
        if (suggestion.type === 'given-name') {
          const surname = this.titleCase(suggestion.surname || suggestion.primary || '');
          return surname
            ? `Given name variants · ${surname}`
            : `Given name variants · Group ${groupNumber}`;
        }

        const surname = this.titleCase(suggestion.primary || '');
        return surname
          ? `Surname variants · ${surname}`
          : `Variant Group ${groupNumber}`;
      },

      buildRecommendedHTML: function(suggestion, recommendedValue) {
        const safeValue = this.escapeHTML(recommendedValue || '');
        if (suggestion.type === 'given-name') {
          return 'Recommended full name: <strong>' + safeValue + '</strong>';
        }
        return 'Recommended normalization: <strong>' + safeValue + '</strong>';
      },

      getVariantSummaryText: function(suggestion) {
        const variantCount = Array.isArray(suggestion.variants) ? suggestion.variants.length : 0;

        if (suggestion.type === 'given-name') {
          const total = suggestion.totalFrequency || 0;
          return `${variantCount} given-name variants · ${total} occurrences`;
        }

        const totalOccurrences = (suggestion.variants || []).reduce((sum, variant) => sum + (variant.frequency || 0), 0);
        return `${variantCount} surname spellings · ${totalOccurrences} occurrences`;
      },

      getVariantDisplayLabel: function(suggestion, variant) {
        if (!variant) {
          return '';
        }

        const frequency = typeof variant.frequency === 'number' ? ` (${variant.frequency})` : '';

        if (suggestion.type === 'given-name') {
          const name = variant.firstName || variant.name || '';
          return `${this.titleCase(name)}${frequency}`;
        }

        return `${this.formatNameString(variant.name)}${frequency}`;
      },

      getVariantSelectionLabel: function(suggestion, variant) {
        if (!variant) {
          return '';
        }

        const occurrences = typeof variant.frequency === 'number' ? `${variant.frequency} occurrences` : 'variant';

        if (suggestion.type === 'given-name') {
          return `Normalize to ${this.titleCase(variant.firstName || variant.name || '')} (${occurrences})`;
        }

        return `Normalize to ${this.formatNameString(variant.name)} (${occurrences})`;
      },

      buildVariantListElement: function(index, suggestion) {
        const wrapper = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-list' });
        const recommendedValue = (this.getDefaultNormalizationValue(suggestion) || '').trim().toLowerCase();

        (suggestion.variants || []).forEach((variant, variantIndex) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'variant-pill';
          button.dataset.suggestionIndex = String(index);
          button.dataset.variantIndex = String(variantIndex);
          button.textContent = this.getVariantDisplayLabel(suggestion, variant);
          const variantValue = (typeof variant.name === 'string' && variant.name)
            ? variant.name.trim().toLowerCase()
            : (variant.firstName ? `${variant.firstName} ${variant.lastName || suggestion.primary || ''}`.trim().toLowerCase() : '');
          if (recommendedValue && variantValue && variantValue === recommendedValue) {
            button.classList.add('recommended');
          }
          button.addEventListener('click', () => {
            this.showVariantDetails(index, variantIndex, suggestion, { suppressHighlight: false });
          });
          wrapper.appendChild(button);
        });

        return wrapper;
      },

      findRecommendedVariantIndex: function(suggestion) {
        if (!suggestion || !Array.isArray(suggestion.variants) || suggestion.variants.length === 0) {
          return null;
        }

        const recommendedValue = (this.getDefaultNormalizationValue(suggestion) || '').trim().toLowerCase();
        if (!recommendedValue) {
          return null;
        }

        for (let i = 0; i < suggestion.variants.length; i++) {
          const variant = suggestion.variants[i];
          const variantValue = (typeof variant.name === 'string' && variant.name)
            ? variant.name.trim().toLowerCase()
            : (variant.firstName ? `${variant.firstName} ${variant.lastName || suggestion.primary || ''}`.trim().toLowerCase() : '');

          if (variantValue && variantValue === recommendedValue) {
            return i;
          }
        }

        return null;
      },

      highlightVariantPills: function(suggestionIndex, variantIndex) {
        const pills = document.querySelectorAll('.variant-pill[data-suggestion-index]');
        pills.forEach(pill => {
          const matches = pill.dataset.suggestionIndex === String(suggestionIndex) && pill.dataset.variantIndex === String(variantIndex);
          pill.classList.toggle('active', matches);
        });
      },

      getVariantDetailTitle: function(suggestion, variant) {
        const label = this.getVariantDisplayLabel(suggestion, variant).replace(/\s+\([^)]*\)$/, '');
        if (suggestion.type === 'given-name') {
          return `Occurrences for ${label}`;
        }
        return `Occurrences for surname variant ${label}`;
      },

      showVariantDetails: function(suggestionIndex, variantIndex, suggestion, options = {}) {
        if (!suggestion || !Array.isArray(suggestion.variants)) {
          this.clearVariantDetails();
          return;
        }

        const variant = suggestion.variants[variantIndex];
        if (!variant) {
          this.clearVariantDetails();
          return;
        }

        this.variantDetailState = { suggestionIndex, variantIndex };

        if (!options.suppressHighlight) {
          this.highlightVariantPills(suggestionIndex, variantIndex);
        }

        const panel = ZoteroNER_HTMLUtils.getElement('variant-detail-panel');
        if (!panel) {
          return;
        }

        panel.style.display = 'block';

        const titleEl = ZoteroNER_HTMLUtils.getElement('variant-detail-title');
        if (titleEl) {
          titleEl.textContent = this.getVariantDetailTitle(suggestion, variant);
        }

        const contextEl = ZoteroNER_HTMLUtils.getElement('variant-detail-context');
        if (contextEl) {
          const pieces = [];
          const freq = typeof variant.frequency === 'number' ? variant.frequency : 0;
          pieces.push(`Occurrences: ${freq}`);
          if (suggestion.type === 'given-name') {
            pieces.push(`Surname: ${this.titleCase(suggestion.surname || suggestion.primary || '')}`);
          }
          contextEl.textContent = pieces.join(' · ');
        }

        const listEl = ZoteroNER_HTMLUtils.getElement('variant-detail-items');
        if (listEl) {
          listEl.innerHTML = '';
          const items = Array.isArray(variant.items) ? variant.items : [];

          if (items.length === 0) {
            const emptyLi = document.createElement('li');
            emptyLi.textContent = 'No sample items available for this variant.';
            listEl.appendChild(emptyLi);
          } else {
            items.forEach(item => {
              const li = document.createElement('li');
              li.textContent = this.formatItemSummary(item);
              listEl.appendChild(li);
            });

            if ((variant.frequency || 0) > items.length) {
              const moreLi = document.createElement('li');
              moreLi.className = 'variant-meta';
              moreLi.textContent = `…and ${(variant.frequency || 0) - items.length} more entries`;
              listEl.appendChild(moreLi);
            }
          }
        }
      },

      clearVariantDetails: function() {
        this.variantDetailState = null;
        const panel = ZoteroNER_HTMLUtils.getElement('variant-detail-panel');
        if (panel) {
          panel.style.display = 'none';
        }

        const contextEl = ZoteroNER_HTMLUtils.getElement('variant-detail-context');
        if (contextEl) {
          contextEl.textContent = '';
        }

        const listEl = ZoteroNER_HTMLUtils.getElement('variant-detail-items');
        if (listEl) {
          listEl.innerHTML = '';
        }

        const pills = document.querySelectorAll('.variant-pill');
        pills.forEach(pill => pill.classList.remove('active'));
      },

      formatItemSummary: function(item) {
        if (!item) {
          return 'Untitled item';
        }

        const title = item.title || 'Untitled';
        const trimmedTitle = title.length > 80 ? title.slice(0, 77) + '…' : title;
        const year = item.year || item.date || '';
        return year ? `${trimmedTitle} (${year})` : trimmedTitle;
      },

      buildSelectionControls: function(index, suggestion) {
        const choiceGroup = ZoteroNER_HTMLUtils.createElement('div', { class: 'radio-group', id: 'ner-variant-group-choice-' + index });
        const selection = this.ensureUserSelection(index, suggestion);
        const recommendedValue = this.getDefaultNormalizationValue(suggestion);
        const recommendedLabelText = suggestion.type === 'given-name'
          ? (recommendedValue ? `Use recommended full name: ${recommendedValue}` : 'Use recommended full name')
          : (recommendedValue ? `Use recommended normalization: ${recommendedValue}` : 'Use recommended normalization');

        const primaryRow = this.createSelectionRadioRow(index, suggestion, {
          mode: 'primary',
          label: recommendedLabelText,
          checked: selection.mode === 'primary',
          selectionUpdate: () => ({ mode: 'primary', value: recommendedValue })
        });
        choiceGroup.appendChild(primaryRow);

        const keepRow = this.createSelectionRadioRow(index, suggestion, {
          mode: 'keep',
          label: 'Keep existing forms as-is',
          checked: selection.mode === 'keep',
          selectionUpdate: () => ({ mode: 'keep', apply: false })
        });
        choiceGroup.appendChild(keepRow);

        (suggestion.variants || []).forEach((variant, variantIndex) => {
          const label = this.getVariantSelectionLabel(suggestion, variant);
          const variantRow = this.createSelectionRadioRow(index, suggestion, {
            mode: 'variant',
            label,
            checked: selection.mode === 'variant' && selection.variantIndex === variantIndex,
            onSelect: () => {
              this.showVariantDetails(index, variantIndex, suggestion);
            },
            selectionUpdate: () => {
              const variantValue = (typeof variant.name === 'string' && variant.name)
                ? variant.name.trim()
                : (variant.firstName ? `${variant.firstName} ${variant.lastName || suggestion.primary || ''}`.trim() : '');
              return {
                mode: 'variant',
                variantIndex,
                value: variantValue
              };
            }
          });
          choiceGroup.appendChild(variantRow);
        });

        const customRow = this.createCustomSelectionRow(index, suggestion, selection, recommendedValue);
        choiceGroup.appendChild(customRow);

        return choiceGroup;
      },

      createSelectionRadioRow: function(index, suggestion, option) {
        const row = ZoteroNER_HTMLUtils.createElement('div');
        const radioId = `choice-${index}-${option.mode}-${Math.random().toString(16).slice(2, 7)}`;
        const radio = ZoteroNER_HTMLUtils.createElement('input', {
          type: 'radio',
          id: radioId,
          name: `choice-${index}`,
          value: option.mode
        });
        if (option.checked) {
          radio.checked = true;
        }

        radio.addEventListener('change', () => {
          if (typeof option.onSelect === 'function') {
            option.onSelect();
          }
          const update = typeof option.selectionUpdate === 'function'
            ? option.selectionUpdate()
            : { mode: option.mode };
          this.updateSelection(index, suggestion, update);
        });

        const label = ZoteroNER_HTMLUtils.createElement('label', { for: radioId });
        label.textContent = option.label;

        row.appendChild(radio);
        row.appendChild(label);
        return row;
      },

      createCustomSelectionRow: function(index, suggestion, selection, defaultValue) {
        const container = ZoteroNER_HTMLUtils.createElement('div', { class: 'custom-normalization' });
        const radioId = `choice-${index}-custom`;
        const radio = ZoteroNER_HTMLUtils.createElement('input', {
          type: 'radio',
          id: radioId,
          name: `choice-${index}`,
          value: 'custom'
        });
        radio.checked = selection.mode === 'custom';

        const label = ZoteroNER_HTMLUtils.createElement('label', { for: radioId });
        label.textContent = 'Use a custom normalization:';

        const input = document.createElement('input');
        input.type = 'text';
        input.value = selection.customValue || defaultValue || '';
        input.disabled = selection.mode !== 'custom';
        input.placeholder = defaultValue || 'Enter normalized name';

        radio.addEventListener('change', () => {
          input.disabled = !radio.checked;
          if (radio.checked) {
            this.updateSelection(index, suggestion, {
              mode: 'custom',
              value: input.value,
              customValue: input.value,
              variantIndex: null
            });
          }
        });

        input.addEventListener('input', (event) => {
          const value = event.target.value;
          const current = this.ensureUserSelection(index, suggestion);
          const updates = { customValue: value };
          if (current.mode === 'custom') {
            updates.value = value;
          }
          this.updateSelection(index, suggestion, updates);
        });

        input.addEventListener('focus', () => {
          if (!radio.checked) {
            radio.checked = true;
            radio.dispatchEvent(new Event('change'));
          }
        });

        container.appendChild(radio);
        container.appendChild(label);
        container.appendChild(input);

        return container;
      },

      buildRelatedGivenNamesSection: function(suggestion) {
        const wrapper = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-meta' });
        const variants = suggestion.relatedGivenNameVariants || [];
        if (!variants.length) {
          return wrapper;
        }

        const intro = document.createElement('div');
        intro.textContent = 'Associated given name variants:';
        wrapper.appendChild(intro);

        const list = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-list' });
        variants.forEach(variant => {
          const pill = document.createElement('span');
          pill.className = 'variant-pill';
          pill.textContent = `${this.titleCase(variant.firstName || '')} (${variant.frequency || 0})`;
          list.appendChild(pill);
        });

        wrapper.appendChild(list);
        return wrapper;
      },

      populateVariantGroupList: function() {
        const container = ZoteroNER_HTMLUtils.getElement('variant-groups-container');
        if (!container) {
          return false;
        }

        container.innerHTML = '';

        const suggestions = (this.analysisResults && Array.isArray(this.analysisResults.suggestions))
          ? this.analysisResults.suggestions
          : [];

        if (suggestions.length === 0) {
          this.showEmptyState('No variant groups were detected for the scanned surnames.');
          return false;
        }

        const emptyMsg = ZoteroNER_HTMLUtils.getElement('empty-message');
        if (emptyMsg) {
          emptyMsg.style.display = 'none';
        }

        suggestions.forEach((suggestion, index) => {
          if (!suggestion) {
            return;
          }
          this.ensureUserSelection(index, suggestion);
          const groupElement = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-group' });

          const header = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-group-header' });
          const title = ZoteroNER_HTMLUtils.createElement('h3');
          title.textContent = this.getGroupTitle(index, suggestion);
          header.appendChild(title);

          const summary = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-group-summary' });
          summary.textContent = this.getVariantSummaryText(suggestion);
          header.appendChild(summary);

          const recommendedValue = this.getDefaultNormalizationValue(suggestion);
          if (recommendedValue) {
            const recommended = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-meta' });
            recommended.innerHTML = this.buildRecommendedHTML(suggestion, recommendedValue);
            header.appendChild(recommended);
          }

          groupElement.appendChild(header);

          const variantsContainer = ZoteroNER_HTMLUtils.createElement('div', { class: 'variant-group-variants' });
          const variantList = this.buildVariantListElement(index, suggestion);

          if (variantList && variantList.childElementCount > 0) {
            variantsContainer.appendChild(variantList);
          } else {
            const emptyVariants = document.createElement('div');
            emptyVariants.className = 'variant-meta';
            emptyVariants.textContent = 'No variants detected.';
            variantsContainer.appendChild(emptyVariants);
          }

          const controls = this.buildSelectionControls(index, suggestion);
          variantsContainer.appendChild(controls);

          if (suggestion.type === 'given-name') {
            const relatedSection = this.buildRelatedGivenNamesSection(suggestion);
            if (relatedSection && relatedSection.childNodes.length) {
              variantsContainer.appendChild(relatedSection);
            }
          }

          groupElement.appendChild(variantsContainer);
          container.appendChild(groupElement);
        });

        const { variantDetailState } = this;
        if (variantDetailState && suggestions[variantDetailState.suggestionIndex]) {
          const { suggestionIndex, variantIndex } = variantDetailState;
          this.showVariantDetails(suggestionIndex, variantIndex, suggestions[suggestionIndex]);
        } else {
          const firstSuggestion = suggestions[0];
          if (firstSuggestion && Array.isArray(firstSuggestion.variants) && firstSuggestion.variants.length > 0) {
            const defaultVariantIndex = this.findRecommendedVariantIndex(firstSuggestion);
            const variantIndex = defaultVariantIndex !== null ? defaultVariantIndex : 0;
            this.showVariantDetails(0, variantIndex, firstSuggestion);
          } else {
            this.clearVariantDetails();
          }
        }

        this.refreshApplyButtonState();
        return true;
      },

      formatNameString: function(name) {
        if (typeof name === 'string') return name.trim();
        if (name && typeof name === 'object') {
          return `${name.firstName || ''} ${name.lastName || ''}`.trim();
        }
        return '';
      },

      escapeHTML: function(value) {
        if (typeof value !== 'string') {
          return '';
        }
        const map = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;'
        };
        return value.replace(/[&<>"']/g, (char) => map[char]);
      },

      formatSurnameKey: function(value) {
        if (!value || typeof value !== 'string') {
          return '';
        }
        const titleCased = value
          .split(/\s+/)
          .filter(Boolean)
          .map(part => part.charAt(0).toUpperCase() + part.slice(1))
          .join(' ');
        return this.escapeHTML(titleCased);
      },

      setApplyEnabled: function(enabled) {
        const applyButton = ZoteroNER_HTMLUtils.getElement('apply-button');
        if (applyButton) applyButton.disabled = !enabled || this.isProcessing;
      },

      setDialogBusy: function(isBusy) {
        this.isProcessing = isBusy;
        ZoteroNER_HTMLUtils.setHidden('progress-container', !isBusy);

        const applyButton = ZoteroNER_HTMLUtils.getElement('apply-button');
        if (applyButton) applyButton.disabled = isBusy;
      },

      updateProgress: function() {
        const progressLabel = ZoteroNER_HTMLUtils.getElement('progress-label');
        if (!progressLabel) return;

        if (this.analysisResults && this.analysisResults.suggestions) {
          if (this.isProcessing) {
            ZoteroNER_HTMLUtils.updateProgressBar(50);
            ZoteroNER_HTMLUtils.updateProgressLabel('Applying normalizations...');
          } else {
            ZoteroNER_HTMLUtils.updateProgressBar(100);
            ZoteroNER_HTMLUtils.updateProgressLabel('Analysis complete: ' + this.analysisResults.suggestions.length + ' variant groups found');
          }
        } else if (this.isProcessing) {
          ZoteroNER_HTMLUtils.updateProgressBar(50);
          ZoteroNER_HTMLUtils.updateProgressLabel('Analyzing library...');
        } else {
          ZoteroNER_HTMLUtils.updateProgressBar(0);
          ZoteroNER_HTMLUtils.updateProgressLabel('Ready');
        }
      },

      applySelected: async function() {
        if (this.isProcessing || !this.analysisResults || !Array.isArray(this.analysisResults.suggestions)) {
          return;
        }

        const preparedSuggestions = [];
        this.analysisResults.suggestions.forEach((suggestion, index) => {
          const selection = this.ensureUserSelection(index, suggestion);
          if (!selection || selection.apply === false) {
            return;
          }

          const normalizedValue = (selection.value || '').trim();
          if (!normalizedValue) {
            return;
          }

          const originalPrimary = suggestion.primary;
          const prepared = Object.assign({}, suggestion);
          prepared.originalPrimary = originalPrimary;
          prepared.primary = normalizedValue;
          prepared.variants = (suggestion.variants || []).map(variant => {
            const variantClone = Object.assign({}, variant);
            if (Array.isArray(variantClone.items)) {
              variantClone.items = variantClone.items.map(item => Object.assign({}, item));
            }
            return variantClone;
          });
          prepared.userSelection = Object.assign({}, selection);

          if (selection.mode === 'variant' && typeof selection.variantIndex === 'number') {
            prepared.selectedVariant = prepared.variants[selection.variantIndex] || null;
          }

          if (selection.mode === 'custom') {
            prepared.customNormalization = normalizedValue;
          }

          preparedSuggestions.push(prepared);
        });

        if (preparedSuggestions.length === 0) {
          this.alert('NER Author Name Normalizer', 'No normalization choices are selected to apply. Adjust your selections or close the dialog.');
          return;
        }

        this.setDialogBusy(true);

        let applyError = null;

        try {
          if (typeof ZoteroNER !== 'undefined' && ZoteroNER.ZoteroDBAnalyzer) {
            this.dbAnalyzer = new ZoteroNER.ZoteroDBAnalyzer();
          }

          if (!this.dbAnalyzer || typeof this.dbAnalyzer.applyNormalizationSuggestions !== 'function') {
            throw new Error('Zotero NER database analyzer is not available in this context.');
          }

          const results = await this.dbAnalyzer.applyNormalizationSuggestions(preparedSuggestions, false);

          this.alert('NER Author Name Normalizer',
            'Normalization selections applied!\n\n' +
            'Total selections: ' + results.totalSuggestions + '\n' +
            'Applied: ' + results.applied + '\n' +
            'Skipped: ' + results.skipped + '\n' +
            'Errors: ' + results.errors);

        } catch (error) {
          applyError = error;
          console.error(error);
          this.alert('Error', 'Failed to apply normalization selections: ' + error.message);
        } finally {
          this.setDialogBusy(false);
          if (!applyError) {
            window.close();
          }
        }
      }
    };

    // Event listeners
    document.getElementById('apply-button').addEventListener('click', function() {
      ZoteroNER_NormalizationDialog.applySelected();
    });

    document.getElementById('cancel-button').addEventListener('click', function() {
      window.close();
    });

    // Start
    ZoteroNER_NormalizationDialog.init();
  </script>
</body>
</html>